import und_lib.kind_util as kind_util
import understand
import sys

def ids():
    return [
        "IncludeNodes",
        "IncludeDepth",
        "IncludeSumCyclomatic",
        "IncludeCountLineCode",
        "IncludeByNodes",
        "IncludeByDepth",
        "IncludeBySumCyclomatic",
        "IncludeByCountLineCode"
    ]

def name(id):
    if id == "IncludeNodes":
        return "Include Nodes"
    elif id == "IncludeDepth":
        return "Include Depth"
    elif id == "IncludeSumCyclomatic":
        return "Include Sum Cyclomatic"
    elif id == "IncludeCountLineCode":
        return "Include Count Line Code"
    elif id == "IncludeByNodes":
        return "Include By Nodes"
    elif id == "IncludeByDepth":
        return "Include By Depth"
    elif id == "IncludeBySumCyclomatic":
        return "Include By Sum Cyclomatic"
    elif id == "IncludeByCountLineCode":
        return "Include By Count Line Code"

def description(id):
    if id == "IncludeNodes":
        return '''<p>Number of unique nodes in the include tree (including self).</p>
        <p>Counts all unique files included by this file, directly or indirectly,
        including the file itself.</p>'''
    elif id == "IncludeDepth":
        return '''<p>Maximum number of levels the include tree reaches.</p>
        <p>Measures the maximum include chain depth from this file.</p>'''
    elif id == "IncludeSumCyclomatic":
        return '''<p>Sum of Cyclomatic Complexities for each unique node in the include tree.</p>
        <p>Aggregates the cyclomatic complexity of all files in the include tree.</p>'''
    elif id == "IncludeCountLineCode":
        return '''<p>Sum of CountLineCode for each unique node in the include tree.</p>
        <p>Total lines of code across all files in the include tree.</p>'''
    elif id == "IncludeByNodes":
        return '''<p>Number of unique nodes in the included-by tree (not including self).</p>
        <p>Counts all unique files that include this file, directly or indirectly.</p>'''
    elif id == "IncludeByDepth":
        return '''<p>Maximum number of levels the included-by tree reaches (not including self).</p>
        <p>Measures the maximum include chain depth from any file to this file.</p>'''
    elif id == "IncludeBySumCyclomatic":
        return '''<p>Sum of Cyclomatic Complexities for each unique node in the included-by tree (not including self).</p>
        <p>Aggregates the cyclomatic complexity of all files that include this file.</p>'''
    elif id == "IncludeByCountLineCode":
        return '''<p>Sum of CountLineCode for each unique node in the included-by tree (not including self).</p>
        <p>Total lines of code across all files that include this file.</p>'''

def tags(id):
    return [
        'Target: Files',
        'Language: Any',
    ]

def test_available(metric, entkindstr):
    # Kind check if requested
    if entkindstr:
        my_kinds = set(understand.Kind.list_entity(kind_util.FILE_KIND_STR))
        test_kinds = set(understand.Kind.list_entity(entkindstr))
        return len(my_kinds.intersection(test_kinds)) > 0
    return True

def is_integer(id):
    return True

def test_entity(metric, ent):
    return ent.kind().check(kind_util.FILE_KIND_STR) and hasattr(metric, "cache")

def value(metric, ent):
    und_cache = metric.cache(metric.id())
    if und_cache:
        return calculate_metric(metric.id(), und_cache, ent)

def calculate_metric(metric_id, und_cache, ent):
    # Check cache first
    cached_value = und_cache.value(ent=ent)
    if cached_value is not None:
        return cached_value

    # Determine direction and whether to include self
    if metric_id.startswith("IncludeBy"):
        ref_type = "includeby"
        include_self = False
    else:
        ref_type = "include"
        include_self = True

    # Calculate the requested metric
    if metric_id == "IncludeDepth" or metric_id == "IncludeByDepth":
        result = calculate_max_depth(ent, ref_type, include_self, und_cache)
    else:
        # Collect unique nodes in the tree
        unique_nodes = collect_tree_nodes(ent, ref_type, include_self)

        if metric_id == "IncludeNodes":
            result = len(unique_nodes)
        elif metric_id == "IncludeByNodes":
            result = len(unique_nodes)
        elif metric_id == "IncludeSumCyclomatic":
            result = sum_metric(unique_nodes, "SumCyclomatic")
        elif metric_id == "IncludeCountLineCode":
            result = sum_metric(unique_nodes, "CountLineCode")
        elif metric_id == "IncludeBySumCyclomatic":
            result = sum_metric(unique_nodes, "SumCyclomatic")
        elif metric_id == "IncludeByCountLineCode":
            result = sum_metric(unique_nodes, "CountLineCode")
        else:
            result = None

    # Store in cache
    if result is not None:
        und_cache.insert(result, ent=ent)

    return result

# Traverse the tree and collect all unique nodes
def collect_tree_nodes(start_ent, ref_type, include_self):
    visited = set()
    to_visit = []

    if include_self:
        to_visit.append(start_ent)
    else:
        # Start with direct references, not including self
        refs = start_ent.refs(ref_type) if ref_type == "includeby" else start_ent.filerefs(ref_type)
        for ref in refs:
            to_visit.append(ref.ent())

    while to_visit:
        current = to_visit.pop()
        if current in visited:
            continue
        visited.add(current)

        # Add children to visit
        refs = current.refs(ref_type) if ref_type == "includeby" else current.filerefs(ref_type)
        for ref in refs:
            child = ref.ent()
            if child not in visited:
                to_visit.append(child)

    return visited

# Find entities that are part of a cycle in the graph
def find_cycle_members(adj):
    index_counter = [0]
    stack = []
    lowlinks = {}
    node_index = {}
    on_stack = set()
    cycle_members = set()
    old_limit = sys.getrecursionlimit()
    sys.setrecursionlimit(max(old_limit, len(adj) + 100))

    def strongconnect(v):
        node_index[v] = index_counter[0]
        lowlinks[v] = index_counter[0]
        index_counter[0] += 1
        stack.append(v)
        on_stack.add(v)
        for w in adj.get(v, []):
            if w not in node_index:
                strongconnect(w)
                lowlinks[v] = min(lowlinks[v], lowlinks[w])
            elif w in on_stack:
                lowlinks[v] = min(lowlinks[v], node_index[w])
        if lowlinks[v] == node_index[v]:
            scc = []
            while True:
                w = stack.pop()
                on_stack.remove(w)
                scc.append(w)
                if w == v:
                    break
            if len(scc) > 1:
                cycle_members.update(scc)

    for v in adj:
        if v not in node_index:
            strongconnect(v)

    sys.setrecursionlimit(old_limit)
    return cycle_members

# Calculate maximum depth of tree
def calculate_max_depth(start_ent, ref_type, include_self, und_cache):
    # Build a cache key specific to this ref_type to avoid collision
    cache_key = f"depth_{ref_type}"

    # Pre-cache all refs into a dict to avoid repeated database queries
    refs_map = {}
    to_collect = [start_ent]
    collected = set()
    while to_collect:
        cur = to_collect.pop()
        if cur in collected:
            continue
        collected.add(cur)
        children = [r.ent() for r in (cur.refs(ref_type) if ref_type == "includeby" else cur.filerefs(ref_type))]
        refs_map[cur] = children
        for child in children:
            if child not in collected:
                to_collect.append(child)

    # Find cycle members so we only skip caching for those
    cycle_members = find_cycle_members(refs_map)

    visited_in_path = set()

    def depth_recursive(ent, current_depth):
        # Check cache for this entity's depth
        cached_depth = und_cache.value(key=cache_key, ent=ent)
        if cached_depth is not None:
            return current_depth + cached_depth

        # Check for cycles
        if ent in visited_in_path:
            return current_depth - 1

        visited_in_path.add(ent)

        # Get children from pre-cached refs
        children = refs_map.get(ent, [])

        if not children:
            visited_in_path.remove(ent)
            und_cache.insert(0, key=cache_key, ent=ent)
            return current_depth

        max_child_depth = current_depth
        for child in children:
            max_child_depth = max(max_child_depth, depth_recursive(child, current_depth + 1))

        visited_in_path.remove(ent)

        # Only cache if not a cycle member (cycle members' depths are context-dependent)
        if ent not in cycle_members:
            depth_from_here = max_child_depth - current_depth
            und_cache.insert(depth_from_here, key=cache_key, ent=ent)

        return max_child_depth

    if include_self:
        return depth_recursive(start_ent, 0)
    else:
        max_depth = 0
        for child in refs_map.get(start_ent, []):
            max_depth = max(max_depth, depth_recursive(child, 1))
        return max_depth

# Sum a specific metric across all entities
def sum_metric(entities, metric_name):
    total = 0
    for ent in entities:
        metric_value = ent.metric(metric_name)
        if metric_value is not None:
            total += metric_value
    return total
