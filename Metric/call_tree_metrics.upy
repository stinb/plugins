import und_lib.kind_util as kind_util
import understand
import sys

def ids():
    return [
        "CallNodes",
        "CallSumCyclomatic",
        "CallCountLineCode",
        "CallByNodes",
        "CallByDepth",
        "CallBySumCyclomatic",
        "CallByCountLineCode"
    ]

def name(id):
    if id == "CallNodes":
        return "Call Nodes"
    elif id == "CallSumCyclomatic":
        return "Call Sum Cyclomatic"
    elif id == "CallCountLineCode":
        return "Call Count Line Code"
    elif id == "CallByNodes":
        return "Call By Nodes"
    elif id == "CallByDepth":
        return "Call By Depth"
    elif id == "CallBySumCyclomatic":
        return "Call By Sum Cyclomatic"
    elif id == "CallByCountLineCode":
        return "Call By Count Line Code"

def description(id):
    if id == "CallNodes":
        return '''<p>The number of unique nodes in the call tree (including self).</p>
        <p>Counts all unique functions called by this function, directly or indirectly,
        including the function itself.</p>'''
    elif id == "CallSumCyclomatic":
        return '''<p>Sum of Cyclomatic Complexities for each unique node in the call tree.</p>
        <p>Aggregates the cyclomatic complexity of all functions in the call tree,
        providing a measure of total complexity reachable from this function.</p>'''
    elif id == "CallCountLineCode":
        return '''<p>Sum of CountLineCode for each unique node in the call tree.</p>
        <p>Total lines of code across all functions in the call tree.</p>'''
    elif id == "CallByNodes":
        return '''<p>The number of unique nodes in the called-by tree (not including self).</p>
        <p>Counts all unique functions that call this function, directly or indirectly.</p>'''
    elif id == "CallByDepth":
        return '''<p>Maximum number of levels the called-by tree reaches (not including self).</p>
        <p>Measures the maximum call chain depth from any caller to this function.</p>'''
    elif id == "CallBySumCyclomatic":
        return '''<p>Sum of Cyclomatic Complexities for each unique node in the called-by tree (not including self).</p>
        <p>Aggregates the cyclomatic complexity of all functions that call this function.</p>'''
    elif id == "CallByCountLineCode":
        return '''<p>Sum of CountLineCode for each unique node in the called-by tree (not including self).</p>
        <p>Total lines of code across all functions that call this function.</p>'''

def tags(id):
    return [
        'Target: Functions',
        'Language: Any',
    ]

def test_available(metric, entkindstr):
    # Kind check if requested
    if entkindstr:
        my_kinds = set(understand.Kind.list_entity(kind_util.FUNCTION_KIND_STR))
        test_kinds = set(understand.Kind.list_entity(entkindstr))
        return len(my_kinds.intersection(test_kinds)) > 0
    return True

def is_integer(id):
    return True

def test_entity(metric, ent):
    return ent.kind().check(kind_util.FUNCTION_KIND_STR) and hasattr(metric, "cache")

def value(metric, ent):
    und_cache = metric.cache(metric.id())
    if und_cache:
        return calculate_metric(metric.id(), und_cache, ent)

def calculate_metric(metric_id, und_cache, ent):
    # Check cache first
    cached_value = und_cache.value(ent=ent)
    if cached_value is not None:
        return cached_value

    # Determine direction and whether to include self
    if metric_id.startswith("CallBy"):
        ref_type = "callby"
        include_self = False
    else:
        ref_type = "call"
        include_self = True

    # Calculate the requested metric
    if metric_id == "CallByDepth":
        result = calculate_max_depth(ent, ref_type, und_cache)
    else:
        # Collect unique nodes in the tree
        unique_nodes = collect_tree_nodes(ent, ref_type, include_self)

        if metric_id == "CallNodes":
            result = len(unique_nodes)
        elif metric_id == "CallByNodes":
            result = len(unique_nodes)
        elif metric_id == "CallSumCyclomatic":
            result = sum_metric(unique_nodes, "Cyclomatic")
        elif metric_id == "CallCountLineCode":
            result = sum_metric(unique_nodes, "CountLineCode")
        elif metric_id == "CallBySumCyclomatic":
            result = sum_metric(unique_nodes, "Cyclomatic")
        elif metric_id == "CallByCountLineCode":
            result = sum_metric(unique_nodes, "CountLineCode")
        else:
            result = None

    # Store in cache
    if result is not None:
        und_cache.insert(result, ent=ent)

    return result

# Traverse the tree and collect all unique nodes
def collect_tree_nodes(start_ent, ref_type, include_self):
    visited = set()
    to_visit = []

    if include_self:
        to_visit.append(start_ent)
    else:
        # Start with direct references, not including self
        for ref in start_ent.refs(ref_type + ' ~inactive', kind_util.FUNCTION_KIND_STR_WITH_UNRESOLVED, True):
            to_visit.append(ref.ent())

    while to_visit:
        current = to_visit.pop()
        if current in visited:
            continue
        visited.add(current)

        # Add children to visit
        for ref in current.refs(ref_type + ' ~inactive', kind_util.FUNCTION_KIND_STR_WITH_UNRESOLVED, True):
            child = ref.ent()
            if child not in visited:
                to_visit.append(child)

    return visited

# Find entities that are part of a cycle in the graph
def find_cycle_members(adj):
    index_counter = [0]
    stack = []
    lowlinks = {}
    node_index = {}
    on_stack = set()
    cycle_members = set()
    old_limit = sys.getrecursionlimit()
    sys.setrecursionlimit(max(old_limit, len(adj) + 100))

    def strongconnect(v):
        node_index[v] = index_counter[0]
        lowlinks[v] = index_counter[0]
        index_counter[0] += 1
        stack.append(v)
        on_stack.add(v)
        for w in adj.get(v, []):
            if w not in node_index:
                strongconnect(w)
                lowlinks[v] = min(lowlinks[v], lowlinks[w])
            elif w in on_stack:
                lowlinks[v] = min(lowlinks[v], node_index[w])
        if lowlinks[v] == node_index[v]:
            scc = []
            while True:
                w = stack.pop()
                on_stack.remove(w)
                scc.append(w)
                if w == v:
                    break
            if len(scc) > 1:
                cycle_members.update(scc)

    for v in adj:
        if v not in node_index:
            strongconnect(v)

    sys.setrecursionlimit(old_limit)
    return cycle_members

# Calculate maximum depth of tree (not including start_ent for callby)
def calculate_max_depth(start_ent, ref_type, und_cache):
    # Build a cache key specific to this ref_type to avoid collision
    cache_key = f"depth_{ref_type}"
    ref_str = ref_type + ' ~inactive'

    # Pre-cache all refs into a dict to avoid repeated database queries
    refs_map = {}
    to_collect = [start_ent]
    collected = set()
    while to_collect:
        cur = to_collect.pop()
        if cur in collected:
            continue
        collected.add(cur)
        children = [r.ent() for r in cur.refs(ref_str, kind_util.FUNCTION_KIND_STR_WITH_UNRESOLVED, True)]
        refs_map[cur] = children
        for child in children:
            if child not in collected:
                to_collect.append(child)

    # Find cycle members so we only skip caching for those
    cycle_members = find_cycle_members(refs_map)

    visited_in_path = set()

    def depth_recursive(ent, current_depth):
        # Check cache for this entity's depth
        cached_depth = und_cache.value(key=cache_key, ent=ent)
        if cached_depth is not None:
            return current_depth + cached_depth

        # Check for cycles
        if ent in visited_in_path:
            return current_depth - 1

        visited_in_path.add(ent)

        # Get children from pre-cached refs
        children = refs_map.get(ent, [])

        if not children:
            visited_in_path.remove(ent)
            und_cache.insert(0, key=cache_key, ent=ent)
            return current_depth

        max_child_depth = current_depth
        for child in children:
            max_child_depth = max(max_child_depth, depth_recursive(child, current_depth + 1))

        visited_in_path.remove(ent)

        # Only cache if not a cycle member (cycle members' depths are context-dependent)
        if ent not in cycle_members:
            depth_from_here = max_child_depth - current_depth
            und_cache.insert(depth_from_here, key=cache_key, ent=ent)

        return max_child_depth

    # Start depth calculation from the entity's children
    max_depth = 0
    for child in refs_map.get(start_ent, []):
        max_depth = max(max_depth, depth_recursive(child, 1))

    return max_depth

# Sum a specific metric across all entities
def sum_metric(entities, metric_name):
    total = 0
    for ent in entities:
        metric_value = ent.metric(metric_name)
        if metric_value is not None:
            total += metric_value
    return total
