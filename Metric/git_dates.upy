# A Metrics Plugin for Git dates

import datetime
import os
import understand
import subprocess

gitMets = {
  "GitDaysSinceCreated" : ["Days since creation", "The number of days since the file's oldest commit in Git"],
  "GitDaysSinceLastModified" : ["Days since modified", "The number of days since the file's most recent commit in Git"]
}

def ids():
  """
  Required, a list of metric ids that this script provides

  For example, CountLineCode is a metric id.
  """
  return list(gitMets.keys())

def name(id):
  """
  Required, the name of the metric given by id.

  For example, CountLineCode -> "Source Lines of Code"
  """
  return gitMets.get(id,["",""])[0]

def description(id):
  """
  Required, the description of the metric given by id

  For example, CountLineCode -> "Number of lines containing source code"
  """
  return gitMets.get(id,["",""])[1]

def is_integer(id):
   """
   Optional, return True if the metric value is an integer.

   If this function it not implemented, it is assumed false, meaning the
   value should be represented as a double/float.
   """
   return True

# One of the following three test functions should return True.
def test_entity(metric, ent):
  """
  Optional, return True if metric can be calculated for the given entity.
  """
  return ent.kind().check("file ~unknown ~unresolved") and has_git(metric)

def test_architecture(metric, arch):
  """
  Optional, return True if metric can be calculated for the given architecture.
  """
  return has_cache(metric) or ((arch.longname().startswith("Directory Structure/") or arch.name() == "Directory Structure") and has_git(metric))

def test_global(metric, db):
  """
  Optional, return True if metric can be calculated for the given database.
  """
  return has_git(metric)

def test_available(metric,entkindstr):
  """
  Optional, return True if the metric is potentially available.

  This is used when there isn't a specific target for the metric, like lists
  of metrics available for export, or for a treemap.

  Use metric.db() to retrieve the database. If the metric is language specific,
  the code might look like this:
    return "Ada" in metric.db().language()

  entkindstr may be empty. If it is empty, return True as long as the metric
  is available for an entity, architecture, or the project as a whole.

  If entkindstr is not empty, return True only if the metric is available for
  entities matching the provided kind string. Kind checks are performed like
  this:
    my_kinds = set(understand.Kind.list_entity(myMetricKindString)
    test_kinds = set(understand.Kind.list_entity(entkindstr)
    return len(my_kinds.intersection(test_kinds)) > 0
  """
  if not has_git(metric):
    return False

  # Kind check if requested
  if entkindstr:
    my_kinds = set(understand.Kind.list_entity("file ~unknown ~unresolved"))
    test_kinds = set(understand.Kind.list_entity(entkindstr))
    return len(my_kinds.intersection(test_kinds)) > 0

  # Git repository was found, so git metrics are available
  return True

def value(metric, target):
  """
  Required, return the metric value for the target. The target may be
  an entity, architecture, or database depending on which test functions
  returned True.
  """
  oldest = metric.id() == "GitDaysSinceCreated"
  today = datetime.date.today()

  if has_cache(metric):
    und_cache = metric.cache("Git")
    if isinstance(target, understand.Db):
      files = target.lookup_arch("Directory Structure").ents(True)
    elif isinstance(target, understand.Arch):
      files = target.ents(True)
    else: # entity
      files = [target]

    days = -1
    for file in files:
      dateList = und_cache.value(key="dates", file=file, value=[])
      if dateList:
        if oldest:
          delta = today - datetime.datetime.fromisoformat(dateList[-1]).date()
          if days == -1 or delta.days > days:
            days = delta.days
        else:
          delta = today - datetime.datetime.fromisoformat(dateList[0]).date()
          if days == -1 or delta.days < days:
            days = delta.days
    if days == -1:
      return None
    return days

  path = ""
  if isinstance(target, understand.Db):
    path = "."
  elif isinstance(target, understand.Arch):
    # This assumes that the root of the directory structure architecture is
    # at the same location as the Understand project. If the Understand project
    # is not at the root of directory structure, this line must be updated
    if target.name() == "Directory Structure":
      path = "."
    else:
      path = '/'.join(target.longname().split('/')[1:])
  else: # entity, must be file
    path = target.longname()

  # The git repository is assumed to be in the same folder as the Understand
  # project. If this is not True for your project, update the working directory
  # accordingly.
  wd = os.path.dirname(metric.db().name())
  startinfo = None
  if os.name == 'nt':
    startinfo = subprocess.STARTUPINFO()
    startinfo.dwFlags |= subprocess.STARTF_USESHOWWINDOW
  try:
    gitlog = subprocess.run(["git", "log", "--format=%aI", "--", path], check=True, capture_output=True, cwd=wd, text=True, startupinfo=startinfo, encoding='latin-1')
  except Exception as e:
    return None # not part of the repository?

  dateList = gitlog.stdout.splitlines()
  if dateList:
    if oldest:
      delta = today - datetime.datetime.fromisoformat(dateList[-1]).date()
      return delta.days
    else:
      delta = today - datetime.datetime.fromisoformat(dateList[0]).date()
      return delta.days

def has_git(metric):
  # If the built-in Git cache has content, then the repository for the project
  # was found
  if has_cache(metric):
    return True

  # This assumes that the git repository, if it exists, is in the same location
  # as the Understand project. If that is not true for your repository, you
  # would need to update this code.
  path = os.path.join(os.path.dirname(metric.db().name()), ".git")
  return os.path.exists(path)

def has_cache(metric):
  return hasattr(metric, "cache") and metric.cache("Git") and not metric.cache("Git").is_empty()

