"""
Create a custom architecture for a C/C++ codebase that filters filenames matching certain patterns that are often used for auxiliary 
purposes, testing, examples, or auto-generated content, which might not be central to your analysis. 

You should adjust these exclusions based on the specific context and requirements of your project. For instance, if your analysis 
aims to include testing mechanisms, you should not exclude test files.

This filtered architecture can then be used to easily select only relevant source files when running CodeCheck on the codebase.
"""

import re

# List of file extensions/patterns to place in the exclude architecture (these must be pre-formatted as regular expression strings)
EXCLUDED_EXTS = [
                 # Autogenerated Files
                 "\*\.moc\.cpp",          # Qt Meta-Object Compiler files
                 "moc_\*\.cpp",           # Qt Meta-Object Compiler files
                 "ui_\*\.h",              # Qt User Interface Compiler header files
                 "\*_pb2\.c",             # Protocol Buffers
                 "\*_pb2\.h",             # Protocol Buffers
                 "lex\.yy\.c",            # Lex/Flex generated files
                 "y\.tab\.c",             # Yacc/Bison generated files
                 "y\.tab\.h",             # Yacc/Bison generated files
                 "\*_wrap\.c",            # SWIG generated files
                 "\*_wrap\.h",            # SWIG generated files
                 # Test Files
                 "test_\*\.c",
                 "test_\*\.h",
                 "\*_test\.c",
                 "\*_test\.h",
                 "unittest_\*\.c",
                 "unittest_\*\.h",
                 "\*_unittest\.c",
                 "\*_unittest\.h",       
                 # Example or Sample Files
                 "example\*\.c",
                 "example\*\.h",
                 "sample\*\.c",
                 "sample\*\.h",
                 "demo\*\.c",
                 "demo\*\.h",               
                 # Template or Placeholder Files
                 "template\.c",
                 "template\.h",
                 "placeholder\.c",
                 "placeholder\.h",                 
                 # Deprecated or Obsolete Files
                 "deprecated_\*\.c",
                 "deprecated_\*\.h",
                 "obsolete_\*\.c",
                 "obsolete_\*\.h",                     
                 # Configuration or Setup Files
                 "config\.c",
                 "config\.h",
                 "setup\.c",
                 "setup\.h",                      
                 # Utility or Helper Files
                 "util\.c",
                 "util\.h",
                 "helper\.c",
                 "helper\.h",
                 "common\.c",
                 "common\.h",
                 "misc\.c",
                 "misc\.h",                  
                 ]


def name():
  return "File Categorizer Architecture"


def generate(arch, db):

  include_arch = "Included"
  exclude_arch = "Excluded"

  for file in db.ents("file ~unknown ~unresolved"):

    # Grab the filename
    excluded = False
    filename = file.simplename()   # This can be changed to longname() if the full path to the file is needed
    filename = str(filename)
    

    # Iterate through each regular expression string comparing to the filename
    for ext in EXCLUDED_EXTS:
      if re.search(ext, filename):
        arch.map(file, exclude_arch)
        excluded = True
    
    # If the file hasn't been placed in the excluded architecture, place in the included architecture
    if excluded == False:
      arch.map(file, include_arch)