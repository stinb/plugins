import understand

def name():
  """
  Required, the name of the ireport.
  """
  return "Mermaid Graph\\Data Flow"

def description():
  """
  Optional, the description to display in the plugin manager.
  """
  return '''Create Mermaid input for a Data Flow Graph
  '''

def tags():
  """
  Optional, the tags to display in the plugin manager
  """
  return [
    'Target: Objects',
    'Language: Any',
    'Mermaid Graph',
  ]

OBJECT_KINDS="Object, Macro, Variable, Field, Property"
FUNCTION_KINDS="Function, Method"
BOTH_KINDS=OBJECT_KINDS + "," + FUNCTION_KINDS

def test_entity(entity):
  """
  Optional method, return true if report is valid for the entity
  """
  return entity.kind().check(OBJECT_KINDS)

def init(report, entity):
  """
  Optional method, define options that can be changed by the user
  """
  report.options().integer('Data Flow In Depth', 'Data Flow In Depth', 3, 0, 10)
  report.options().integer('Data Flow Out Depth', 'Data Flow Out Depth', 3, 0, 10)

  report.options().choice("Name", "Name", ["Shortname", "Fullname", "None (Overview Mode)"], "Shortname")
  report.options().choice("Filename", "Filename", ["Shortname", "Fullname", "Relative", "None"], "None")
  report.options().checkbox("Unresolved", "Unresolved", True)
  report.options().checkbox("Local", "Local", True)

def generate(report, entity, pageId):
  """
  Required, generate the report

  The pageId parameter is optional. It will be an empty string the first
  time a report is generated. On subsequent generations, it can be any
  value returned from pages() or provided as a pageId to report.pagelink()
  or report.breadcrumbs() functions.
  """
  # Create the mermaid graph
  report.print("%% Copy the text or export the interactive report as text\n")
  report.print("%% Data Flow Graph for Mermaid generated by Understand\n")
  report.print("flowchart LR\n") # begin the graph

  nodes = dict()

  # create start node
  grab_node(report, nodes, entity)

  # draw forward relations
  fdepth = int(report.options().lookup('Data Flow Out Depth'))
  draw_tree(report, entity, nodes, fdepth, True)

  # draw inverse relations
  idepth = int(report.options().lookup('Data Flow In Depth'))
  draw_tree(report, entity, nodes, idepth, False)


def draw_tree(report, entity, nodes, depth, isForward):
  visited = set()
  curLevel = [entity]

  while curLevel and depth != 0:
    nextLevel = []
    for ent in curLevel:
      if ent in visited:
        continue # already expanded entity
      visited.add(ent)

      head = grab_node(report,nodes,ent)

      # Draw edges for this node
      refs = []
      if ent.kind().check(FUNCTION_KINDS):
        if isForward: # Data flow out
          refs.extend(ent.refs("set, modify, define", OBJECT_KINDS, False))
          refs.extend(ent.refs("call", FUNCTION_KINDS, False))
        else: #Data flow in
          refs.extend(ent.refs("use ~macrodefine", OBJECT_KINDS, False))
          refs.extend(ent.refs("callby", FUNCTION_KINDS, False))
      else:
        if isForward: # Data flow out
          refs.extend(ent.refs("useby ~macrodefine", BOTH_KINDS, False))
        else: # Data flow in
          refs.extend(ent.refs("setby, modifyby, definein", BOTH_KINDS, False))

      for ref in refs:
        tailEnt = ref.ent()
        if ((not report.options().lookup("Unresolved") and
             tailEnt.kind().check("unresolved, unknown, undefined")) or
             (not report.options().lookup("Local") and
              tailEnt.kind().check("local"))):
          continue
        nextLevel.append(tailEnt)
        tail = grab_node(report,nodes,tailEnt)

        lbl = ""
        if (not ref.kind().check("Callby")):
          lbl="|" + ref.kindname() + "|"
        if isForward:
          report.print("    {tail}-->{label}{head}\n".format(tail=head, label=lbl, head=tail))
        else:
          report.print("    {tail}-->{label}{head}\n".format(tail=tail, label=lbl, head=head))
    # End loop over current level
    curLevel = nextLevel
    if depth > 0:
      depth -= 1

def grab_node(report, nodes, ent):
  if ent in nodes:
    return nodes[ent]

  label = ""

  # Name Option
  if report.options().lookup("Name") == "Fullname":
    label += ent.longname()
  elif report.options().lookup("Name") == "Shortname":
    label += ent.name()

  # Filename option
  filename = report.options().lookup("Filename")
  if filename != "None" and not ent.kind().check("file"):
    defref = ent.ref("definein,declarein")
    if defref:
      if filename == "Relative":
        label += "\n" + defref.file().relname()
      elif filename == "Fullname":
        label += "\n" + defref.file().longname()
      else:
        label += "\n" + defref.file().name()

  label =label.replace("\"", "#quot;")

  shape = ""
  if ent.kind().check('unresolved, unknown, undefined'):
    shape="shape: \"hexagon\"," # closest to octagon that mermaid supports
  elif ent.kind().check(OBJECT_KINDS):
    shape="shape: \"stadium\"," # closest to oval that mermaid supports

  # Create the node for Mermaid
  node = "node" + str(len(nodes))
  nodes[ent] = node

  report.print("    {id}@{{ {shape} label: \"{label}\"}}\n".format(id=node, label=label, shape=shape))

  return node
