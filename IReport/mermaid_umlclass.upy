import understand
import re


def name():
  """
  Required, the name of the ireport.
  """
  return "Mermaid Graph\\UML Class Diagram"

def description():
  """
  Optional, the description to display in the plugin manager.
  """
  return '''Create Mermaid input for a UML Class Diagram
  '''

def tags():
  """
  Optional, the tags to display in the plugin manager
  """
  return [
    'Target: Classes',
    'Target: Files',
    'Target: Architectures',
    'Language: Any',
    'Mermaid Graph',
  ]

def test_global(db):
  """
  Optional method, return true for project level reports
  """
  return True

def test_entity(ent):
  """
  Optional method, return true if report is valid for the entity
  """
  if ent.kind().check(CLASS_KIND):
    return True # Entity is a class
  if ent.kind().check(TYPEDEF_KIND) and typeFor(ent).kind().check(CLASS_KIND):
    return True # Typedef for a class
  if ent.kind().check(MAY_HAVE_CLASSES_KIND):
    return classes(ent)
  return False

def test_architecture(arch):
  """
  Optional method, return true if report is valid for the architecture
  """
  return True


def init(report, target):
  """
  Optional method, define options that can be changed by the user
  """
  report.options().checkbox("Show Solo Classes", "Show Solo Classes", True)
  report.options().checkbox("Show Class Details", "Show Class Details", True)
  report.options().checkbox("Show Related Classes", "Show Related Classes", True)
  report.options().checkbox("Include Standard Libraries", "Include Standard Libraries", True)
  report.options().checkbox("Show Return Type", "Show Return Type", True)
  report.options().choice("Layout", "Layout",["Horizontal","Vertical"], "Horizontal")


def generate(report, target, pageId):
  """
  Required, generate the report

  The pageId parameter is optional. It will be an empty string the first
  time a report is generated. On subsequent generations, it can be any
  value returned from pages() or provided as a pageId to report.pagelink()
  or report.breadcrumbs() functions.
  """
  report.print("%% Copy the text or export the interactive report as text\n")
  report.print("%% UML Class Diagram for Mermaid generated by Understand\n")
  report.print("classDiagram\n") # begin the class diagram

  if report.options().lookup("Layout") == "Vertical":
    report.print("    direction RL")

  allowLibrary = report.options().lookup("Include Standard Libraries")
  allowSolo = report.options().lookup("Show Solo Classes")

  ids = dict()
  for cls in sorted(classes(target), key=lambda ent: ent.name()):
    if cls.library() and not allowLibrary:
      continue

    bases = set()
    for ref in cls.refs(REFERENCE_BASE_KIND):
      if not ref.ent().library() or allowLibrary:
        bases.add(ref.ent())

    derived = set()
    for ref in cls.refs(REFERENCE_DERIVE_KIND):
      if not ref.ent().library() or allowLibrary:
        derived.add(ref.ent())

    if not allowSolo and not bases and not derived:
      continue

    printClass(report, cls, ids)



CLASS_KIND= (
 "class ~unknown ~unresolved,"
  "struct ~unknown ~unresolved,"
  "ada record type ~unknown ~unresolved"
)
TYPEDEF_KIND = "typedef ~unknown ~unresolved"
FILE_KIND = "file ~unknown ~unresolved"
PYTHON_PACKAGE_KIND = "python package ~unknown"
MAY_HAVE_CLASSES_KIND = FILE_KIND + "," + PYTHON_PACKAGE_KIND
UNNAMED_STRUCT_KIND = "c struct unnamed"
REFERENCE_BASE_KIND = "derivefrom, base, extend, inherit"
REFERENCE_DERIVE_KIND = "derive, extendby, inheritby"

def classes(target):
  classes = set()
  files = set()
  pythonPackages = set()

  if isinstance(target, understand.Db):
    for ent in target.ents(CLASS_KIND):
      classes.add(typedefFor(ent))
  elif isinstance(target, understand.Arch):
    for ent in target.entities(True):
      if ent.kind().check(CLASS_KIND):
        classes.add(typedefFor(ent))
      elif ent.kind().check(FILE_KIND):
        files.add(ent)
      elif ent.kind().check(PYTHON_PACKAGE_KIND):
        pythonPackages.add(ent)
  else:
    if target.kind().check(TYPEDEF_KIND):
      classes.add(target)
    elif target.kind().check(CLASS_KIND):
      classes.add(typedefFor(target))
    elif target.kind().check(FILE_KIND):
      files.add(target)
    elif target.kind().check(PYTHON_PACKAGE_KIND):
      pythonPackages.add(target)

  for package in pythonPackages:
    for ref in package.refs("python contain", FILE_KIND, True):
      files.add(ref.ent())

  for file in files:
    for ref in file.filerefs("define,ada declare", CLASS_KIND, True):
      classes.add(typedefFor(ref.ent()))

  return classes

def typedefFor(ent):
  if ent.kind().check(UNNAMED_STRUCT_KIND):
    refs = ent.refs("c typedby", TYPEDEF_KIND, True)
    if refs:
      return refs[0].ent()
  return ent

def typeFor(ent):
  refs = ent.refs("typed")
  if refs:
    return refs[0].ent()
  return ent

def printClass(report, cls, ids, expandBase = True, expandDerive = True):
  if cls in ids:
    return ids[cls] # Already visited node

  # Show the class in mermaid
  id = "class" + str(len(ids))
  ids[cls] = id
  report.print('    class {id}["{label}"]\n'.format(id=id, label=cls.name()))

  # Add class details
  if report.options().lookup("Show Class Details"):
    # May be looking at a typedef. Use the actual type to get members
    members = typeFor(cls).refs("operation,define,declare", unique=True)
    if members:
      report.print('    class {id}{{\n'.format(id=id))
      for ref in sorted(members, key=lambda ref: (ref.ent().kind().name(), ref.ent().name())):
        member = ref.ent()
        lbl = "+" #public
        if member.kind().check("protected"):
          lbl = "#" # protected
        elif member.kind().check("private"):
          lbl = "-" # private

        lbl += member.name()

        type = ""
        if member.type():
          # Mermaid type expects templates <> to be replaced with ~
          type = member.type()
          type = type.replace("<", "~")
          type = type.replace(">", "~")
          # Types are displayed at the end, and if they are pointer types
          # the * is interpreted as abstract. It doesn't seem like there's
          # a way to escape the star. The choice is to repeat it twice, so
          # only the last one is interpreted as abstract, or stick the whole
          # thing in quotes. For now, add an extra star
          if type.endswith("*"):
            type += "*"

        if member.kind().check("procedure,function,method"):
          params = []
          for param in member.parameters(True).split(','):
            # Show parameters UML style (name: type) instead of type name
            m = re.match(r"(.*\s\W?)(\w+)", param)
            if m:
              params.append(m.group(2) + ": " + m.group(1))
            else:
              params.append(param)
          lbl += "(" + ",".join(params) + ")"
          if report.options().lookup("Show Return Type") and type:
            lbl += " " + type

          if member.kind().check("pure"):
            lbl += " Pure"
          if member.kind().check("virtual"):
            lbl += " Virtual"
          if member.kind().check("ada abstract"):
            lbl += " Abstract"
        elif member.kind().check("component,object,variable,field,attribute,property"):
          if type:
            lbl += ": " + type
          # Don't worry about values for now. Values may include problematic
          # mermaid characters and can be very long
        report.print("        " + lbl + "\n")
      # end for loop
      report.print("    }\n") # end the class
    # end member existing  if
  # end class details if

  if not report.options().lookup("Show Related Classes"):
    return id

  allowLibrary = report.options().lookup("Include Standard Libraries")

  if expandBase:
    for ref in cls.refs(REFERENCE_BASE_KIND):
      if not ref.ent().library() or allowLibrary:
        baseId = printClass(report, ref.ent(), ids, expandBase=True, expandDerive=False)
        report.print("    {base} <|-- {derived}\n".format(base=baseId, derived=id))

  if expandDerive:
    for ref in cls.refs(REFERENCE_DERIVE_KIND):
      if not ref.ent().library() or allowLibrary:
        deriveId = printClass(report, ref.ent(), ids, expandBase=False, expandDerive=True)
        report.print("    {base} <|-- {derived}\n".format(base=id, derived=deriveId))

  return id

