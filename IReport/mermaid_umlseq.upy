import understand

def name():
  """
  Required, the name of the ireport.
  """
  return "Mermaid Graph\\UML Sequence Diagram"

def description():
  """
  Optional, the description to display in the plugin manager.
  """
  return '''Create Mermaid input for a UML Sequence Diagram

  <p>Mermaid is a web-based graph tool. Mermaid input is text, so it's
  recommended to export this interactive report as a text file which can
  then be used directly with Mermaid.</p>

  <br>
  <img src=".doc/mermaid_umlseq.png"/>
  '''

def tags():
  """
  Optional, the tags to display in the plugin manager
  """
  return [
    'Target: Functions',
    'Language: Any',
    'Mermaid Graph',
  ]


def test_entity(ent):
  """
  Optional method, return true if report is valid for the entity
  """
  return ent.kind().check("function, method, procedure, task") and len(diagramRefs(ent)) > 0


def support_abort():
  """
  Optional method, return True if this report can be aborted.

  Use report.is_aborted() to check if an abort has been requested
  """
  return True


def init(report, target):
  """
  Optional method, define options that can be changed by the user
  """
  report.options().choice("Name Format", "Name Format", ["Short", "Long"], "Short")
  report.options().checkbox("Show Edge Labels", "Show Edge Labels", True)
  report.options().checkbox("Parameters", "Parameters", False)

  report.options().checkbox("Cluster", "Cluster", True)
  report.options().checkbox("Collapse 'else if'", "Collapse 'else if'", True)

  # With build 1225+, the integer option supports a range.
  report.options().integer("Level", "Level", 1, 1, 10)

  report.options().checkbox("Show Returns", "Show Returns", True)
  report.options().checkbox("Show Self Calls", "Show Self Calls", True)
  report.options().checkbox("Function Pointer", "Function Pointer", True)
  report.options().checkbox("Functional Macros", "Functional Macros", True)

  report.options().choice("Show Unresolved Entities","Show Unresolved Entities", ["Hide", "Show", "Show in 'Unresolved Column'"], "Hide")
  report.options().choice("Aggregate by Architecture", "Aggregate by Architecture", ["Off"] + [arch.name() for arch in report.db().root_archs()], "Off")


def generate(report, ent, pageId):
  """
  Required, generate the report

  The pageId parameter is optional. It will be an empty string the first
  time a report is generated. On subsequent generations, it can be any
  value returned from pages() or provided as a pageId to report.pagelink()
  or report.breadcrumbs() functions.
  """
  diagram = UmlSequenceDiagram(report)
  diagram.draw(ent)

class UmlSequenceDiagram:
  """
  The UML Sequence Diagram algorithm is recursive. Bundle together all the
  variables into a class to reduce the parameters passed around.
  """
  def __init__(self, report):
    self.report = report
    self.indent = 0
    self.level = report.options().lookup("Level")
    self.visited = set()

    # Track the objects that appear along the top of the diagram by columns
    self.participants = dict() # entity -> id (string)

    # Track the clusters
    self.controlFlowNodeStack = list()
    self.lexerCache = dict() # lexers needed for control flow text

    # Support grouping by architecture
    self.arch = None
    archName = report.options().lookup("Aggregate by Architecture")
    if archName != "Off":
      self.arch = report.db().lookup_arch(archName)


  def draw(self, ent):
    self.printLine("%% Copy the text or export the interactive report as text")
    self.printLine("%% UML Sequence Diagram for Mermaid generated by Understand")
    self.printLine("sequenceDiagram") # begin the sequence diagram
    self.indent += 1

    # Can't figure out how to create a "found message" in mermaid. So, have
    # the first participant be an actor
    self.printLine("actor fm as ")

    # Add the activation box for the start entity, connecting it to
    # the found message. addActivation is recursive, and builds
    # the main part of the diagram
    self.addActivation("fm", ent)

  def participantIdOf(self, ent):
    """
    Returns the participant identifer for the entity.
    """
    participant = None

    if not ent.kind().check("unresolved") or self.report.options().lookup("Show Unresolved Entities") == "Show":
      # If aggregating by architecture, search for an architecture containing
      # the entity
      if self.arch:
        # Get the list of architectures the entity belongs to, including implicit
        for a in self.report.db().archs(ent, True):
          # Find the root architecture
          par = a
          while par and par != self.arch:
            par = par.parent()
          if par:
            # root matched, use this arch as the column parent
            participant = a
            break

      # No arch parent, check for an entity parent
      if not participant:
        par = ent.parent()
        if par and par.kind().check("class,package,interface,struct,program,c# member property"):
          # prefer class parent
          participant = par
        else:
          file = entFile(ent)
          if file: # File is next priority
            participant = file
          elif par: # any parent
            participant = par
          else: # entity is it's own column
            participant = ent

    # Check for existing id for the participant
    if participant in self.participants:
      return self.participants[participant]

    # id didn't exist, create the participant
    participantId = "c" + str(len(self.participants)+1)
    self.participants[participant] = participantId

    # and set the label
    name = "Unresolved"
    if participant:
      name = self.formattedName(participant)

    self.printLine("participant {pid} as {name}".format(pid=participantId, name=name))

    return participantId


  def addActivation(self, fromId, ref):
    """
    Add an activation box for the given reference (or entity), connecting
    it to fromId
    """
    if self.report.is_aborted():
      return # support abort

    # Find the participant
    ent = ref
    if isinstance(ent, understand.Ref):
      ent = ref.ent()

    toId = self.participantIdOf(ent)

    # determine label
    messageLabel = ""
    isEdgeLabels = self.report.options().lookup("Show Edge Labels")
    if isEdgeLabels:
      messageLabel = self.formattedName(ent)
      if self.report.options().lookup("Parameters"):
        messageLabel = messageLabel + "(" + ent.parameters(True) +")"

    # Add the activation
    self.printLine("{fromId}->>+{toId}: {label}".format(fromId=fromId, toId=toId, label=messageLabel))


    # Recurse, add edges from this activation node to what it calls
    self.level -= 1

    if self.level >= 0:
      self.expand(toId, ent)

    self.level += 1


    if fromId != "fm" and fromId != toId and self.report.options().lookup("Show Returns"):
      # Add return edge
      returnLabel = ""
      if isEdgeLabels and ent.type():
        returnLabel = ent.type() # Use type text as return value
      self.printLine("{toId}-->>-{fromId}: {label}".format(fromId=fromId, toId=toId, label=returnLabel))
    else:
      # Return edge not shown, just deactivate
      self.printLine("deactivate {toId}".format(toId=toId))

  def expand(self, fromId, ent):
    """
    Add children for the given entity, from the entity's node and column number
    """
    # References create activation boxes
    refs = diagramRefs(ent, self.report)
    refs.sort(key=lambda ref: (ref.line(), ref.column()))

    # control flow nodes create clusters
    cfnodes = []
    elseIfs = set() # Remember if nodes that got combined with previous else nodes
    if self.report.options().lookup("Cluster"):
      filteredCFNodes(ent, cfnodes, elseIfs, self.report.options().lookup("Collapse 'else if'"))

    # For control flow nodes labels
    file = None
    if cfnodes:
      file = entFile(ent)

    # Combine the control flow nodes and references by line/column, keeping
    # only non-empty clusters
    combined = []
    while cfnodes:
      # Determine whether reference or control flow node comes next
      if refs and before(refs[0].line(), refs[0].column(), cfnodes[0].line_begin(), cfnodes[0].column_begin()):
        if self.isIncluded(refs[0]):
          combined.append(refs[0])
        del refs[0] # reference handled
      else:
        if combined and isinstance(combined[-1], understand.CFNode):
          if combined[-1].end_node() == cfnodes[0]:
            del combined[-1] # Empty section, start followed by end
          elif (combined[-1].kind() not in CONTROL_FLOW_ENDS and             # previous node was not an end
                (not combined[-1].end_node() or combined[-1] in elseIfs) and # previous node was did not start a cluster
                (not cfnodes[0].end_node() or cfnodes[0] in elseIfs)):       # current node does not start a cluster
            # Previous node and current node are siblings within the same
            # cluster and the previous node was empty, so delete the empty section
            del combined[-1]

            # Check if now this node ends the parent cluster
            if combined and isinstance(combined[-1], understand.CFNode) and combined[-1].end_node() == cfnodes[0]:
              del combined[-1] # Empty section, start followed by end
            else:
              combined.append(cfnodes[0]) # new section in current cluster
          else:
            combined.append(cfnodes[0]) # begin section/cluster
        else:
          combined.append(cfnodes[0]) # begin/end of section/cluster

        del cfnodes[0] # control flow graph node handled

    # append remaining references
    for ref in refs:
      if self.isIncluded(ref):
        combined.append(ref)

    # Now add to graph
    for object in combined:
      if isinstance(object, understand.Ref):
        self.addActivation(fromId, object)
      else:
        self.addControlFlow(object, elseIfs, file)

  def addControlFlow(self, node, elseIfs, file):
    """
    Control flow nodes create alt and loop sections
    """
    if node.end_node() and not node in elseIfs:
      label = self.sourceText(node, file)
      if node.kind() in CONTROL_FLOW_ALT:
        self.printLine("alt {label}".format(label=label))
      else:
        self.printLine("loop {label}".format(label=label))
      self.indent += 1
      self.controlFlowNodeStack.append(node)
    elif self.controlFlowNodeStack and self.controlFlowNodeStack[-1].end_node() == node:
      self.indent -= 1
      self.printLine("end")
      del self.controlFlowNodeStack[-1]
    elif self.controlFlowNodeStack:
      # New section within current combined fragment
      label = self.sourceText(node, file)
      self.indent -= 1
      self.printLine("else {label}".format(label=label))
      self.indent += 1


  def sourceText(self, cfnode, file):
    """
    Find the source code at the control flow node's location
    """
    text = ""
    if file:
      lexer = None
      if file not in self.lexerCache:
        try:
          lexer = file.lexer()
        except:
          pass
        self.lexerCache[file] = lexer
      else:
        lexer = self.lexerCache[file]

      if lexer:
        eline = cfnode.line_end()
        ecol = cfnode.column_end()
        lexeme = lexer.lexeme(cfnode.line_begin(), cfnode.column_begin())
        while lexeme and before(lexeme.line_begin(), lexeme.column_begin(), eline, ecol):
          text += lexeme.text()
          lexeme = lexeme.next()

    return escapeLabel(text)


  def isIncluded(self, ref):
    """
    Screen call references to see if they should be added to the graph.
    Calling this function counts as visiting the reference
    """
    # Avoid visiting the exact same reference twice. This makes it so
    # repeat calls to the same function only show the first function expanded
    if repr(ref) in self.visited:
      return False
    self.visited.add(repr(ref))
    if self.report.options().lookup("Show Unresolved Entities") == "Hide" and ref.ent().kind().check("unresolved"):
      return False
    if not self.report.options().lookup("Show Self Calls") and ref.ent().parent() == ref.scope().parent():
      return False
    return True

  def formattedName(self, target):
    """
    Return an entity or architecture name based on the graph's name format
    """
    if self.report.options().lookup("Name Format") == "Short":
      return escapeLabel(target.name())
    return escapeLabel(target.longname())

  def printLine(self, line):
    self.report.print("    "*self.indent + line + "\n")

CONTROL_FLOW_ENDS=[ "end-do-while", "end-if", "end-loop", "end-switch"]
CONTROL_FLOW_ALT= [ "if", "elsif", "switch" ]
CONTROL_FLOW_KINDS=[
  "do-while",
  "end-do-while",
  "if",
  "elsif",
  "else",
  "end-if",
  "while-for",
  "while",
  "for",
  "end-loop",
  "switch",
  "switch-case",
  "switch-default",
  "end-switch"
]

def filteredCFNodes(ent, cfnodes, elseIfs, collapseElseIf):
  """
  Get the list of control flow nodes that may appear in the diagram
  """
  cgraph = ent.control_flow_graph()
  if not cgraph:
    return

  skipEnd = set()
  for node in cgraph.nodes():
    if node.kind() not in CONTROL_FLOW_KINDS or node in skipEnd:
      continue

    # Combine else node + if node
    if cfnodes and cfnodes[-1].kind() == "else" and node.kind() == "if" and collapseElseIf:
      del cfnodes[-1] # skip the else node
      skipEnd.add(node.end_node()) # Use end of original if, not this if's end
      elseIfs.add(node) # Flag this node as an else-if node

    # Add the node to the list
    cfnodes.append(node)



ENT_KIND_STR=(
  "ada entry, ada function, ada procedure,"
  "object ~unknown ~unresolved,"
  "member function ~unknown,"
  "member method ~unknown,"
  "c function ~unknown,"
  "pascal function method ~unknown ~unresolved,"
  "pascal procedure method ~unknown ~unresolved,"
  "python function ~unknown ~unresolved"
)

def diagramRefs(ent, report = None):
  """
  Return the references to be shown in the diagram for a given entity.
  """
  refs = ent.refs("call ~inactive", ENT_KIND_STR, False)
  if not report or report.options().lookup("Function Pointer"):
    refs.extend(ent.refs("use ptr ~inactive, c assign functionptr", ENT_KIND_STR, False))
  if not report or report.options().lookup("Functional Macros"):
    refs.extend(ent.refs("c use", "c functional macro", False))

  return refs

def entFile(ent):
  """
  Find the file for the given entity
  """
  defref = ent.refs("definein")
  if len(defref) == 1:
    return defref[0].file()

def before(line, col, beforeLine, beforeCol):
  """
  Range check
  """
  return line < beforeLine or (line == beforeLine and col <= beforeCol)

def escapeLabel(text):
  # escape problematic characters for mermaid
  t = ""
  for c in text:
    if c == "#":
      t += " #35;"
    elif c == ";":
      t += " #59;"
    elif c == "\n":
      t += "<br>"
    else:
      t+= c
  return t
