
def name():
  """
  Required, the name of the ireport.
  """
  return "Mermaid Graph\\Calls With Global Objects"

def description():
  """
  Optional, the description to display in the plugin manager.
  """
  return '''Create Mermaid input for a Calls with Global Objects Graph
  '''

def tags():
  """
  Optional, the tags to display in the plugin manager
  """
  return [
    'Target: Functions',
    'Language: Any',
    'Mermaid Graph',
  ]


ent_filter = ("function ~unknown ~unresolved,"
              "method ~unknown ~unresolved,"
              "procedure ~unknown ~unresolved,"
              "vhdl process, vhdl architecture,"
              "cobol paragraph, cobol section,"
              "Fortran Subroutine"
             )
ref_filter = "call, cobol perform, cobol goto"

def test_entity(entity):
  """
  Optional method, return true if report is valid for the entity
  """
  return entity.kind().check(ent_filter)

def init(report, entity):
  """
  Optional method, define options that can be changed by the user
  """
  report.options().choice("Calls Depth", "Calls Depth", [ "1", "2", "3", "4", "5", "All" ], "3")
  report.options().choice("Name", "Name", ["Shortname", "Fullname", "None (Overview Mode)"], "Shortname")
  report.options().choice("File Name", "File Name", ["Shortname", "Fullname", "Relative", "None"], "None")
  report.options().choice("References", "References", ["Simple", "All"], "All")

def generate(report, entity, pageId):
  """
  Required, generate the report

  The pageId parameter is optional. It will be an empty string the first
  time a report is generated. On subsequent generations, it can be any
  value returned from pages() or provided as a pageId to report.pagelink()
  or report.breadcrumbs() functions.
  """
  # Create the mermaid graph
  report.print("%% Copy the text or export the interactive report as text\n")
  report.print("%% Calls with Global Objects Graph for Mermaid generated by Understand\n")
  report.print("flowchart LR\n") # begin the graph

  depth = report.options().lookup("Calls Depth")
  if depth == "All":
    depth = -1
  else:
    depth = int(depth)

  curLevel = []
  curLevel.append(entity)
  visited = set()
  nodes = dict()

  # Loop over the levels of the tree
  while curLevel:
    nextLevel = []
    for ent in curLevel:
      # avoid visiting nodes multiple times
      if ent in visited:
        continue
      visited.add(ent)

      # Get a node id for the entity
      tail = grab_node(report,nodes,ent)

      # Call Edges
      if depth != 0:
        for ref in ent.refs(ref_filter,ent_filter,True):
          headEnt = ref.ent()
          nextLevel.append(headEnt)
          head = grab_node(report,nodes,headEnt)
          report.print("    {tail}-->{head}\n".format(tail=tail, head=head))

      # Global Object edges
      globals = set()
      global_edges(report, globals, nodes, ent, "~modify set, ~modify init")
      global_edges(report, globals, nodes, ent, "~modify ~set ~init")
      global_edges(report, globals, nodes, ent, "modify ~set ~init")

    if depth == 0:
      curLevel = []
    else:
      curLevel = nextLevel
    depth -= 1

def global_edges(report, visited, nodes, ent, refkindstr):
  tail = grab_node(report,nodes,ent)
  for ref in ent.refs(refkindstr,"global object, fortran variable ~local",True):
    headEnt = ref.ent()
    if report.options().lookup("References") == "Simple" and headEnt in visited:
      continue
    visited.add(headEnt)
    head = grab_node(report, nodes, headEnt)
    lbl = ""
    if report.options().lookup("References") == "All":
      lbl="|" + ref.kindname() + "|"

    report.print("    {tail}-->{label}{head}\n".format(tail=tail, label=lbl, head=head))

def grab_node(report, nodes, ent):
  if ent in nodes:
    return nodes[ent]

  label=""
  shape=""
  if ent.kind().check("global object, fortran variable ~local"):
    label = ent.name()
    shape="shape: \"stadium\"," # closest to oval that mermaid supports
  else:
    # Function Style
    if report.options().lookup("Name") == "Fullname":
      label = ent.longname()
    elif report.options().lookup("Name") == "Shortname":
      label = ent.name()

    filename = report.options().lookup("File Name")
    if filename != "None" and not ent.kind().check("file"):
      defref = ent.ref("definein,declarein")
      if defref:
        if filename == "Relative":
          label += "\n" + defref.file().relname()
        elif filename == "Fullname":
          label += "\n" + defref.file().longname()
        else:
          label += "\n" + defref.file().name()

  label =label.replace("\"", "#quot;")

  node = "node" + str(len(nodes))
  nodes[ent] = node

  report.print("    {id}@{{ {shape} label: \"{label}\"}}\n".format(id=node, label=label, shape=shape))

  return node

