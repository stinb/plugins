import understand

def name():
  """
  Required, the name of the ireport.
  """
  return "Mermaid Graph\\Butterfly"

def description():
  """
  Optional, the description to display in the plugin manager.
  """
  return '''Create Mermaid input for a Butterfly Graph
  '''

def tags():
  """
  Optional, the tags to display in the plugin manager
  """
  return [
    'Target: Functions',
    'Target: Classes',
    'Target: Files',
    'Language: Any',
    'Mermaid Graph',
  ]


def test_entity(entity):
  """
  Optional method, return true if report is valid for the entity
  """
  return entity.kind().check(",".join([
    CALLS_ENT_KIND,
    BASE_DERIVE_ENT_KIND,
    EXTENDS_ENT_KIND,
    TYPE_ENT_KIND,
    INCLUDE_ENT_KIND,
    USE_ENT_KIND ]))


def init(report, entity):
  """
  Optional method, define options that can be changed by the user
  """
  kinds = kindStrings(entity)

  # With build 1225+, the integer option supports a range.
  report.options().integer(kinds["forward"] + ' Depth', kinds["forward"] + ' Depth', 3, 0, 10)
  report.options().integer(kinds["inverse"] + ' Depth', kinds["inverse"] + ' Depth', 3, 0, 10)
  report.options().define('Name', ['Shortname', 'Fullname', 'None (Overview Mode)'], 'Shortname')
  report.options().define('Filename', ['None','Shortname', 'Fullname', 'Relative'], 'None')
  report.options().checkbox('Unresolved', 'Unresolved', True)
  if kinds["forward"] == 'Calls':
    report.options().checkbox('Virtual Calls', 'Virtual Calls', False)
  report.options().checkbox('Intrinsic', 'Intrinsic', True)


def generate(report, entity, pageId):
  """
  Required, generate the report

  The pageId parameter is optional. It will be an empty string the first
  time a report is generated. On subsequent generations, it can be any
  value returned from pages() or provided as a pageId to report.pagelink()
  or report.breadcrumbs() functions.
  """
  kinds = kindStrings(entity)

    # Create the mermaid graph
  report.print("%% Copy the text or export the interactive report as text\n")
  report.print("%% Butterfly Graph for Mermaid generated by Understand\n")
  report.print("flowchart LR\n") # begin the graph

  # create start node
  ids = {}
  start = nodeId(report, entity, ids)
  reverse_ids = ids.copy()

  # draw forward relations
  fdepth = int(report.options().lookup(kinds["forward"] + ' Depth'))
  draw_tree(report, entity, ids, fdepth, kinds["forwardRel"], 0)

  # draw inverse relations
  idepth = int(report.options().lookup(kinds["inverse"] + ' Depth'))
  draw_tree(report, entity, reverse_ids, idepth, kinds["inverseRel"], len(ids))


def nodeId(report, ent, ids, offset=0):
  # return existing node
  if ent in ids:
    return ids[ent]


  # build label
  label = ' '
  if report.options().lookup('Name') == 'Fullname':
    label = ent.longname()
  elif report.options().lookup('Name') == 'Shortname':
    label = ent.name()

  filenameopt = report.options().lookup('Filename')
  deffile = ent.ref('definein, declarein')

  if deffile and filenameopt != 'None' and not ent.kind().check('file'):
    if filenameopt == 'Shortname':
      label += '\n' + deffile.file().name()
    elif filenameopt == 'Fullname':
      label += '\n' + deffile.file().longname()
    elif filenameopt == 'Relative':
      label += '\n' + deffile.file().relname()
  label =label.replace("\"", "#quot;")

  # Create the node for Mermaid
  id = "node" + str(len(ids) + offset)
  ids[ent] = id
  shape = ""
  if ent.kind().check('unresolved, unknown, undefined'):
    shape="shape: \"hexagon\"," # closest to octagon that mermaid supports

  report.print("{id}@{{ {shape} label: \"{label}\"}}\n".format(id=id, label=label, shape=shape))

  return id


def virtualNodeId(report, ent, ids):
  # build id
  id = 'v' + str(ent.id())

  # return existing node
  if id in ids:
    return ids[id]

  ids[id] = id
  report.print("{id}@{{ shape: text, label: \"Virtual\"}}\n".format(id=id))

  return id


def newEdge(report, start, end, isForward):
  if isForward:
    report.print("{start} --> {end}\n".format(start=start, end=end))
  else:
    report.print("{start} --> {end}\n".format(start=end, end=start))

def isIncluded(report, ent):
  if not report.options().lookup('Unresolved') and ent.kind().check('unresolved, unknown, undefined'):
    return False
  if not report.options().lookup('Intrinsic Functions') and ent.kind().check('intrinsic'):
    return False
  return True

def draw_tree(report, entity, ids, depth, refkind, offset):
  visited = set()
  curLevel = [entity]
  isForward = offset == 0

  while curLevel and depth != 0:
    nextLevel = []
    for ent in curLevel:
      if ent in visited:
        continue # already expanded entity
      visited.add(ent)

      # Draw edges for this node
      id = nodeId(report, ent, ids, offset)
      for ref in sorted(ent.refs(refkind, unique=True), key=lambda x: x.line()):
        if isIncluded(report, ref.ent()):
          newEdge(report, id, nodeId(report, ref.ent(), ids, offset), isForward)
          nextLevel.append(ref.ent())

      if not report.options().lookup('Virtual Calls'):
        continue # Not showing virtual

      # Calculate Virtual Edges
      vrefs = []
      if isForward:
        for vref in ent.refs('java call, call virtual', 'function, method', True):
          vrefs.append(vref)
          vrefs.extend(vref.ent().refs('overriddenby, overrideby', unique=True))
      else:
        for oref in ent.refs('overrides, override', unique =True):
          vrefs.extend(oref.ent().refs('java callby, callby virtual', 'function, method', True))

      if not vrefs:
        continue # no virtual edges to show

      # Draw Virtual Edges
      vId = virtualNodeId(report, ent, ids)
      newEdge(report, id, vId, isForward)
      for vref in vrefs:
        newEdge(report, vId, nodeId(report, vref.ent(), ids, offset), isForward)
        nextLevel.append(vref.ent())
    # End loop over current level
    curLevel = nextLevel
    if depth > 0:
      depth -= 1


CALLS_ENT_KIND = (
  "ada entry, ada function, ada package, ada procedure, ada protected, ada task,"
  "assembly label,"
  "basic method,"
  "c function,"
  "csharp method,"
  "fortran block data, fortran function, fortran interface, fortran program, fortran subroutine,"
  "java method,"
  "jovial file, jovial subroutine,"
  "pascal compunit, pascal function, pascal procedure,"
  "python function,"
  "vhdl procedure, vhdl function, vhdl process, vhdl architecture,"
  "web function")
BASE_DERIVE_ENT_KIND=(
  "basic class, basic struct,"
  "csharp class, csharp struct,"
  "c class, c struct, c union")
EXTENDS_ENT_KIND=(
  "pascal class, pascal interface,"
  "java class ~anonymous, java interface")
TYPE_ENT_KIND= "ada type"
INCLUDE_ENT_KIND="c file, fortran file, pascal file"
USE_ENT_KIND= "vhdl entity, vhdl architecture, vhdl package, vhdl configuration"

def kindStrings(entity):
  if entity.kind().check(CALLS_ENT_KIND):
    forward = 'Calls'
    forwardRel = ("ada call ~dispatch, ada with,"
                  "assembly call,"
                  "basic call ~virtual, basic use ptr,"
                  "c call ~virtual, c use ptr,"
                  "csharp call ~virtual, csharp use ptr,"
                  "fortran call,"
                  "java call,"
                  "jovial call, jovial asm use,"
                  "pascal call ~virtual,"
                  "python call,"
                  "vhdl call,"
                  "web call")
    inverse = 'Called By'
    inverseRel = ("ada callby, ada withby,"
                  "assembly callby,"
                  "basic callby, basic useby ptr,"
                  "c callby ~inactive, c useby ptr,"
                  "csharp callby, csharp useby ptr,"
                  "fortran callby,"
                  "java callby,"
                  "jovial callby, jovial asm useby,"
                  "pascal callby,"
                  "python callby,"
                  "vhdl callby,"
                  "web callby")
  elif entity.kind().check(BASE_DERIVE_ENT_KIND):
    forward = 'Derived Classes'
    forwardRel = 'derive'
    inverse = 'Base Classes'
    inverseRel = 'base'
  elif entity.kind().check(EXTENDS_ENT_KIND):
    forward = 'Extended By'
    forwardRel = 'derive, extendby ~implicit'
    inverse = 'Extends'
    inverseRel = 'derivefrom, extend ~implicit'
  elif entity.kind().check(TYPE_ENT_KIND):
    forward = 'Type'
    forwardRel = 'derive'
    inverse = 'Type Derived From'
    inverseRel = 'derivefrom'
  elif entity.kind().check(INCLUDE_ENT_KIND):
    forward = 'Include'
    forwardRel = 'include ~inactive'
    inverse = 'Includeby'
    inverseRel = 'includeby ~inactive'
  elif entity.kind().check(USE_ENT_KIND):
    forward = 'Use'
    forwardRel = 'vhdl use name'
    inverse = 'Useby'
    inverseRel = 'vhdl useby name'

  return {
    "forward": forward,
    "inverse": inverse,
    "forwardRel": forwardRel,
    "inverseRel": inverseRel
  }
