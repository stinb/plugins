# Interactive Report for showing lexemes as a filterable table

def name():
  return "Tokenizer Table"

def description():
  return '''Display the lexer tokens generated for a file or entity in a table.
    <p>This report shows each token as generated by the lexer as a row in the
    table. The table columns are:</p>
    <ul>
      <li>Token</li>
      <li>Text</li>
      <li>Start Line</li>
      <li>Start Column </li>
      <li>End Line</li>
      <li>End Column </li>
      <li>The entity if any</li>
      <li>Reference kind if there is a reference</li>
      <li>Reference scope if there is a reference</li>
      <li>Reference entity if there is a reference</li>
      <li>Inactive</li>
    </ul>

    <p>See also the <a href="und://plugin/ireport/Tokenizer">Tokenizer</a>
    ireport which displays the same information with xml.</p>

    <br><img src=".doc/tokenizer_table.png"/>
  '''

def tags():
  return [
    'Target: Files',
    'Target: Functions',
    'Target: Classes',
    'API',
  ]

def test_entity(ent):
  return ent.kind().check("file ~unknown ~unresolved") or ent.ref("end")

def init(report, target):
  report.options().checkbox("expand","Expand Macro Text (Must save macro expansion text in C++ Options)",True)
  report.options().checkbox("whitespace","Show Whitespace",False)

# Report generation
def generate(report, ent):
  lexemes = []
  try:
    macros = report.options().lookup("expand")
    if ent.kind().check("file"):
      lexemes = ent.lexer(expand_macros=macros).lexemes()
    else:
      defref = ent.ref("begin")
      if not defref:
        defref = ent.ref("definein, body declarein")
      endref = ent.ref("end")
      if defref and endref and defref.file() == endref.file():
        lexemes = defref.file().lexer(expand_macros=macros).lexemes(defref.line(), endref.line())
  except understand.UnderstandError:
    pass

  report.table("""
    [{
      "name" : "Token",
      "filtertype": [
        "Comment",
        "Continuation",
        "EndOfStatement",
        "Identifier",
        "Keyword",
        "Label",
        "Literal",
        "Newline",
        "Operator",
        "Preprocessor",
        "Punctuation",
        "String",
        "Whitespace",
        "Indent",
        "Dedent"
      ]
     },{
      "name" : "Text",
      "filtertype": "string"
     },{
      "name" : "Start Line",
      "filtertype": "numeric",
       "sort": "ascending"
     },{
      "name" : "Start Column",
      "filtertype": "numeric"
     },{
      "name" : "End Line",
      "filtertype": "numeric"
     },{
      "name" : "End Column",
      "filtertype": "numeric"
     },{
      "name" : "Entity",
      "filtertype": "string"
     },{
      "name" : "Reference Kind",
      "filtertype": "string"
     },{
      "name" : "Reference Scope",
      "filtertype": "string"
     },{
      "name" : "Reference Entity",
      "filtertype": "string"
     },{
      "name" : "Inactive",
      "filtertype": ["Yes", "No"]
    }]""")

  ws = report.options().lookup("whitespace")
  for lex in lexemes:
    if not ws and lex.token() in ["Whitespace", "Newline"]:
      continue

    report.tablecell()
    report.print(lex.token())

    report.tablecell()
    # use repr to show whitespace characters as the control sequences, but
    # strip quotes added by repr
    text = repr(lex.text())
    text = text[1:-1]
    report.print(text)

    report.tablecell()
    report.print(str(lex.line_begin()))

    report.tablecell()
    report.print(str(lex.column_begin()))

    report.tablecell()
    report.print(str(lex.line_end()))

    report.tablecell()
    report.print(str(lex.column_end()))

    report.tablecell()
    printent(report, lex.ent())

    report.tablecell()
    r = lex.ref()
    if r:
      report.print(r.kind().longname())

    report.tablecell()
    if r:
      printent(report, r.scope())

    report.tablecell()
    if r:
      printent(report, r.ent())

    report.tablecell()
    report.print("Yes" if lex.inactive() else "No")

  report.table()

def printent(report, ent):
  if ent:
    report.entity(ent)
    report.print(ent.longname())
    report.entity()
