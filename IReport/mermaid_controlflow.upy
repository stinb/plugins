import understand

def name():
  """
  Required, the name of the ireport.
  """
  return "Mermaid Graph\\Control Flow"

def description():
  """
  Optional, the description to display in the plugin manager.
  """
  return '''Create Mermaid input for a Control Flow Graph
  '''

def tags():
  """
  Optional, the tags to display in the plugin manager
  """
  return [
    'Target: Functions',
    'Language: Any',
    'Mermaid Graph',
  ]


def test_entity(ent):
  """
  Optional method, return true if report is valid for the entity
  """
  return ent.control_flow_graph()


def init(report, target):
  """
  Optional method, define options that can be changed by the user
  """
  report.options().choice("Source Code", "Source Code", ["Off", "On", "Decision Only"], "On")
  report.options().checkbox("Comments", "Comments", False)
  if "C++" in report.db().language():
    report.options().checkbox("Expand Macros", "Expand Macros", False)

  report.options().checkbox_vert("Start/End Node", "Start/End Node", ["Name", "Entity", "Parameters"], ["Name"])

  report.options().checkbox("Edge Labels", "Edge Labels", True)
  report.options().choice("Passive Nodes", "Passive Nodes", ["Hide", "Show Individually", "Combine Adjacent Nodes"], "Combine Adjacent Nodes")
  report.options().checkbox("Filter", "Filter", True)

  report.options().checkbox("Cluster", "Cluster", False)
  report.options().checkbox("Show Finally-Block Flows", "Show Finally-Block Flows", True)

def generate(report, ent, pageId):
  """
  Required, generate the report

  The pageId parameter is optional. It will be an empty string the first
  time a report is generated. On subsequent generations, it can be any
  value returned from pages() or provided as a pageId to report.pagelink()
  or report.breadcrumbs() functions.
  """

  # Find the lexer
  lexer = None
  macros = "C++" in report.db().language() and report.options().lookup("Expand Macros")
  if ent.kind().check("file"):
    lexer = ent.lexer(expand_macros=macros)
  else:
    defRefs = ent.refs("definein,body declarein")
    if defRefs:
      lexer = defRefs[0].file().lexer(expand_macros=macros)
    elif ent.kind().check("vhdl process") and ent.refs("declarein"):
      lexer = ent.refs("declarein")[0].file().lexer(expand_macros=macros)

  # Find the nodes
  cfnodes = ent.control_flow_graph().nodes()

  collapsed = set()
  filtered = set()
  allChildren = understand.CFNode_Normal | understand.CFNode_Deferred

  # Calculate the collapsed nodes
  if report.options().lookup("Passive Nodes") == "Combine Adjacent Nodes":
    inverse = dict()
    for node in cfnodes:
      for child in node.children(allChildren):
        inverse.setdefault(child, []).append(node)
    for node in cfnodes:
      children = node.children(allChildren)
      if node.kind() == "passive" and len(children) == 1 and children[0].kind() == "passive" and len(inverse[children[0]]) == 1:
        collapsed.add(children[0])
        filtered.add(children[0])

  # Calculate the filtered nodes
  if report.options().lookup("Filter"):
    isAsm = ent.language() == "Assembly"
    for node in cfnodes:
      if node.kind() in FILTERED_KINDS or (not isAsm and node.kind() in NON_ASM_FILTERED_KINDS):
        filtered.add(node)

  # Create the mermaid graph
  report.print("%% Copy the text or export the interactive report as text\n")
  report.print("%% Control Flow Graph for Mermaid generated by Understand\n")
  report.print("flowchart TD\n") # begin the graph

  cluster = report.options().lookup("Cluster")
  clusterStack = []
  ids = dict()
  for id, node in enumerate(cfnodes):
    ids[node] = "node" + str(id)

    if cluster: # Handle clusters
      if node.end_node():
        report.print("    " * (len(clusterStack) + 1) + "subgraph g{id} [ ]\n".format(id=id))
        clusterStack.append(node.end_node())
      elif clusterStack and clusterStack[-1] == node:
        del clusterStack[-1]
        report.print("    " * (len(clusterStack) + 1) + "end\n")

    if node in filtered:
      continue

    # Determine the label for this node
    lbl = nodeLabel(report, ent, lexer, node)
    children = node.children(allChildren)
    while len(children) == 1 and children[0] in collapsed:
      clbl = nodeLabel(report, ent, lexer, children[0])
      if clbl and lbl:
        lbl += "\n"
      lbl += clbl
      children = children[0].children(allChildren)
    if not lbl:
      lbl = " " # make sure the label is at least a space big or Mermaid can't parse it


    shape = "rectangle"
    if node.kind() in SWITCH_KINDS:
      shape = "hexagon" # closest to octagon
    elif node.kind() in LOOP_KINDS:
      shape = "stadium" # closest to oval
    elif node.kind() in CONDITIONAL_KINDS:
      shape = "decision"
    elif node.kind() in CATCH_KINDS:
      shape = "stadium" # closest to oval
    elif node.kind() == "try":
      shape = "hexagon"

    # Create the node for Mermaid (inside it's subgraph)
    report.print("    " * (len(clusterStack) + 1) + "node{id}@{{ shape: \"{shape}\", label: \"{label}\"}}\n".format(id=id, label=lbl, shape=shape))

  # Draw the edges last
  edgeLabels = report.options().lookup("Edge Labels")
  deferred = report.options().lookup("Show Finally-Block Flows")
  for node in cfnodes:
    if node in filtered:
      continue

    for child in node.children(understand.CFNode_Normal):
      lbl = ""
      if edgeLabels:
        lbl = node.child_label(child)
      if lbl:
        lbl = "|"+lbl+"|"

      for visibleChild in visible(child, filtered):
        report.print("    {tail}-->{label}{head}\n".format(tail=ids[node], label=lbl, head=ids[visibleChild]))

    if deferred:
      for child in node.children(understand.CFNode_Deferred):
        for visibleChild in visible(child, filtered):
          # Use dotted style, since Mermaid doesn't seem to support dashed
          report.print("    {tail}-.->{head}\n".format(tail=ids[node], head=ids[visibleChild]))




FILTERED_KINDS= [
  "do-while", "end-case", "loop", "end-switch", "end-block", "end-try",
  "end-select", "else-where", "end-where", "end-do","repeat-until",
  "end-with-do", "do", "passive-implicit"
]

NON_ASM_FILTERED_KINDS = [ "else", "end-if", "end-loop" ]

SWITCH_KINDS = [ "case","switch","arith-if","select-case","computed-goto" ]
LOOP_KINDS = [
  "end-do-while","while-for","while","for","do","do-infinite","do-while","loop-expr",
  "end-repeat-until","do-until","do-while","end-do-loop-until","end-do-loop-while"
]
CONDITIONAL_KINDS = [ "if","elsif","exit-when","where","else-where-cond" ]
CATCH_KINDS = [ "try-catch","try-finally" ]

def nodeLabel(report, ent, lexer, node):
  lbl = ""
  if node.kind() == "start":
    fields = report.options().lookup("Start/End Node")
    if "Name" in fields:
      lbl += "start"

    if "Entity" in fields:
      if lbl:
        lbl += "\n"

      lbl += ent.longname()
    if "Parameters" in fields:
      if lbl and not "Entity" in fields:
        lbl += "\n"
      lbl += "(" + ent.parameters(True) + ")"
  elif node.kind() == "end":
    if "Name" in report.options().lookup("Start/End Node"):
      lbl = "end"
  elif lexer and node.line_begin() and node.column_begin() and node.line_end() and node.column_end(): # Node with location
    lines = []
    # Preceding Comments
    comments = report.options().lookup("Comments")
    if comments:
      line = node.line_begin() - 1
      while line >= 0:
        lexeme = lexer.lexeme(line, 0)
        while lexeme and lexeme.token() == "Whitespace":
          lexeme = lexeme.next()

        if lexeme and lexeme.token() == "Comment":
          lines.insert(0,lexeme.text())
          line = min(lexeme.line_begin() - 1, line - 1)
        else:
          line = -1

    # Source code
    src = report.options().lookup("Source Code")
    showSrc = src == "On" or (src == "Decision Only" and not node.kind() == "passive")
    lexeme = lexer.lexeme(node.line_begin(), node.column_begin())
    line = ""
    while lexeme and lexeme.line_begin() <= node.line_end():
      if lexeme.token() == "Newline":
        if line:
          lines.append(line)
          line = ""
      elif lexeme.token() == "Comment":
        if comments:
          line += lexeme.text()
      elif showSrc and (not lexeme.line_begin() == node.line_end() or lexeme.column_begin() <= node.column_end()):
        line += lexeme.text()
      lexeme = lexeme.next()
    if line:
      lines.append(line)
    lbl = '\n'.join(lines)
    lbl =lbl.replace("\"", "#quot;")
  else:
    lbl = node.kind()
  return lbl

def visible(node, filtered):
  childqueue = [node]
  children = []
  while childqueue:
    child = childqueue.pop(0)
    if child in filtered:
      childqueue.extend(child.children(understand.CFNode_Normal | understand.CFNode_Deferred))
    else:
      children.append(child)
  return children



