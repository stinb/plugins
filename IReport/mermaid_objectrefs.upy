import understand

def name():
  """
  Required, the name of the ireport.
  """
  return "Mermaid Graph\\Object References"

def description():
  """
  Optional, the description to display in the plugin manager.
  """
  return '''Create Mermaid input for an Object References Graph
  '''

def tags():
  """
  Optional, the tags to display in the plugin manager
  """
  return [
    'Target: Objects',
    'Language: Any',
    'Mermaid Graph',
  ]

callbykind = ("ada callby,"
              "c callby ~inactive, c useby ptr, c assignby functionptr,"
              "cobol callby,"
              "csharp callby, csharp useby ptr,"
              "fortran callby,"
              "java callby,"
              "jovial callby, jovial asm useby,"
              "pascal callby,"
              "vhdl callby,"
              "php callby")
objectrefkind = "setby, useby, modifyby, definein"

def test_entity(entity):
  """
  Optional method, return true if report is valid for the entity
  """
  return entity.kind().check("Object, Macro, Variable, Field, Property")

def init(report, entity):
  """
  Optional method, define options that can be changed by the user
  """
  report.options().integer("Called By Depth", "Called By Depth", 3, 0, 10)
  report.options().checkbox("Type", "Type", False)
  report.options().choice("Name", "Name", ["Shortname", "Fullname", "None (Overview Mode)"], "Shortname")
  report.options().choice("Filename", "Filename", ["Shortname", "Fullname", "Relative", "None"], "None")
  report.options().checkbox("Unresolved", "Unresolved", True)
  report.options().choice("References", "References", ["Simple", "All"], "All")

  report.options().checkbox_vert("Reference Kinds", "Reference Kinds",
                                ["Define/Declare", "Set", "Use", "Modify"],
                                ["Set", "Use", "Modify"])


def generate(report, entity, pageId):
  """
  Required, generate the report

  The pageId parameter is optional. It will be an empty string the first
  time a report is generated. On subsequent generations, it can be any
  value returned from pages() or provided as a pageId to report.pagelink()
  or report.breadcrumbs() functions.
  """
  # Create the mermaid graph
  report.print("%% Copy the text or export the interactive report as text\n")
  report.print("%% Object References Graph for Mermaid generated by Understand\n")
  report.print("flowchart LR\n") # begin the graph

  depth = int(report.options().lookup("Called By Depth"))

  curLevel = []
  curLevel.append(entity)
  visited = set()
  nodes = dict()

  # Make sure initial node shows when depth = 0
  grab_node(report,nodes,entity)

  for i in range(depth):
    nextLevel = []
    for ent in curLevel:
      # Avoid visiting nodes multiple times
      if ent in visited:
        continue
      visited.add(ent)

      # Get a node id for the entity
      head = grab_node(report,nodes,ent)

      if i == 0:
        refs = []
        refkinds = report.options().lookup("Reference Kinds")
        if "Define/Declare" in refkinds:
          refs += entity.refs("Definein,Declarein", unique=False)
        if "Set" in refkinds:
          refs += entity.refs("SetBy Init",unique=False)
          refs += entity.refs("SetBy ~Init",unique=False)
        if "Modify" in refkinds:
          refs += entity.refs("Modifyby",unique=False)
        if "Use" in refkinds:
          refs += entity.refs("UseBy Return", unique=False)
          refs += entity.refs("UseBy ~Return", unique=False)
      else:
        refs = ent.refs(callbykind, unique=True)

      for ref in refs:
        tailEnt = ref.ent()
        if (not report.options().lookup("Unresolved") and
            tailEnt.kind().check("unresolved, unknown, undefined")):
          continue
        nextLevel.append(tailEnt)
        tail = grab_node(report,nodes,tailEnt)

        # Create the edge
        lbl = ""
        if (report.options().lookup("References") == "All" and
            not ref.kind().check("Callby")):
          lbl="|" + ref.kindname() + "|"
        report.print("    {tail}-->{label}{head}\n".format(tail=tail, label=lbl, head=head))
    # End of loop over current level
    curLevel = nextLevel

def grab_node(report, nodes, ent):
  if ent in nodes:
    return nodes[ent]

  label = ""

  # Type Option
  if (report.options().lookup("Type") and
      ent.kind().check("Object, Variable, Field, Property")):
    type = ent.type()
    if not type:
      type = "unknown"
    label += type + "\n"

  # Name Option
  if report.options().lookup("Name") == "Fullname":
    label += ent.longname()
  elif report.options().lookup("Name") == "Shortname":
    label += ent.name()

  # Filename option
  filename = report.options().lookup("Filename")
  if filename != "None" and not ent.kind().check("file"):
    defref = ent.ref("definein,declarein")
    if defref:
      if filename == "Relative":
        label += "\n" + defref.file().relname()
      elif filename == "Fullname":
        label += "\n" + defref.file().longname()
      else:
        label += "\n" + defref.file().name()

  label =label.replace("\"", "#quot;")

  shape = ""
  if ent.kind().check('unresolved, unknown, undefined'):
    shape="shape: \"hexagon\"," # closest to octagon that mermaid supports
  elif ent.kind().check("Object, Variable, Field, Property"):
    shape="shape: \"stadium\"," # closest to oval that mermaid supports

  # Create the node for Mermaid
  node = "node" + str(len(nodes))
  nodes[ent] = node

  report.print("    {id}@{{ {shape} label: \"{label}\"}}\n".format(id=node, label=label, shape=shape))

  return node
