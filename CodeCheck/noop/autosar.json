{
  "A1-4-3": {
    "checked": true,
    "language": "C++",
    "tags": [ "Language: C++", "Language: C", "Standard: AUTOSAR", "Category: Advisory", "Automation: Automated", "Warnings" ],
    "name": "Published Standards/AUTOSAR/All code should compile free of compiler warnings",
    "desc": {
      "html": [
        "<p><b>",
        "This check is automatically run",
        "</b></p>",
        "",
        "<p>",
        "All code should compile free of compiler warnings",
        "</p>"
      ]
    }
  },
  "A2-13-2": {
    "checked": true,
    "language": "C++",
    "tags": [ "Language: C++", "Language: C", "Expressions" ],
    "name": "Published Standards/AUTOSAR/Concatenating String Literals of Different Encodings",
    "desc": {
      "html": [
        "<p><b>This check is automatically run</b></p>",
        "",
        "<p><b>Title</b></p>",
        "<p>String literals with different encoding prefixes shall not be concatenated.</p>",
        "",
        "<p><b>Rationale</b></p>",
        "<p>Concatenation of wide and narrow string literals leads to undefined behavior.</p>",
        "<p>\"In translation phase 6 (2.2), adjacent string-literals are concatenated. If both string-literals have the same encoding-prefix, the resulting concatenated string literal has that encoding-prefix. If one string-literal has no encoding-prefix, it is treated as a string-literal of the same encoding-prefix as the other operand. If a UTF-8 string literal token is adjacent to a wide string literal token, the program is ill-formed. Any other concatenations are conditionally-supported with implementation-defined behavior. [ Note: This concatenation is an interpretation, not a conversion. Because the interpretation happens in translation phase 6 (after each character from a literal has been translated into a value from the appropriate character set), a string-literal's initial rawness has no effect on the interpretation or well-formedness of the concatenation. -end note ]\" [C++14 Language Standard] [3]</p>",
        "",
        "<p><b>Example</b></p>",
        "<pre><code language=\"C++\">char16_t nArray[] =",
        "    u\"Hello\"",
        "    u\"World\";  // Compliant, \"u\" stands for char16_t type",
        "",
        "char32_t nArray2[] =",
        "    U\"Hello\"",
        "    U\"World\";  // Compliant, \"U\" stands for char32_t type",
        "",
        "wchar_t wArray[] =",
        "    L\"Hello\"",
        "    L\"World\";  // Compliant, \"L\" stands for wchar_t type - violates A2-13-3",
        "               // rule.",
        "",
        "wchar_t mixed1[] =",
        "    \"Hello\"",
        "    L\"World\";  // Compliant",
        "",
        "char32_t mixed2[] =",
        "    \"Hello\"",
        "    U\"World\";  // Compliant",
        "",
        "char16_t mixed3[] =",
        "    \"Hello\"",
        "    u\"World\";  // Compliant",
        "",
        "// wchar_t mixed1[] = u\"Hello\" L\"World\";  // Non-compliant - compilation error",
        "",
        "// char32_t mixed2[] = u\"Hello\" U\"World\";  // Non-compliant - compilation error</code></pre>",
        "",
        "<p><b>See also</b></p>",
        "<ul>",
        "<li>MISRA C++ 2008 [7]: required 2-13-5 Narrow and wide string literals shall not be concatenated.</li>",
        "<li>HIC++ v4.0 [9]: 2.5.1 Do not concatenate strings with different encoding prefixes</li>",
        "</ul>"
      ]
    }
  },
  "A16-2-3": {
    "checked": true,
    "language": "C++",
    "tags": [ "Language: C++", "Automation: Non-automated", "Category: Required", "Preprocessor", "Standard: AUTOSAR"],
    "name": "Published Standards/AUTOSAR/An include directive shall be added explicitly for every symbol used in a file",
    "desc": {
      "html": [
        "<p><b>",
        "This check cannot be automated",
        "</b></p>",
        "",
        "<p>",
        "An include directive shall be added explicitly for every symbol used in a file.",
        "</p>"
      ]
    }
  },
  "M0-3-1": {
    "checked": true,
    "language": "C++",
    "tags": [ "Language: C++", "Automation: Non-automated", "Category: Required", "Tools", "Standard: AUTOSAR"],
    "name": "Published Standards/AUTOSAR/Minimization of run-time failures shall be ensured by the use of static analysis tools",
    "desc": {
      "html": [
        "<p><b>Rule</b><br>",
        "Minimization of run-time failures shall be ensured by the use of at least one of:<br>",
        "&nbsp;&nbsp;(a) static analysis tools/techniques;<br> ",
        "&nbsp;&nbsp;(b) dynamic analysis tools/techniques;<br>",
        "&nbsp;&nbsp;(c) explicit coding of checks to handle run-time faults.</p>",
        "",
        "<p><b>Rationale</b><br>",
        "Run-time checking is an issue (not specific to C++) to which developers need to pay special ",
        "attention, especially as the C++ language is weak in its provision of any run-time checking. C++ ",
        "implementations are not required to perform many of the dynamic checks that are necessary for ",
        "robust software. It is therefore an issue that C++ developers need to consider carefully, adding ",
        "dynamic checks to code wherever there is the potential for run-time errors to occur.</p>",
        "",
        "<p>Where expressions consist only of values within a well-defined range, a run-time check may ",
        "not be necessary, provided it can be demonstrated that for all values within the defined range ",
        "the exception cannot occur. Such a demonstration, if used, should be documented along with ",
        "the assumptions on which it depends. However, if adopting this approach, be very careful about ",
        "subsequent modifications of the code that may invalidate the assumptions, or of the assumptions ",
        "changing for any other reason.</p>",
        "",
        "<p>The following notes give some guidance on areas where consideration needs to be given to the ",
        "provision of dynamic checks.</p>",
        "",
        "<p><b>Arithmetic Errors</b><br>",
        "This includes errors occurring in the evaluation of expressions, such as overflow, underflow, ",
        "division by zero or loss of significant bits through shifting.",
        "In considering integer overflow, note that unsigned integer calculations do not strictly ",
        "overflow (producing undefined values), but the values wrap around (producing defined, but ",
        "possibly unexpected, values).</p>",
        "",
        "<p><b>Pointer Arithmetic</b><br>",
        "Ensure that when an address is calculated dynamically the computed address is reasonable ",
        "and points somewhere meaningful. In particular it should be ensured that if a pointer points ",
        "within a structure or array, then when the pointer has been incremented or otherwise altered ",
        "it still points to the same structure or array. See Rule 5-0-15, Rule 5-0-16, Rule 5-0-17 ",
        "and Rule 5-0-18 for restrictions on pointer arithmetic.</p>",
        "",
        "<p><b>Array Bound Errors</b><br>",
        "Ensure that array indices are within the bounds of the array size before using them to index ",
        "the array.</p>",
        "",
        "<p><b>Function Arguments</b><br>",
        "Function arguments should be validated.</p>",
        "",
        "<p><b>Pointer Dereferencing</b><br>",
        "Where a function returns a pointer and that pointer is subsequently de-referenced the ",
        "program should first check that the pointer is not NULL. Within a function, it is relatively ",
        "straightforward to reason about which pointers may or may not hold NULL values. Across ",
        "function boundaries, especially when calling functions defined in other source files or ",
        "libraries, it is much more difficult.</p>",
        "",
        "<pre style=\"margin-top:0;padding-top:0;\">",
        "// Given a pointer to a message, check the message header and return",
        "// a pointer to the body of the message or NULL if the message is",
        "// invalid.",
        "const char_t *msg_body ( const char_t * msg )",
        "{",
        "const char_t * body = NULL;",
        "  if ( msg != NULL )",
        "  {",
        "    if ( msg_header_valid ( msg ) )",
        "    {",
        "      body = &msg [ MSG_HEADER_SIZE ];",
        "    }",
        "  }",
        "  return ( body );",
        "}",
        "...",
        "char_t msg_buffer [ MAX_MSG_SIZE ];",
        "const char_t * payload;",
        "...",
        "payload = msg_body ( msg_buffer );",
        "if ( payload != NULL )",
        "{",
        "  // process the message payload",
        "}",
        "</pre>",
        "",
        "<p>The techniques that will be employed to minimize run-time failures should be planned and ",
        "documented, e.g. in design standards, test plans, static analysis configuration files, code review ",
        "checklists.</p>"
      ]
    }
  },
  "M15-3-7": {
    "checked": true,
    "language": "C++",
    "tags": [ "Language: C++", "Automation: Automated", "Category: Required", "Exception Handling", "Standard: AUTOSAR"],
    "name": "Published Standards/AUTOSAR/Where multiple handlers are provided in a single try-catch statement or function-try-block, any ellipsis (catch-all) handler shall occur last",
    "desc": {
      "html": [
        "<p><b>This check is automatically run</b></p>",
        "<p>This check is always run during the strict analysis, any violations will be reported as analysis errors.</p>",
        "<p><b>Rationale</b></p>",
        "<p>If the catch-all handler is found before any other handler, that behaviour",
        "will be performed. Any handlers after the catch-all are unreachable code and",
        "can never be executed.</p>",
        "<p><b>Example</b></p>",
        "<pre>",
        "void f1 ( )",
        "{",
        "  try",
        "  {",
        "    // ...",
        "  }",
        "  catch ( int32_t i ) // int handler",
        "  {",
        "    // Handle int exceptions",
        "  }",
        "  catch( ... ) // catch-all handler",
        "  {",
        "    // Handle all other exception types",
        "  }",
        "}",
        "void f2 ( )",
        "{",
        "  try",
        "  {",
        "    // ...",
        "  }",
        "  catch( ... ) // catch-all handler",
        "  {",
        "    // Handle all exception types",
        "  }",
        "  catch ( int32_t i ) // Non-compliant – handler will never be called",
        "  {",
        "  }",
        "}</pre>"
      ]
    }
  },
  "M5-2-2": {
    "checked": true,
    "language": "C++",
    "tags": [ "Language: C++", "Automation: Automated", "Category: Required", "Virtual Functions", "Standard: AUTOSAR"],
    "name": "Published Standards/AUTOSAR/A pointer to a virtual base class shall only be cast to a pointer to a derived class by means of dynamic_cast",
    "desc": {
      "html": [
        "<p><b>This check is automatically run</b></p>",
        "<p>This check is always run during the strict analysis, any violations will be reported as analysis errors.</p>",
        "<p><b>Rationale</b></p>",
        "<p>Casting from a virtual base to a derived class, using any means other than",
        "dynamic_cast has undefined behaviour. The behaviour for dynamic_cast is",
        "defined.</p>",
        "<p><b>Example</b></p>",
        "<pre>",
        "class B { ... };",
        "class D: public virtual B { ... };",
        "D d;",
        "B *pB = &d;",
        "D *pD = static_cast&lt;D*&gt;(pB); // Non-compliant - undefined behaviour",
        "D *pD2 = dynamic_cast&lt;D*&gt;(pB); // Compliant, but pD2 may be NULL",
        "D & D3 = dynamic_cast&lt;D&&gt;(*pB); // Compliant, but may throw an exception</pre>"
      ]
    }
  },
  "A0-4-1": {
    "checked": false,
    "language": "C++",
    "tags": [ "Language: C++", "Language: C", "Standard: AUTOSAR", "Category: Required", "Automation: Non-automated", "Types" ],
    "name": "Published Standards/AUTOSAR/Floating-point implementation shall comply with IEEE 754 standard",
    "desc": {
      "html": [
        "<p><b>",
        "This check cannot be automated",
        "</b></p>",
        "",
        "<p>",
        "Floating-point implementation shall comply with IEEE 754 standard",
        "</p>"
      ]
    }
  },
  "A0-4-3": {
    "checked": false,
    "language": "C++",
    "tags": [ "Language: C++", "Automation: Automated", "Category: Required", "Standard: AUTOSAR"],
    "name": "Published Standards/AUTOSAR/The implementations in the chosen compiler shall strictly comply with the C++14 Language Standard",
    "desc": {
      "html": [
        "<p><b>",
        "This check cannot be automated",
        "</b></p>",
        "",
        "<p>",
        "The implementations in the chosen compiler shall strictly comply with the C++14",
        "Language Standard.",
        "</p>"
      ]
    }
  },
  "A0-4-4": {
    "checked": false,
    "language": "C++",
    "tags": [ "Language: C++", "Automation: Non-automated", "Category: Required", "Exception Handling", "Standard: AUTOSAR"],
    "name": "Published Standards/AUTOSAR/Range, domain and pole errors shall be checked when using math functions",
    "desc": {
      "html": [
        "<p><b>",
        "This check cannot be automated",
        "</b></p>",
        "",
        "<p>",
        "Range, domain and pole errors shall be checked when using math functions",
        "</p>"
      ]
    }
  },
  "A1-1-1": {
    "checked": false,
    "language": "C++",
    "tags": [ "Language: C++", "Automation: Automated", "Category: Required", "Standard: AUTOSAR"],
    "name": "Published Standards/AUTOSAR/All code shall conform to ISO&#47;IEC 14882:2014 - Programming Language C++ and shall not use deprecated features",
    "desc": {
      "html": [
        "<p><b>",
        "This check cannot be automated",
        "</b></p>",
        "",
        "<p>",
        "All code shall conform to ISO/IEC 14882:2014 - Programming Language C++ and",
        "shall not use deprecated features",
        "</p>"
      ]
    }
  },
  "A1-1-2": {
    "checked": false,
    "language": "C++",
    "tags": [ "Language: C++", "Language: C", "Standard: AUTOSAR", "Category: Required", "Automation: Non-automated", "Warnings" ],
    "name": "Published Standards/AUTOSAR/A warning level of the compilation process shall be set in compliance with project policies",
    "desc": {
      "html": [
        "<p><b>",
        "This check cannot be automated",
        "</b></p>",
        "",
        "<p>",
        "A warning level of the compilation process shall be set in compliance with project policies",
        "</p>"
      ]
    }
  },
  "A1-1-3": {
    "checked": false,
    "language": "C++",
    "tags": [ "Language: C++", "Automation: Non-automated", "Category: Required", "Tools", "Standard: AUTOSAR"],
    "name": "Published Standards/AUTOSAR/An optimization option that disregards strict standard compliance shall not be turned on in the chosen compiler",
    "desc": {
      "html": [
        "<p><b>",
        "This check cannot be automated",
        "</b></p>",
        "",
        "<p>",
        "An optimization option that disregards strict standard compliance shall not be turned on in the chosen compiler",
        "</p>"
      ]
    }
  },
  "A1-2-1": {
    "checked": false,
    "language": "C++",
    "tags": [ "Language: C++", "Automation: Non-automated", "Category: Required", "Tools", "Standard: AUTOSAR"],
    "name": "Published Standards/AUTOSAR/When using a compiler toolchain, in safety-related software, the tool confidence level (TCL) shall be determined",
    "desc": {
      "html": [
        "",
        "<p><b>Rationale</b></p>",
        "Rule A1-2-1 (required, toolchain, non-automated)",
        "When using a compiler toolchain (including preprocessor, compiler itself, linker, C++ ",
        "standard libraries) in safety-related software, the tool confidence level (TCL) shall ",
        "be determined. In case of TCL2 or TCL3, the compiler shall undergo a “Qualification ",
        "of a software tool”, as per ISO 26262-8.11.4.6 [6].",
        "",
        "Vulnerabilities and errors in the compiler toolchain impact the binary that is built.",
        "</p>",
        "",
        "<p><b>Example</b></p>",
        "<pre>",
        "The following mechanisms could help to increase the Tool error Detection (TD) and thus allowing to reduce the Tool Confidence Level:",
        "1. Achievement of MC/DC code coverage on generated project assembly code",
        "2. Diverseimplementationofsafetyrequirementsatsoftwareorevenatsystemlevel (e.g. two micro-controllers)",
        "3. Usage of diverse compilers or compilation options",
        "4. Diversity at the level of operating system",
        "5. Extensive testing (e.g. equivalence class testing, boundary value testing), testing at several levels (e.g. unit testing, integration testing)",
        "",
        "Note that in most automotive applications, the compiler is evaluated TCL3 or TCL2. In case of TCL2 or TCL3, the following are typically ",
        "performed (by compiler vendor or by a project), see table 4 in ISO 26262-8:",
        "1. Evaluation of the tool development process",
        "2. Validation of the software tool, by performing automatic compiler tests that are derived from the C++ language specification",
        "</pre>",
        "",
        "<p>See also: <i>ISO 26262-8 [6]: 11 Confidence in the use of software tools.</i></p>"
      ]
    }
  },
  "A1-4-1": {
    "checked": false,
    "language": "C++",
    "tags": [ "Language: C++", "Automation: Non-automated", "Category: Required", "Standard: AUTOSAR"],
    "name": "Published Standards/AUTOSAR/Code metrics and their valid boundaries shall be defined and code shall comply with defined boundaries of code metrics",
    "desc": {
      "html": [
        "<p><b>",
        "This check cannot be automated",
        "</b></p>",
        "",
        "<p>",
        "Code metrics and their valid boundaries shall be defined and code shall comply with defined boundaries of code metrics",
        "</p>"
      ]
    }
  },
  "A10-0-2": {
    "checked": false,
    "language": "C++",
    "tags": [ "Language: C++", "Language: C", "Standard: AUTOSAR", "Category: Required", "Automation: Non-automated", "Declarations and Definitions" ],
    "name": "Published Standards/AUTOSAR/Membership or non-public inheritance shall be used to implement \"has-a\" relationship",
    "desc": {
      "html": [
        "<p><b>",
        "This check cannot be automated",
        "</b></p>",
        "",
        "<p>",
        "Membership or non-public inheritance shall be used to implement \"has-a\" relationship",
        "</p>"
      ]
    }
  },
  "A12-1-6": {
    "checked": false,
    "language": "C++",
    "tags": [ "Language: C++", "Language: C", "Standard: AUTOSAR", "Category: Required", "Automation: Automated", "Declarations and Definitions" ],
    "name": "Published Standards/AUTOSAR/Derived classes that do not need further explicit initialization and require all the constructors from the base class shall use inheriting constructors",
    "desc": {
      "html": [
        "<p><b>",
        "This check cannot be automated",
        "</b></p>",
        "",
        "<p>",
        "Derived classes that do not need further explicit initialization and require all",
        "the constructors from the base class shall use inheriting constructors",
        "</p>"
      ]
    }
  },
  "A15-0-1": {
    "checked": false,
    "language": "C++",
    "tags": [ "Language: C++", "Language: C", "Standard: AUTOSAR", "Category: Required", "Automation: Non-automated", "Exception Handling" ],
    "name": "Published Standards/AUTOSAR/A function shall not exit with an exception if it is able to complete its task",
    "desc": {
      "html": [
        "<p><b>",
        "This check cannot be automated",
        "</b></p>",
        "",
        "<p>",
        "A function shall not exit with an exception if it is able to complete its task",
        "</p>"
      ]
    }
  },
  "A15-0-2": {
    "checked": false,
    "language": "C++",
    "tags": [ "Language: C++", "Language: C", "Standard: AUTOSAR", "Category: Required", "Automation: Partially Automated", "Exception Handling" ],
    "name": "Published Standards/AUTOSAR/At least the basic guarantee for exception safety shall be provided for all operations. In addition, each function may offer either the strong guarantee or the nothrow guarantee",
    "desc": {
      "html": [
        "<p><b>",
        "This check cannot be automated",
        "</b></p>",
        "",
        "<p>",
        "At least the basic guarantee for exception safety shall be provided for all operations. In addition, each function may offer either the strong guarantee or the nothrow guarantee",
        "</p>"
      ]
    }
  },
  "A15-0-3": {
    "checked": false,
    "language": "C++",
    "tags": [ "Language: C++", "Language: C", "Standard: AUTOSAR", "Category: Required", "Automation: Non-automated", "Exception Handling" ],
    "name": "Published Standards/AUTOSAR/Exception safety guarantee of a called function shall be considered",
    "desc": {
      "html": [
        "<p><b>",
        "This check cannot be automated",
        "</b></p>",
        "",
        "<p>",
        "Exception safety guarantee of a called function shall be considered",
        "</p>"
      ]
    }
  },
  "A15-0-4": {
    "checked": false,
    "language": "C++",
    "tags": [ "Language: C++", "Language: C", "Standard: AUTOSAR", "Category: Required", "Automation: Non-automated", "Exception Handling" ],
    "name": "Published Standards/AUTOSAR/Unchecked exceptions shall be used to represent errors from which the caller cannot reasonably be expected to recover.",
    "desc": {
      "html": [
        "<p><b>",
        "This check cannot be automated",
        "</b></p>",
        "",
        "<p>",
        "Unchecked exceptions shall be used to represent errors from which the caller cannot reasonably be expected to recover.",
        "</p>"
      ]
    }
  },
  "A15-0-5": {
    "checked": false,
    "language": "C++",
    "tags": [ "Language: C++", "Language: C", "Standard: AUTOSAR", "Category: Required", "Automation: Non-automated", "Exception Handling" ],
    "name": "Published Standards/AUTOSAR/Checked exceptions shall be used to represent errors from which the caller can reasonably be expected to recover",
    "desc": {
      "html": [
        "<p><b>",
        "This check cannot be automated",
        "</b></p>",
        "",
        "<p>",
        "Checked exceptions shall be used to represent errors from which the caller can reasonably be expected to recover",
        "</p>"
      ]
    }
  },
  "A15-0-6": {
    "checked": false,
    "language": "C++",
    "tags": [ "Language: C++", "Language: C", "Standard: AUTOSAR", "Category: Required", "Automation: Non-automated", "Exception Handling" ],
    "name": "Published Standards/AUTOSAR/An analysis shall be performed to analyze the failure modes of exception handling",
    "desc": {
      "html": [
        "<p><b>",
        "This check cannot be automated",
        "</b></p>",
        "",
        "<p>",
        "An analysis shall be performed to analyze the failure modes of exception handling. In particular, the following failure modes shall be analyzed:",
        "</p>",
        "",
        "<ol type='a'>",
        "<li>worst time execution time not existing or cannot be determined,</li>",
        "<li>stack not correctly unwound,</li>",
        "<li>exception not thrown, other exception thrown, wrong catch activated,</li>",
        "<li>memory not available while exception handling.</li>",
        "</ol>"
      ]
    }
  },
  "A15-0-7": {
    "checked": false,
    "language": "C++",
    "tags": [ "Language: C++", "Language: C", "Standard: AUTOSAR", "Category: Required", "Automation: Partially Automated", "Exception Handling" ],
    "name": "Published Standards/AUTOSAR/Exception handling mechanism shall guarantee a deterministic worst-case time execution time",
    "desc": {
      "html": [
        "<p><b>",
        "This check cannot be automated",
        "</b></p>",
        "",
        "<p>",
        "Exception handling mechanism shall guarantee a deterministic worst-case time execution time",
        "</p>"
      ]
    }
  },
  "A15-0-8": {
    "checked": false,
    "language": "C++",
    "tags": [ "Language: C++", "Language: C", "Standard: AUTOSAR", "Category: Required", "Automation: Non-automated", "Exception Handling" ],
    "name": "Published Standards/AUTOSAR/A worst-case execution time (WCET) analysis shall be performed to determine maximum execution time constraints of the software, covering in particular the exceptions processing",
    "desc": {
      "html": [
        "<p><b>",
        "This check cannot be automated",
        "</b></p>",
        "",
        "<p>",
        "A worst-case execution time (WCET) analysis shall be performed to determine maximum execution time constraints of the software, covering in particular the exceptions processing",
        "</p>"
      ]
    }
  },
  "A15-3-2": {
    "checked": false,
    "language": "C++",
    "tags": [ "Language: C++", "Automation: Non-automated", "Category: Required", "Exception Handling", "Standard: AUTOSAR"],
    "name": "Published Standards/AUTOSAR/If a function throws an exception, it shall be handled when meaningful actions can be taken, otherwise it shall be propagated",
    "desc": {
      "html": [
        "<p><b>",
        "This check cannot be automated",
        "</b></p>",
        "",
        "<p>",
        "If a function throws an exception, it shall be handled when meaningful actions can be taken, otherwise it shall be propagated",
        "</p>"
      ]
    }
  },
  "A17-0-2": {
    "checked": false,
    "language": "C++",
    "tags": [ "Language: C++", "Automation: Non-automated", "Category: Required", "Libraries", "Standard: AUTOSAR"],
    "name": "Published Standards/AUTOSAR/All project’s code including used libraries and any third-party user code shall conform to the AUTOSAR C++14 Coding Guidelines",
    "desc": {
      "html": [
        "<p><b>",
        "This check cannot be automated",
        "</b></p>",
        "",
        "<p>",
        "All project’s code including used libraries (including standard and ",
        "user-defined libraries) and any third-party user code shall conform to the ",
        "AUTOSAR C++14 Coding Guidelines.",
        "</p>"
      ]
    }
  },
  "A17-1-1": {
    "checked": false,
    "language": "C++",
    "tags": [ "Language: C++", "Automation: Non-automated", "Category: Required", "Libraries", "Standard: AUTOSAR"],
    "name": "Published Standards/AUTOSAR/Use of the C Standard Library shall be encapsulated and isolated",
    "desc": {
      "html": [
        "<p><b>",
        "This check cannot be automated",
        "</b></p>",
        "",
        "<p>",
        "Use of the C Standard Library shall be encapsulated and isolated",
        "</p>"
      ]
    }
  },
  "A18-5-10": {
    "checked": false,
    "language": "C++",
    "tags": [ "Language: C++", "Automation: Automated", "Category: Required", "Memory Allocation", "Standard: AUTOSAR"],
    "name": "Published Standards/AUTOSAR/Placement new shall be used only with properly aligned pointers to sufficient storage capacity",
    "desc": {
      "html": [
        "<p><b>",
        "This check cannot be automated",
        "</b></p>",
        "",
        "<p>",
        "Placement new shall be used only with properly aligned pointers to sufficient",
        "storage capacity",
        "</p>"
      ]
    }
  },
  "A18-5-5": {
    "checked": false,
    "language": "C++",
    "tags": [ "Language: C++", "Automation: Partially Automated", "Category: Required", "Memory Allocation", "Standard: AUTOSAR"],
    "name": "Published Standards/AUTOSAR/Memory management functions shall ensure the following",
    "desc": {
      "html": [
        "<p><b>",
        "This check cannot be automated",
        "</b></p>",
        "",
        "<p>",
        "Memory management functions shall ensure the following:",
        "</p>",
        "",
        "<ol type='a'>",
        "<li>deterministic behavior resulting with the existence of worst-case execution",
        "time,</li>",
        "<li>avoiding memory fragmentation,</li>",
        "<li>avoid running out of memory,</li>",
        "<li>avoiding mismatched allocations or deallocations,</li>",
        "<li>no dependence on non-deterministic calls to kernel.</li>",
        "</ol>"
      ]
    }
  },
  "A18-5-6": {
    "checked": false,
    "language": "C++",
    "tags": [ "Language: C++", "Automation: Non-automated", "Category: Required", "Memory Allocation", "Standard: AUTOSAR"],
    "name": "Published Standards/AUTOSAR/An analysis shall be performed to analyze the failure modes of dynamic memory management",
    "desc": {
      "html": [
        "<p><b>",
        "This check cannot be automated",
        "</b></p>",
        "",
        "<p>",
        "An analysis shall be performed to analyze the failure modes of dynamic memory",
        "management. In particular, the following failure modes shall be analyzed:",
        "</p>",
        "",
        "<ol type='a'>",
        "<li>non-deterministic behavior resulting with nonexistence of worst-case",
        "execution time,</li>",
        "<li>memory fragmentation,</li>",
        "<li>running out of memory,</li>",
        "<li>mismatched allocations and deallocations,</li>",
        "<li>dependence on non-deterministic calls to kernel.</li>",
        "</ol>"
      ]
    }
  },
  "A2-7-5": {
    "checked": false,
    "language": "C++",
    "tags": [ "Language: C++", "Automation: Non-automated", "Category: Required", "Comments", "Standard: AUTOSAR"],
    "name": "Published Standards/AUTOSAR/Comments shall not document any actions or sources (e.g. tables, figures, paragraphs, etc.) that are outside of the file",
    "desc": {
      "html": [
        "<p><b>",
        "This check cannot be automated",
        "</b></p>",
        "",
        "<p>",
        "Comments shall not document any actions or sources (e.g. tables, figures, paragraphs, etc.) that are outside of the file",
        "</p>"
      ]
    }
  },
  "A23-0-2": {
    "checked": false,
    "language": "C++",
    "tags": [ "Language: C++", "Automation: Automated", "Category: Required", "Memory Allocation", "Standard: AUTOSAR"],
    "name": "Published Standards/AUTOSAR/Elements of a container shall only be accessed via valid references, iterators, and pointers",
    "desc": {
      "html": [
        "<p><b>",
        "This check cannot be automated",
        "</b></p>",
        "",
        "<p>",
        "Elements of a container shall only be accessed via valid references, iterators,",
        "and pointers",
        "</p>"
      ]
    }
  },
  "A25-4-1": {
    "checked": false,
    "language": "C++",
    "tags": [ "Language: C++", "Automation: Non-automated", "Category: Required", "Types", "Standard: AUTOSAR"],
    "name": "Published Standards/AUTOSAR/Ordering predicates used with associative containers and STL sorting and related algorithms shall adhere to a strict weak ordering relation",
    "desc": {
      "html": [
        "<p><b>",
        "This check cannot be automated",
        "</b></p>",
        "",
        "<p>",
        "Ordering predicates used with associative containers and STL sorting and related algorithms shall adhere to a strict weak ordering relation",
        "</p>"
      ]
    }
  },
  "A27-0-2": {
    "checked": false,
    "language": "C++",
    "tags": [ "Language: C++", "Automation: Automated", "Category: Advisory", "Types", "Standard: AUTOSAR"],
    "name": "Published Standards/AUTOSAR/A C-style string shall guarantee sufficient space for data and the null terminator",
    "desc": {
      "html": [
        "<p><b>",
        "This check cannot be automated",
        "</b></p>",
        "",
        "<p>",
        "A C-style string shall guarantee sufficient space for data and the null terminator",
        "</p>"
      ]
    }
  },
  "A3-8-1": {
    "checked": false,
    "language": "C++",
    "tags": [ "Language: C++", "Automation: Automated", "Category: Required", "Memory Allocation", "Standard: AUTOSAR"],
    "name": "Published Standards/AUTOSAR/An object shall not be accessed outside of its lifetime",
    "desc": {
      "html": [
        "<p><b>This check cannot be automated</b></p>",
        "<p><b>Rationale</b></p>",
        "<p>Accessing an object outside of its lifetime, i.e. before its initialization",
        "or constructor has completed, or after its non-trivial destructor has finished,",
        "is well defined only for a very restricted number of cases, as laid out by the",
        "language standard. Outside of these cases it leads to undefined behavior.</p>",
        "<p>Note: The AUTOSAR C++14 guidelines contain several other rules which are",
        "special cases of this rule (see references below). This rule was added to",
        "provide generic coverage for all cases not contained in these specialized rules.",
        "This also makes it easier to provide tracing from other standards with a similar",
        "generic rule.</p>",
        "<p>Note: The examples given below are not intended to represent a complete list of",
        "situations where violations of this rule can occur.</p>",
        "<p><b>Example</b></p>",
        "<pre>",
        "1  //% $Id: A3-8-1.cpp 305786 2018-01-30 08:58:33Z michal.szczepankiewicz $",
        "2",
        "3  //",
        "4  // 1. Pointer to virtual base is passed as function argument after lifetime of",
        "5  // object has ended.",
        "6  //",
        "7",
        "8  class B",
        "9  {",
        "10 };",
        "11",
        "12 class C1 : public virtual B // violates M10-1-1",
        "13 {",
        "14 };",
        "15",
        "16 class C2 : public virtual B // violates M10-1-1",
        "17 {",
        "18 };",
        "19",
        "20 class D : public C1, public C2",
        "21 {",
        "22 };",
        "23",
        "24 void f(B const* b){};",
        "25",
        "26 void example1()",
        "27 {",
        "28  D* d = new D(); // lifetime of d starts (violates A18-5-2)",
        "29  // Use d",
        "30  delete d; // lifetime of d ends (violates A18-5-2)",
        "31",
        "32  f(d); // Non-compliant - Undefined behavior, even if argument is not used",
        "33  // by f().",
        "34 }",
        "35",
        "36 //",
        "37 // 2. Accessing an initializer_list after lifetime of initializing array has",
        "38 // ended.",
        "39 //",
        "40 class E",
        "41 {",
        "42   std::initializer_list&lt;int&gt; lst;",
        "43",
        "44   public:",
        "45     // Conceptually, this works as if a temporary array {1, 2, 3} was created",
        "46     // and a reference to this array was passed to the initializer_list. The",
        "47     // lifetime of the temporary array ends when the constructor finishes.",
        "48     E() : lst{1, 2, 3} {}",
        "49",
        "50     int first() const { return *lst.begin(); }",
        "51 };",
        "52",
        "53 void example2()",
        "54 {",
        "55   E e;",
        "56   std::out &lt;&lt; e.first() &lt;&lt; \"",
        "\"; // Non-compliant",
        "57 }",
        "58",
        "59 //",
        "60 // 3. Exiting main while running tasks depend on static objects",
        "61 //",
        "62 void initialize_task()",
        "63 {",
        "64   // start some task (separate thread) which depends on some static object.",
        "65   // ...",
        "66 }",
        "67",
        "68 int main()",
        "69 {",
        "70   // static constructors are called",
        "71",
        "72   initialize_task();",
        "73 } // main ends, static destructors are called",
        "74",
        "75 // Non-compliant",
        "76 // Task begins to run and accesses destroyed static object.",
        "77",
        "78 //",
        "79 // 4. Storage reuse without explicit destructor call",
        "80 //",
        "81 void example4()",
        "82 {",
        "83   std::string str;",
        "84   new (&a) std::vector&lt;int&gt;{}; // Non-compliant: storage of str reused without",
        "85   // calling its non-trivial destructor.",
        "86 } // Non-compliant: Destructor of str is implicitly called at scope exit, but",
        "87 // storage contains object of different type.",
        "</pre>"
      ]
    }
  },
  "A7-2-5": {
    "checked": false,
    "language": "C++",
    "tags": [ "Language: C++", "Automation: Non-automated", "Category: Advisory", "Types", "Standard: AUTOSAR"],
    "name": "Published Standards/AUTOSAR/Enumerations should be used to represent sets of related named constants",
    "desc": {
      "html": [
        "<p><b>",
        "This check cannot be automated",
        "</b></p>",
        "",
        "<p>",
        "Enumerations should be used to represent sets of related named constants",
        "</p>"
      ]
    }
  },
  "A8-4-14": {
    "checked": false,
    "language": "C++",
    "tags": [ "Language: C++", "Automation: Non-automated", "Category: Required", "Types", "Standard: AUTOSAR"],
    "name": "Published Standards/AUTOSAR/Interfaces shall be precisely and strongly typed",
    "desc": {
      "html": [
        "<p><b>",
        "This check cannot be automated",
        "</b></p>",
        "",
        "<p>",
        "Interfaces shall be precisely and strongly typed",
        "</p>"
      ]
    }
  },
  "A9-6-2": {
    "checked": false,
    "language": "C++",
    "tags": [ "Language: C++", "Automation: Non-automated", "Category: Required", "Bit-fields", "Standard: AUTOSAR"],
    "name": "Published Standards/AUTOSAR/Bit-fields shall be used only when interfacing to hardware or conforming to communication protocols",
    "desc": {
      "html": [
        "<p><b>",
        "This check cannot be automated",
        "</b></p>",
        "",
        "<p>",
        "Bit-fields shall be used only when interfacing to hardware or conforming to communication protocols",
        "</p>"
      ]
    }
  },
  "M0-3-2": {
    "checked": false,
    "language": "C++",
    "tags": [ "Language: C++", "Automation: Non-automated", "Category: Required", "Exception Handling", "Standard: AUTOSAR"],
    "name": "Published Standards/AUTOSAR/If a function generates error information, then that error information shall be tested",
    "desc": {
      "html": [
        "<p><b>",
        "This check cannot be automated",
        "</b></p>",
        "",
        "<p>",
        "If a function generates error information, then that error information shall be tested",
        "</p>"
      ]
    }
  },
  "M1-0-2": {
    "checked": false,
    "language": "C++",
    "tags": [ "Language: C++", "Automation: Non-automated", "Category: Required", "Libraries", "Standard: AUTOSAR"],
    "name": "Published Standards/AUTOSAR/Multiple compilers shall only be used if they have a common, defined interface",
    "desc": {
      "html": [
        "<p><b>",
        "This check cannot be automated",
        "</b></p>",
        "",
        "<p>",
        "Multiple compilers shall only be used if they have a common, defined interface.",
        "</p>"
      ]
    }
  },
  "M5-19-1": {
    "checked": false,
    "language": "C++",
    "tags": [ "Language: C++", "Automation: Automated", "Category: Required", "Types", "Standard: AUTOSAR"],
    "name": "Published Standards/AUTOSAR/Evaluation of constant unsigned integer expressions shall not lead to wrap-around",
    "desc": {
      "html": [
        "<p><b>",
        "This check cannot be automated",
        "</b></p>",
        "",
        "<p>",
        "Evaluation of constant unsigned integer expressions shall not lead to wrap-around.",
        "</p>"
      ]
    }
  },
  "M9-6-1": {
    "checked": false,
    "language": "C++",
    "tags": [ "Language: C++", "Automation: Non-automated", "Category: Required", "Bit-fields", "Standard: AUTOSAR"],
    "name": "Published Standards/AUTOSAR/When the absolute positioning of bits representing a bit-field is required, then the behavior and packing of bit-fields shall be documented",
    "desc": {
      "html": [
        "<p><b>",
        "This check cannot be automated",
        "</b></p>",
        "",
        "<p>",
        "When the absolute positioning of bits representing a bit-field is required, then the behavior and packing of bit-fields shall be documented",
        "</p>"
      ]
    }
  },
  "M0-1-9": {
    "checked": false,
    "language": "C++",
    "tags": [ "Language: C++", "Automation: Automated", "Category: Required", "Control Flow", "Standard: AUTOSAR"],
    "name": "Published Standards/AUTOSAR/There shall be no dead code",
    "desc": {
      "html": [
        "<p><b>",
        "This check cannot be automated",
        "</b></p>",
        "",
        "<p>",
        "There shall be no dead code",
        "</p>"
      ]
    }
  }
}
