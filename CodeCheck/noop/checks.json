{
  "CPP_DD004": {
    "checked": true,
    "language": "C++",
    "tags": [ "Language: C++", "Language: C", "Declarations and Definitions" ],
    "name": "All Checks/Language Specific/C and C++/Headers/Prototypes for static functions shall include the static storage class",
    "desc": {
      "html": [
        "<p><b>Rationale</b></p>",
        "<p>Prototypes for static functions shall include the static storage class. This is a convention that improves the readability and maintainability of the code.</p>",
        "<p><b>Examples</b></p>",
        "<pre>",
        "int addNumbers(int a, int b);",
        "",
        "int main() {",
        "",
        "   int sum;",
        "   sum = addNumbers(4, 2);",
        "",
        "   return 0;",
        "}",
        "",
        "static int addNumbers(int a, int b) { // Violation, static declaration follows non-static declaration",
        "",
        "   return a + b;",
        "",
        "}",
        "</pre>",
        "</p>"
      ]
    }
  },
  "CPP_H000": {
    "checked": true,
    "language": "C++",
    "tags": [ "Language: C++", "Headers" ],
    "name": "All Checks/Language Specific/C and C++/Headers/The #include directive shall be followed by either a <filename> or \"filename\" sequence",
    "desc": {
      "html": [
        "<p><b>Rationale</b></p>",
        "These are the only forms for the #include directive permitted by ISO/IEC 14882:2003 [1].<br></p>",
        "<p><b>Example</b></p><pre style=\"margin-top:0;padding-top:0;\">",
        "For example, the following are allowed.",
        "#include \"filename.h\" // Compliant",
        "#include &lt;filename.h&gt; // Compliant",
        "#define HEADER \"filename.h\" // Non-compliant with Rule 16-2-2",
        "#include HEADER // Compliant",
        "#include another.h // Non-compliant",
        "</pre>"
      ]
    }
  },
  "CPP_E002": {
    "checked": true,
    "language": "C++",
    "tags": [ "Language: C++", "Exception Handling" ],
    "name": "All Checks/Language Specific/C and C++/Exception Handling/Catch-All Statement Before Last",
    "desc": {
      "html": [
        "<p><b>Title</b></p>",
        "<p>Where multiple handlers are provided in a single <i>try-catch</i> statement or <i>function-try-block</i>, any ellipsis (catch-all) handler shall occur last.</p>",
        "<p><b>Rationale</b></p>",
        "<p>If the catch-all handler is found before any other handler, that behaviour will be performed. Any handlers after the catch-all are <i>unreachable code</i> and can never be executed.</p>",
        "<p><b>Example</b></p><pre><code language=\"C++\">void f1 ( )",
        "{",
        "   try",
        "   {",
        "      // ...",
        "   }",
        "   catch ( int32_t i )   // int handler",
        "   {",
        "      // Handle int exceptions",
        "   }",
        "   catch( ... )          // catch-all handler",
        "   {",
        "      // Handle all other exception types",
        "   }",
        "}",
        "void f2 ( )",
        "{",
        "   try",
        "   {",
        "      // ...",
        "   }",
        "   catch( ... )          // catch-all handler",
        "   {",
        "      // Handle all exception types",
        "   }",
        "   catch ( int32_t i )   // Non-compliant - handler will never be called",
        "   {",
        "   }",
        "}",
        "</code></pre>"
      ]
    }
  },
  "CPP_E026": {
    "checked": true,
    "language": "C++",
    "tags": [ "Language: C++", "Exception Handling" ],
    "name": "All Checks/Language Specific/C and C++/Exception Handling/Minimization of run-time failures shall be ensured by the use of static analysis tools",
    "desc": {
      "html": [
        "<p><b>Rule</b></p><p>",
        "Minimization of run-time failures shall be ensured by the use of at least one of:<br>",
        "&nbsp;&nbsp;(a) static analysis tools/techniques;<br> ",
        "&nbsp;&nbsp;(b) dynamic analysis tools/techniques;<br>",
        "&nbsp;&nbsp;(c) explicit coding of checks to handle run-time faults.</p>",
        "",
        "<p><b>Rationale</b></p><p>",
        "Run-time checking is an issue (not specific to C++) to which developers need to pay special ",
        "attention, especially as the C++ language is weak in its provision of any run-time checking. C++ ",
        "implementations are not required to perform many of the dynamic checks that are necessary for ",
        "robust software. It is therefore an issue that C++ developers need to consider carefully, adding ",
        "dynamic checks to code wherever there is the potential for run-time errors to occur.</p>",
        "",
        "<p>Where expressions consist only of values within a well-defined range, a run-time check may ",
        "not be necessary, provided it can be demonstrated that for all values within the defined range ",
        "the exception cannot occur. Such a demonstration, if used, should be documented along with ",
        "the assumptions on which it depends. However, if adopting this approach, be very careful about ",
        "subsequent modifications of the code that may invalidate the assumptions, or of the assumptions ",
        "changing for any other reason.</p>",
        "",
        "<p>The following notes give some guidance on areas where consideration needs to be given to the ",
        "provision of dynamic checks.</p>",
        "",
        "<p><b>Arithmetic Errors</b></p><p>",
        "This includes errors occurring in the evaluation of expressions, such as overflow, underflow, ",
        "division by zero or loss of significant bits through shifting.",
        "In considering integer overflow, note that unsigned integer calculations do not strictly ",
        "overflow (producing undefined values), but the values wrap around (producing defined, but ",
        "possibly unexpected, values).</p>",
        "",
        "<p><b>Pointer Arithmetic</b></p><p>",
        "Ensure that when an address is calculated dynamically the computed address is reasonable ",
        "and points somewhere meaningful. In particular it should be ensured that if a pointer points ",
        "within a structure or array, then when the pointer has been incremented or otherwise altered ",
        "it still points to the same structure or array. See Rule 5-0-15, Rule 5-0-16, Rule 5-0-17 ",
        "and Rule 5-0-18 for restrictions on pointer arithmetic.</p>",
        "",
        "<p><b>Array Bound Errors</b></p><p>",
        "Ensure that array indices are within the bounds of the array size before using them to index ",
        "the array.</p>",
        "",
        "<p><b>Function Arguments</b></p><p>",
        "Function arguments should be validated.</p>",
        "",
        "<p><b>Pointer Dereferencing</b></p><p>",
        "Where a function returns a pointer and that pointer is subsequently de-referenced the ",
        "program should first check that the pointer is not NULL. Within a function, it is relatively ",
        "straightforward to reason about which pointers may or may not hold NULL values. Across ",
        "function boundaries, especially when calling functions defined in other source files or ",
        "libraries, it is much more difficult.</p>",
        "",
        "<pre style=\"margin-top:0;padding-top:0;\">",
        "// Given a pointer to a message, check the message header and return",
        "// a pointer to the body of the message or NULL if the message is",
        "// invalid.",
        "const char_t *msg_body ( const char_t * msg )",
        "{",
        "const char_t * body = NULL;",
        "  if ( msg != NULL )",
        "  {",
        "    if ( msg_header_valid ( msg ) )",
        "    {",
        "      body = &msg [ MSG_HEADER_SIZE ];",
        "    }",
        "  }",
        "  return ( body );",
        "}",
        "...",
        "char_t msg_buffer [ MAX_MSG_SIZE ];",
        "const char_t * payload;",
        "...",
        "payload = msg_body ( msg_buffer );",
        "if ( payload != NULL )",
        "{",
        "  // process the message payload",
        "}",
        "</pre>",
        "",
        "<p>The techniques that will be employed to minimize run-time failures should be planned and ",
        "documented, e.g. in design standards, test plans, static analysis configuration files, code review ",
        "checklists.</p>"
      ]
    }
  },
  "CPP_E030": {
    "checked": true,
    "language": "C++",
    "tags": [ "Language: C++", "Language: C", "Category: Required", "Automation: Automated", "Expressions", "Standard: AUTOSAR" ],
    "name": "Published Standards/AUTOSAR/Concatenating String Literals of Different Encodings",
    "desc": {
      "html": [
        "<b>This check is automatically run</b>",
        "",
        "<p><b>Title</b></p>",
        "<p>String literals with different encoding prefixes shall not be concatenated.</p>",
        "",
        "<p><b>Rationale</b></p>",
        "<p>Concatenation of wide and narrow string literals leads to undefined behavior.</p>",
        "<p>\"In translation phase 6 (2.2), adjacent string-literals are concatenated. If both string-literals have the same encoding-prefix, the resulting concatenated string literal has that encoding-prefix. If one string-literal has no encoding-prefix, it is treated as a string-literal of the same encoding-prefix as the other operand. If a UTF-8 string literal token is adjacent to a wide string literal token, the program is ill-formed. Any other concatenations are conditionally-supported with implementation-defined behavior. [ Note: This concatenation is an interpretation, not a conversion. Because the interpretation happens in translation phase 6 (after each character from a literal has been translated into a value from the appropriate character set), a string-literal's initial rawness has no effect on the interpretation or well-formedness of the concatenation. -end note ]\" [C++14 Language Standard] [3]</p>",
        "<p><b>Example</b></p>",
        "<pre><code language=\"C++\">char16_t nArray[] =",
        "    u\"Hello\"",
        "    u\"World\";  // Compliant, \"u\" stands for char16_t type",
        "",
        "char32_t nArray2[] =",
        "    U\"Hello\"",
        "    U\"World\";  // Compliant, \"U\" stands for char32_t type",
        "",
        "wchar_t wArray[] =",
        "    L\"Hello\"",
        "    L\"World\";  // Compliant, \"L\" stands for wchar_t type - violates A2-13-3",
        "               // rule.",
        "",
        "wchar_t mixed1[] =",
        "    \"Hello\"",
        "    L\"World\";  // Compliant",
        "",
        "char32_t mixed2[] =",
        "    \"Hello\"",
        "    U\"World\";  // Compliant",
        "",
        "char16_t mixed3[] =",
        "    \"Hello\"",
        "    u\"World\";  // Compliant",
        "",
        "// wchar_t mixed1[] = u\"Hello\" L\"World\";  // Non-compliant - compilation error",
        "",
        "// char32_t mixed2[] = u\"Hello\" U\"World\";  // Non-compliant - compilation error</code></pre>",
        "",
        "<p><b>See also</b></p>",
        "<ul>",
        "<li>MISRA C++ 2008 [7]: required 2-13-5 Narrow and wide string literals shall not be concatenated.</li>",
        "<li>HIC++ v4.0 [9]: 2.5.1 Do not concatenate strings with different encoding prefixes</li>",
        "</ul>"
      ]
    }
  },
  "CPP_P059": {
    "checked": true,
    "language": "C++",
    "tags": [ "Language: C++", "Pointers" ],
    "name": "All Checks/Language Specific/C and C++/Pointers/A pointer to a virtual base class shall only be cast to a pointer to a derived class by means of dynamic_cast",
    "desc": {
      "html": [
        "<b>This check is automatically run</b>",
        "<p>This check is always run during the strict analysis, any violations will be reported as analysis errors.</p>",
        "<p><b>Rationale</b></p>",
        "<p>Casting from a virtual base to a derived class, using any means other than",
        "dynamic_cast has undefined behaviour. The behaviour for dynamic_cast is",
        "defined.</p>",
        "<p><b>Example</b></p>",
        "<pre>",
        "class B { ... };",
        "class D: public virtual B { ... };",
        "D d;",
        "B *pB = &d;",
        "D *pD = static_cast&lt;D*&gt;(pB); // Non-compliant - undefined behaviour",
        "D *pD2 = dynamic_cast&lt;D*&gt;(pB); // Compliant, but pD2 may be NULL",
        "D & D3 = dynamic_cast&lt;D&&gt;(*pB); // Compliant, but may throw an exception</pre>"
      ]
    }
  },
  "CPP_P025": {
    "checked": false,
    "language": "C++",
    "tags": [ "Language: C++", "Preprocessor" ],
    "name": "All Checks/Language Specific/C and C++/Preprocessor/All macro identifiers in preprocessor directives shall be defined before use, except in #ifdef and #ifndef preprocessor directives and the defined() operator",
    "desc": {
      "html": [
        "",
        "<p><b>Rationale</b></p>",
        "",
        "If an attempt is made to use an identifier in a preprocessor directive, and that",
        "identifier has not been defined, the preprocessor will sometimes not give any",
        "warning but will assume the value zero. <i>#ifdef</i>, <i>#ifndef</i> and",
        "<i>defined()</i> are provided to test the existence of a macro, and are",
        "therefore excluded.",
        "</p>",
        "",
        "<p><b>Example</b></p>",
        "",
        "<pre>",
        "#if x &lt; 0 /* x assumed to be zero as it is not defined */",
        "</pre>",
        "",
        "<p>",
        "Consideration should be given to the use of a <i>#ifdef</i> test before an",
        "identifier is used.",
        "</p>",
        "",
        "<p>",
        "Note that preprocessing identifiers may be defined either by use of",
        "<i>#define</i> directives or by options specified at compiler invocation.",
        "However, the use of the <i>#define</i> directive is preferred.",
        "</p>"
      ]
    }
  },
  "CPP_V042": {
    "checked": false,
    "language": "C++",
    "tags": [ "Language: C++", "Variables" ],
    "name": "All Checks/Language Specific/C and C++/Variables/An object shall not be accessed outside of its lifetime",
    "desc": {
      "html": [
        "<b>This check cannot be automated</b>",
        "<p><b>Rationale</b></p>",
        "<p>Accessing an object outside of its lifetime, i.e. before its initialization",
        "or constructor has completed, or after its non-trivial destructor has finished,",
        "is well defined only for a very restricted number of cases, as laid out by the",
        "language standard. Outside of these cases it leads to undefined behavior.</p>",
        "<p>Note: The AUTOSAR C++14 guidelines contain several other rules which are",
        "special cases of this rule (see references below). This rule was added to",
        "provide generic coverage for all cases not contained in these specialized rules.",
        "This also makes it easier to provide tracing from other standards with a similar",
        "generic rule.</p>",
        "<p>Note: The examples given below are not intended to represent a complete list of",
        "situations where violations of this rule can occur.</p>",
        "<p><b>Example</b></p>",
        "<pre>",
        "1  //% $Id: A3-8-1.cpp 305786 2018-01-30 08:58:33Z michal.szczepankiewicz $",
        "2",
        "3  //",
        "4  // 1. Pointer to virtual base is passed as function argument after lifetime of",
        "5  // object has ended.",
        "6  //",
        "7",
        "8  class B",
        "9  {",
        "10 };",
        "11",
        "12 class C1 : public virtual B // violates M10-1-1",
        "13 {",
        "14 };",
        "15",
        "16 class C2 : public virtual B // violates M10-1-1",
        "17 {",
        "18 };",
        "19",
        "20 class D : public C1, public C2",
        "21 {",
        "22 };",
        "23",
        "24 void f(B const* b){};",
        "25",
        "26 void example1()",
        "27 {",
        "28  D* d = new D(); // lifetime of d starts (violates A18-5-2)",
        "29  // Use d",
        "30  delete d; // lifetime of d ends (violates A18-5-2)",
        "31",
        "32  f(d); // Non-compliant - Undefined behavior, even if argument is not used",
        "33  // by f().",
        "34 }",
        "35",
        "36 //",
        "37 // 2. Accessing an initializer_list after lifetime of initializing array has",
        "38 // ended.",
        "39 //",
        "40 class E",
        "41 {",
        "42   std::initializer_list&lt;int&gt; lst;",
        "43",
        "44   public:",
        "45     // Conceptually, this works as if a temporary array {1, 2, 3} was created",
        "46     // and a reference to this array was passed to the initializer_list. The",
        "47     // lifetime of the temporary array ends when the constructor finishes.",
        "48     E() : lst{1, 2, 3} {}",
        "49",
        "50     int first() const { return *lst.begin(); }",
        "51 };",
        "52",
        "53 void example2()",
        "54 {",
        "55   E e;",
        "56   std::out &lt;&lt; e.first() &lt;&lt; \"",
        "\"; // Non-compliant",
        "57 }",
        "58",
        "59 //",
        "60 // 3. Exiting main while running tasks depend on static objects",
        "61 //",
        "62 void initialize_task()",
        "63 {",
        "64   // start some task (separate thread) which depends on some static object.",
        "65   // ...",
        "66 }",
        "67",
        "68 int main()",
        "69 {",
        "70   // static constructors are called",
        "71",
        "72   initialize_task();",
        "73 } // main ends, static destructors are called",
        "74",
        "75 // Non-compliant",
        "76 // Task begins to run and accesses destroyed static object.",
        "77",
        "78 //",
        "79 // 4. Storage reuse without explicit destructor call",
        "80 //",
        "81 void example4()",
        "82 {",
        "83   std::string str;",
        "84   new (&a) std::vector&lt;int&gt;{}; // Non-compliant: storage of str reused without",
        "85   // calling its non-trivial destructor.",
        "86 } // Non-compliant: Destructor of str is implicitly called at scope exit, but",
        "87 // storage contains object of different type.",
        "</pre>"
      ]
    }
  },
  "VHDL_4": {
    "checked": false,
    "language": "VHDL",
    "tags": [ "Language: VHDL", "Control Flow" ],
    "name": "All Checks/Language Specific/Vhdl/VHDL_4 Incomplete sensitivity lists shall not contain signals not needed by process",
    "desc": {
      "html": [
        "<b>This check cannot be automated</b>",
        "<p>This check is beyond the capability of static analysis, as it requires programmer knowledge to verify.</p>",
        "<p><b>Title</b></p>",
        "<p>Incomplete sensitivity lists shall not contain signals not needed by process</p>",
        "<p><b>Description</b></p>",
        "<p>Keeping the sensitivity list of a process in VHDL concise and containing only the necessary signals is important",
        "for efficient simulation, code readability, predictability, maintainability, and accurate hardware synthesis. It helps",
        "ensure that the code reflects the intended behavior of the design and avoids unnecessary computational overhead and potential errors.</p>",
        "<p><b>Noncompliant Code Example</b></p>",
        "<pre>",
        "library IEEE;",
        "use IEEE.STD_LOGIC_1164.ALL;",
        "",
        "entity NoncompliantExample is",
        "  Port ( A, B, C, D : in STD_LOGIC;",
        "         Y : out STD_LOGIC);",
        "end NoncompliantExample;",
        "",
        "architecture Behavioral of NoncompliantExample is",
        "begin",
        "  process (A, B, C, D)",
        "    -- This process is intended to respond to changes in A and B only,",
        "    -- but it includes signals C and D in the sensitivity list unnecessarily.",
        "    if (C = '1' and D = '1') then",
        "      Y  &lt;= '1';",
        "    else",
        "      Y  &lt;= '0';",
        "    end if;",
        "  end process;",
        "end Behavioral;</pre>"
      ]
    }
  },
  "VHDL_23": {
    "checked": false,
    "language": "VHDL",
    "tags": [ "Language: VHDL", "Control Flow" ],
    "name": "All Checks/Language Specific/Vhdl/VHDL_23 Unreachable case items",
    "desc": {
      "html": [
        "<b>This check cannot be automated</b>",
        "<p>This check is beyond the capability of static analysis, as it requires programmer knowledge to verify.</p>",
        "<p><b>Title</b></p>",
        "<p>Unreachable case items</p>",
        "<p><b>Description</b></p>",
        "<p>It is important to eliminate unreachable case items in VHDL code to ensure a clear and unambiguous description",
        "of the design's behavior and to avoid potential issues during simulation and synthesis. Unreachable case items can",
        "lead to dead code, making the code harder to understand and maintain. Additionally, it can confuse simulation tools",
        "and potentially result in incomplete or incorrect simulations. During synthesis, unreachable case items may lead to",
        "inefficient or unnecessary logic being synthesized into hardware, impacting the design's performance and resource utilization.",
        "Therefore, removing unreachable case items is essential for code clarity, correctness, and efficient design implementation.</p>",
        "<p><b>Noncompliant Code Example</b></p>",
        "<pre>",
        "library IEEE;",
        "use IEEE.STD_LOGIC_1164.ALL;",
        "",
        "entity UnreachableCaseExample is",
        "  Port ( A : in STD_LOGIC;",
        "         Y : out STD_LOGIC);",
        "end UnreachableCaseExample;",
        "",
        "architecture Behavioral of UnreachableCaseExample is",
        "begin",
        "  process (A)",
        "  begin",
        "    case A is",
        "      when '0' =>",
        "        Y  &lt;= '1';",
        "      when others =>",
        "        Y  &lt;= '0';",
        "      when '1' =>",
        "        Y  &lt;= '1';  -- Unreachable case item",
        "    end case;",
        "  end process;",
        "end Behavioral;</pre>"
      ]
    }
  },
  "CPP_C048": {
    "checked": true,
    "language": "C++",
    "tags": [ "Language: C++", "Automation: Non-automated", "Category: Required", "Control Flow", "Standard: AUTOSAR"],
    "name": "All Checks/Language Specific/C and C++/Control Flow/Transferring Control to a Try or Catch Block Using Goto or Switch Statement",
    "desc": {
      "html": [
        "<b>This check is automatically run</b>",
        "<p>This check is always run during the strict analysis, any violations will be reported as analysis errors.</p>",
        "<p><b>Rationale</b></p>",
        "<p>A program is ill-formed if control is transferred into a try or catch block using a goto or switch statement; however, not all compilers issue a diagnostic message.</p>",
        "<p><b>Example</b></p>",
        "<pre><code language=\"C++\">void f ( int32_t i )",
        "{",
        " if ( 10 == i )",
        " {",
        " goto Label_10; // Non-compliant",
        " }",
        " if ( 11 == i )",
        " {",
        " goto Label_11; // Non-compliant",
        " }",
        " switch ( i )",
        " {",
        " case 1:",
        " try",
        " {",
        " Label_10:",
        " case 2: // Non-compliant – also violates switch rules",
        " // Action",
        " break;",
        " }",
        " catch ( ... )",
        " {",
        " Label_11:",
        " case 3: // Non-compliant – also violates switch rules",
        " // Action",
        " break;",
        " }",
        " break;",
        " default:",
        " {",
        " // Default Action",
        " break;",
        " }",
        " }",
        "}</code></pre>"
      ]
    }
  }
}
