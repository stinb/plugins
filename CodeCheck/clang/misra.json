{
  "MISRA08_2-13-1": {
    "tags": ["Language: C", "Language: C++", "Standard: MISRA C++ 2008", "Category: Required", "Expressions"],
    "key": "unknown-escape-sequence",
    "name": "Published Standards/MISRA-C++ 2008/2-13-1 Nonstandard Escape Sequences",
    "test": "CPP_E022",
    "desc": {
      "html": [
        "<p><b>Title</b></p>",
        "<p>Only those escape sequences that are defined in ISO/IEC 14882:2003 shall be used.</p>",
        "<p><b>Rationale</b></p>",
        "<p>The use of an undefined escape sequence leads to <i>undefined behaviour</i>.</p>",
        "<p>The defined escape sequences (ISO/IEC 14882:2003 [1] 2.13.2) are:</p>",
        "<p><i>\\n, \\t, \\v, \\b, \\r, \\f, \\a, \\\\, \\?, \\', \\\", \\&lt;Octal Number&gt;, \\x&lt;Hexadecimal Number&gt;</i></p>",
        "<p><b>Example</b></p>",
        "<pre><code language=\"C++\">void fn ( )",
        "{",
        "   const char_t a[ 2 ] = \"\\k\";   // Non-compliant",
        "   const char_t b[ 2 ] = \"\\b\";   // Compliant",
        "}</code></pre>",
        "<p><b>See also</b></p>",
        "<p>Rule 2–13–2</p>"
      ]
    }
  },

  "MISRA08_4-5-3": {
    "tags": ["Language: C", "Language: C++", "Standard: MISRA C++ 2008", "Category: Required", "Expressions"],
    "key": "sti.CharOperators",
    "name": "Published Standards/MISRA-C++ 2008/4-5-3 Character Operators",
    "test": "CPP_E016",
    "desc": {
      "text": "",
      "html": [
        "<p>Expressions with type (plain) <i>char</i> and <i>wchar_t</i> shall not be used as operands to built-in operators other than the assignment operator <i>=</i>, the equality operators <code>==</code> and <code>!=</code>, and the unary <code>&</code> operator.</p>",
        "<p><b>Rationale</b></p>",
        "<p>Manipulation of character data may generate results that are contrary to developer expectations. For example, ISO/IEC 14882:2003 [1] §2.2(3) only requires that the digits \"0\" to \"9\" have consecutive numerical values.</p>",
        "<p><b>Exception</b></p>",
        "<p>Exceptionally, the following operators may be used if the associated restriction is observed:</p>",
        "<ul>",
        "<li>",
        "The binary <code>+</code> operator may be used to add an integral value in the",
        "range 0 to 9 to '0';",
        "</li>",
        "<li>",
        "The binary <code>-</code> operator may be used to subtract character '0';",
        "</li>",
        "<li>",
        "The relational operators <code>&lt;</code>, <code>&lt;=</code>,",
        "<code>&gt;</code>, <code>&gt;=</code> may be used to determine if a character",
        "(or wide character) represents a digit.",
        "</li>",
        "</ul>",
        "<p><b>Example</b></p>",
        "<pre>",
        "char_t ch = 't';                      // Compliant",
        "uint8_t v;",
        "if ( ( ch &gt;= 'a' ) && ( ch &lt;= 'z' ) ) // Non-compliant",
        "{",
        "}",
        "if ( ( ch &gt;= '0' ) && ( ch &lt;= '9' ) ) // Compliant by exception",
        "{",
        "   v = ch - '0';                      // Compliant by exception",
        "   v = ch - '1';                      // Non-compliant",
        "}",
        "else",
        "{",
        "   // ...",
        "}",
        "ch = '0' + v;                         // Compliant by exception",
        "ch = 'A' + v;                         // Non-compliant",
        "</pre>",
        "<p><b>Developer's Notes</b></p>",
        "<p>Other operators are allowed which are not generally thought of as operators. This includes but is not limited to</p>",
        "<ul>",
        "<li>Scope resolution <code>::</code></li>",
        "<li>C-style cast <code>(type)</code></li>",
        "<li>Size-of <code>sizeof</code></li>",
        "<li>Alignment requirement <code>_Alignof</code></li>",
        "<li>Ternary conditional <code>?:</code></li>",
        "</ul>"
      ]
    }
  },

  "MISRA08_5-2-9": {
    "tags": ["Language: C", "Language: C++", "Standard: MISRA C++ 2008", "Category: Advisory", "Pointers"],
    "key": "sti.PointerToIntCast",
    "name": "Published Standards/MISRA-C++ 2008/5-2-9 Pointer to Integer Cast",
    "desc": {
      "html": [
        "<p><b>Rationale</b></p>",
        "<p>The size of integer that is required when a pointer is converted to an integer is <i>implementation-defined</i>. Casting between a pointer and an integer type should be avoided where possible, but may be unavoidable when addressing memory mapped registers or other hardware specific features.</p>",
        "<p>Note that C++ does not permit a pointer to be converted to any floating type.</p>",
        "",
        "<p><b>Example</b></p>",
        "<pre><code language=\"C++\">struct S",
        "{",
        "   int32_t i;",
        "   int32_t j;",
        "};",
        "void f ( S * s )",
        "{",
        "   int32_t p = reinterpret_cast&lt; int32_t &gt;( s );   // Non-compliant",
        "}",
        "</code></pre>"
      ]
    }
  },

  "MISRA08_0-1-2": {
    "tags": ["Language: C", "Language: C++", "Standard: MISRA C++ 2008", "Category: Required", "Expressions"],
    "keys": ["tautological-bitwise-compare", "tautological-compare", "tautological-constant-compare", "tautological-constant-in-range-compare", "tautological-constant-out-of-range-compare", "tautological-objc-bool-compare", "tautological-overlap-compare", "tautological-pointer-compare", "tautological-type-limit-compare", "tautological-undefined-compare", "tautological-unsigned-char-zero-compare", "tautological-unsigned-enum-zero-compare", "tautological-unsigned-zero-compare", "tautological-value-range-compare"],
    "name": "Published Standards/MISRA-C++ 2008/0-1-2 Infeasible Paths",
    "test": "CPP_E032",
    "desc": {
      "html": [
        "<p>A <i>project</i> shall not contain <i>infeasible paths</i></p>",
        "<p><b>Rationale</b></p>",
        "<p><i>Infeasible paths</i> occur where there is a syntactic path but the semantics ensure that the control flow path cannot be executed by any input data. One of the major problems here is the explosion of <i>infeasible paths</i> caused by:</p>",
        "<ul>",
        "<li><i>if</i> ... <i>else</i> statement sequences;</li>",
        "<li>Sequences of poorly chosen loop constructs</li>",
        "</ul>",
        "<p>Errors in conditions and poorly designed logic contribute to this problem. It is always possible to rewrite the code to eliminate these constructs. This process may then reveal faults.</p>",
        "<p>There is the possibility that protective coding techniques generate infeasible code. This code is usually executable (and hence feasible) in a unit testing environment.</p>",
        "<p><b>Example</b></p>",
        "<pre>",
        "void infeas ( uint8_t para, uint8_t outp )",
        "{",
        "   // The condition below will always be true hence the path",
        "   // for the false condition is infeasible. Non-compliant.",
        "   if ( para &gt;= 0U )",
        "   {",
        "      outp = 1U;",
        "   }",
        "",
        "   // The following if statement combines with the if",
        "   // statement above to give four paths. One from",
        "   // the first condition is already infeasible and",
        "   // the condition below combined with assignment above",
        "   // makes the false branch infeasible. There is therefore",
        "   // only one feasible path through this code.",
        "   if ( outp == 1U )",
        "   {",
        "      outp = 0U;",
        "   }",
        "}",
        "",
        "enum ec { RED, BLUE, GREEN } col;",
        "",
        "if ( col &lt;= GREEN ) // Non-compliant - always true",
        "{",
        " // Will always get here",
        "}",
        "else",
        "{",
        " // Will never get here",
        "}",
        "",
        "// The following ifs exhibit similar behaviour.",
        "// Note that u16a is a 16-bit unsigned integer",
        "// and s8a is an 8-bit signed integer.",
        "",
        "if ( u16a &lt; 0U ) // Non-compliant - u16a is always &gt;= 0",
        "",
        "if ( u16a &lt;= 0xffffU ) // Non-compliant - always true",
        "",
        "if ( s8a &lt; 130 ) // Non-compliant - always true",
        "",
        "if ( ( s8a &lt; 10 ) && ( s8a &gt; 20 ) ) // Non-compliant - always false",
        "",
        "if ( ( s8a &lt; 10 ) || ( s8a &gt; 5 ) ) // Non-compliant - always true",
        "",
        "// Nested conditions can also cause problems",
        "if ( s8a &gt; 10 )",
        "{",
        "   if ( s8a &gt; 5 ) // Non-compliant, unless s8a volatile",
        "   {",
        "      // Will always get here.",
        "   }",
        "}",
        "</pre>",
        "<p><b>Developer's Notes</b></p>",
        "<p>This check does not find control-flow that is impossible to go to, such as sequences of poorly chosen loop constructs. It simply finds some expressions which are always true or always false.</p>",
        "<p>In the MISRA C++ 2008 example for rule 0-1-2, there are 2 non-compliant parts that this check misses. An enum can actually be outside of the enum range via casting, so this is not checked. The nested condition is also not checked.</p>"
      ]
    }
  },
  "MISRA08_0-1-3": {
    "tags": ["Language: C", "Language: C++", "Standard: MISRA C++ 2008", "Category: Required", "Variables"],
    "keys": ["unused-variable","unused-const-variable"],
    "name": "Published Standards/MISRA-C++ 2008/0-1-3 A project shall not contain unused variables",
    "test": "CPP_V007",
    "desc": {
      "text": "Check for variables that are unused (C, C++, ObjC)",
      "html": [
        "<p><b>Unused Variables (C, C++, ObjC)</b></p><p>",
        "Variables declared and never used in a project constitute noise and may ",
        "indicate that the wrong variable name has been used somewhere. Removing these",
        "declarations reduces the possibility that they may later be used instead of ",
        "the correct variable. If padding is used within bit-fields, then the padding",
        "member should be unnamed to avoid violation of this rule.</p>",
        "<p>Check ignores references inside inactive code (ie #if 0...#endif).</p>",
        "<b>Example</b><pre>",
          "extern void usefn ( int16_t a, int16_t b );",
          "class C ",
          "{ ",
          "   ... ",
          "};",
          "C c;                         // Non-compliant - unused",
          "void withunusedvar ( void ) ",
          "{ ",
          "   int16_t unusedvar;        // Non-compliant - unused",
          "   struct s_tag ",
          "   { ",
          "      signed int a   : 3; ",
          "      signed int pad : 1;    // Non-compliant - should be unnamed ",
          "      signed int b   : 2; ",
          "   } s_var;",
          "   s_var.a = 0; ",
          "   s_var.b = 0; ",
          "   usefn ( s_var.a, s_var.b ); ",
          "}</pre>"
      ]
    }
  },

  "MISRA08_0-1-7": {
    "tags": [ "Language: C", "Language: C++", "Standard: MISRA C++ 2008", "Category: Required", "Functions" ],
    "key": "sti.IgnoredReturnValues",
    "name": "Published Standards/MISRA-C++ 2008/0-1-7 The value returned by a function having a non-void return type that is not an overloaded operator shall always be used",
    "desc": {
      "html": [
        "<p><b>Rationale</b></p>",
        "<p>In C++ it is possible to call a function without using the return value, which may be an error. The return value of a function shall always be used. Overloaded operators are excluded, as they should behave in the same way as built-in operators.</p>",
        "<p><b>Exception</b></p>",
        "<p>The return value of a function may be discarded by use of a (void) cast.</p>",
        "<p><b>Example</b></p><pre> uint16_t func ( uint16_t para1 )",
        "  {",
        "     return para1;",
        "  }",
        "  void discarded ( uint16_t para2 )",
        "  {",
        "     func ( para2 );         // value discarded  Non-compliant",
        "     (void)func ( para2 );   // Compliant",
        "  }",
        "</pre>"
      ]
    }
  },

  "MISRA04_13.3": {
    "tags": ["Language: C", "Standard: MISRA C 2004", "Category: Required", "Expressions"],
    "keys": ["float-equal","sti.FloatingEqualityTest"],
    "name": "Published Standards/MISRA-C 2004/13.3 Floating-point expressions shall not be tested for equality or inequality",
    "desc": {
      "text": "Floating Equality Test",
      "html": [
        "<p>Floating-point expressions shall not be directly or indirectly tested for",
        "equality or inequality</p>",
        "<p><b>Rationale</b></p><p>",
        "The inherent nature of floating-point types is such that comparisons of equality",
        "will often not evaluate to true, even when they are expected to. Also, the",
        "behavior of such a comparison cannot be predicted before execution, and may",
        "well vary from one implementation to another.</p>",
        "<p>The recommended method for achieving deterministic floating-point comparisons",
        "is to write a library that implements the comparison operations. The library",
        "should take into account the floating-point granularity",
        "(<code>std::numeric_limits<float>::epsilon()</code>) and the magnitude of the",
        "numbers being compared.</p>",
        "<p><b>Example</b></p>",
        "<pre><code language=\"C++\">// The result of the test in the following code is unpredictable:",
        "float32_t x, y;",
        "if ( x == y )     // Non-compliant",
        "if ( x == 0.0f )  // Non-compliant",
        "// An indirect test is equally problematic and is also prohibited by this rule:",
        "if ( ( x &lt;= y ) && ( x &gt;= y ) )   // Non-compliant",
        "if ( ( x &lt; y ) || ( x &gt; y ) )     // Non-compliant",
        "// The following is better, but only if the magnitudes are appropriate:",
        "if ( fabs ( x - y ) &lt;= std::numeric_limits&lt;float&gt;::epsilon( ) ) //Compliant",
        "</code></pre>"
      ]
    }
  },
  "MISRA08_6-2-2": {
    "tags": ["Language: C", "Language: C++", "Standard: MISRA C++ 2008", "Category: Required", "Expressions"],
    "keys": ["float-equal","sti.FloatingEqualityTest"],
    "name": "Published Standards/MISRA-C++ 2008/6-2-2 Floating-point expressions shall not be directly or indirectly tested for equality or inequality",
    "desc": {
      "text": "Floating Equality Test",
      "html": [
        "<p>Floating-point expressions shall not be directly or indirectly tested for",
        "equality or inequality</p>",
        "<p><b>Rationale</b></p><p>",
        "The inherent nature of floating-point types is such that comparisons of equality",
        "will often not evaluate to true, even when they are expected to. Also, the",
        "behavior of such a comparison cannot be predicted before execution, and may",
        "well vary from one implementation to another.</p>",
        "<p>The recommended method for achieving deterministic floating-point comparisons",
        "is to write a library that implements the comparison operations. The library",
        "should take into account the floating-point granularity",
        "(<code>std::numeric_limits<float>::epsilon()</code>) and the magnitude of the",
        "numbers being compared.</p>",
        "<p><b>Example</b></p><pre><code language=\"C++\">",
        "// The result of the test in the following code is unpredictable:",
        "float32_t x, y;",
        "if ( x == y )     // Non-compliant",
        "if ( x == 0.0f )  // Non-compliant",
        "// An indirect test is equally problematic and is also prohibited by this rule:",
        "if ( ( x &lt;= y ) && ( x &gt;= y ) )   // Non-compliant",
        "if ( ( x &lt; y ) || ( x &gt; y ) )     // Non-compliant",
        "// The following is better, but only if the magnitudes are appropriate:",
        "if ( fabs ( x - y ) &lt;= std::numeric_limits&lt;float&gt;::epsilon( ) ) //Compliant",
        "</code></pre>"
      ]
    }
  },

  "MISRA08_15-3-6": {
    "tags": ["Language: C", "Language: C++", "Standard: MISRA C++ 2008", "Category: Required", "Exception Handling"],
    "key": "exceptions",
    "name": "Published Standards/MISRA-C++ 2008/15-3-6 Order of Catch Blocks with Derived Classes",
    "test": "CPP_E006",
    "desc": {
      "html": [
        "<p>Where multiple handlers are provided in a single <i>try-catch</i> statement or <i>function-try-block</i> for a derived class and some or all of its bases, the handlers shall be ordered most-derived to base class</p>",
        "<p><b>Rationale</b></p>",
        "<p>When testing to see if the type of an exception matches the type of a handler, a derived class exception will match with a handler for its base class. If the base class handler is found before the handler for the derived class, the base class handler will be used. The derived class handler is <i>unreachable code</i> and can never be executed.</p>",
        "<p><b>Example</b></p>",
        "<pre>",
        "1  // classes used for exception handling",
        "2  class B {};",
        "3  class D: public B {};",
        "4  try",
        "5  {",
        "6    //...",
        "7  }",
        "8  catch ( D &d ) // Compliant - Derived class caught before base class",
        "9  {",
        "10   //...",
        "11 }",
        "12 catch ( B &b ) // Compliant - Base class caught after derived class",
        "13 {",
        "14   //...",
        "15 }",
        "16 // Using the classes from above",
        "17 try",
        "18 {",
        "19   //...",
        "20 }",
        "21 catch ( B &b )",
        "22 {",
        "23   //...",
        "24 }",
        "25 catch ( D &d ) // Non-compliant - Derived class will be caught above",
        "26 {",
        "27   // Any code here will be unreachable,",
        "28   // breaking rule 0-1-1",
        "29 }",
        "</pre>"
      ]
    }
  },

  "MISRA04_16.8": {
    "tags": ["Language: C", "Standard: MISRA C 2004", "Category: Required", "Functions"],
    "key": "return-type",
    "name": "Published Standards/MISRA-C 2004/16.8 Always return a value in non-void functions",
    "test": "A8-4-2",
    "desc": {
      "html": [
        "<p>Always return a value in non-void functions.</p>",
        "<p>This expression gives the value that the function returns. The absence of a <i>return</i> with an expression leads to undefined behaviour (and the compiler may not give an error).</p>",
        "<p><b>Developer's Notes</b></p>",
        "<p>This check utilizes the clang warning -Wreturn-type and this warning can occasionally produce false positives when analyzing complex control flows, such as Microsoft’s Structured Exception Handling (__try/__except) blocks, as Clang may conservatively assume an unhandled exception could bypass a return statement, even when all paths are covered.</p>"
      ]
    }
  },
  "MISRA08_8-4-3": {
    "tags": ["Language: C", "Language: C++", "Standard: MISRA C++ 2008", "Category: Required", "Functions"],
    "key": "return-type",
    "name": "Published Standards/MISRA-C++ 2008/8-4-3 Always return a value in non-void functions",
    "test": "A8-4-2",
    "desc": {
      "html": [
        "<p>Always return a value in non-void functions.</p>",
        "<p><b>Rationale</b></p>",
        "<p>This expression gives the value that the function returns. The absence of a <i>return</i> with an expression leads to <i>undefined behaviour</i> (and the compiler may not give an error).</p>",
        "<p><b>Exception</b></p>",
        "<p>This rule does not apply if a function exit is due to exception handling (i.e. a <i>throw</i> statement).</p>",
        "<p><b>Example</b></p>",
        "<pre>",
        "int32_t fn1 ( void )",
        "{",
        "} // Non-compliant",
        "int32_t fn3 ( int32_t x )",
        "{",
        "    if ( x &gt; 100 )",
        "    {",
        "        throw 42; // Compliant by exception",
        "    }",
        "    return ( x ); // Compliant",
        "}",
        "</pre>",
        "<p><b>Developer's Notes</b></p>",
        "<p>This check utilizes the clang warning -Wreturn-type and this warning can occasionally produce false positives when analyzing complex control flows, such as Microsoft’s Structured Exception Handling (__try/__except) blocks, as Clang may conservatively assume an unhandled exception could bypass a return statement, even when all paths are covered.</p>"
      ]
    }
  },
  "MISRA12_2.6": {
    "tags": ["Language: C", "Standard: MISRA C 2012", "Category: Required", "Unnecessary Constructs"],
    "key": "unused-label",
    "name": "Published Standards/MISRA C 2012/2.6 Unused Labels",
    "test": "CPP_U007",
    "desc": {
      "html": [
        "<p>A function should not contain unused label declarations</p>",
        "<p><b>Rationale</b></p>",
        "<p>If a label is declared but not used, then it is unclear to a reviewer if the label is redundant or it has been left unused by mistake.</p>",
        "<p><b>Example</b></p>",
        "<pre>",
        "void unused_label ( void )",
        "{",
        "  int16_t x = 6;",
        "label1:              /* Non-compliant */",
        "  use_int16 ( x );",
        "}",
        "</pre>"
      ]
    }
  },
  "MISRA12_8.1": {
    "tags": ["Language: C", "Standard: MISRA C 2012", "Category: Required", "Types"],
    "key": "implicit-int",
    "name": "Published Standards/MISRA C 2012/8.1 Types shall be explicitly specified",
    "test": "CPP_T050",
    "desc": {
      "html": [
        "<p>Types shall be explicitly specified</p>",
        "<p><b>Rationale</b></p>",
        "The C90 standard permits types to be omitted in some circumstances, in which case the <i>int</i> type is implicitly specified. Examples of the circumstances in which an implicit <i>int</i> might be used are:",
        "<ul>",
        "<li>Object declarations;</li>",
        "<li>Parameter declarations;</li>",
        "<li>Member declarations;</li>",
        "<li><i>typedef</i> declarations;</li>",
        "<li>Function return types.</li>",
        "</ul>",
        "<p>The omission of an explicit type might lead to confusion. For example, in the declaration:</p>",
        "<pre>",
        "extern void g ( char c, const k );",
        "</pre>",
        "the type of <code>k</code> is <i>const int</i> whereas <i>const char</i> might have been expected.",
        "<p><b>Example</b></p>",
        "<p>The following examples show compliant and non-compliant object declarations:</p>",
        "<pre>",
        "extern         x; /* Non-compliant - implicit int type */",
        "extern int16_t x; /* Compliant - explicit type */",
        "const          y; /* Non-compliant - implicit int type */",
        "const int16_t  y; /* Compliant - explicit type */",
        "</pre>",
        "<p>The following examples show compliant and non-compliant function type declarations:</p>",
        "<pre>",
        "extern f ( void );                         /* Non-compliant - implicit",
        "                                            * int return type */",
        "extern int16_t f ( void );                 /* Compliant */",
        "",
        "extern void g ( char c, const k );         /* Non-compliant - implicit",
        "                                            * int for parameter k */",
        "extern void g ( char c, const int16_t k ); /* Compliant */",
        "</pre>",
        "<p>The following examples show compliant and non-compliant type definitions:</p>",
        "<pre>",
        "typedef ( *pfi ) ( void );           /* Non-compliant - implicit int",
        "                                      * return type */",
        "typedef int16_t ( *pfi ) ( void );   /* Compliant */",
        "typedef void ( *pfv ) ( const x );   /* Non-compliant - implicit int",
        "                                      * for parameter x */",
        "typedef void ( *pfv ) ( int16_t x ); /* Compliant */",
        "</pre>",
        "<p>The following examples show compliant and non-compliant member declarations:</p>",
        "<pre>",
        "struct str",
        "{",
        "  int16_t x; /* Compliant */",
        "  const   y; /* Non-compliant - implicit int for member y */",
        "} s;",
        "</pre>",
        "<p><b>See also</b></p>",
        "<p>Rule 8.2</p>"
      ]
    }
  },

  "MISRA12_8.2": {
    "tags": ["Language: C", "Language: C++", "Standard: MISRA C 2012", "Functions"],
    "keys": ["strict-prototypes", "deprecated-non-prototype", "implicit-int", "sti.UnnamedParameters"],
    "name": "Published Standards/MISRA C 2012/8.2 Use Named Parameters and Prototype Form",
    "test": "CPP_F009",
    "desc": {
      "html": [
        "<p><b>Title</b></p>",
        "<p>Function types shall be in <i>prototype form</i> with named parameters.</p>",
        "<p><b>Rationale</b></p>",
        "<p>The early version of C, commonly referred to as K&R C [30], did not provide a mechanism for checking the number of arguments or their types against the corresponding parameters. The type of an object or function did not have to be declared in K&R C since the default type of an object and the default return type of a function was <i>int</i>.</p>",
        "<p>The C90 standard introduced function prototypes, a form of function declarator in which the parameter types were declared. This permitted argument types to be checked against parameter types. It also allowed the number of arguments to be checked except when a function prototype specified that a variable number of arguments was expected. The C90 standard did not <b>require</b> the use of function prototypes for reasons of backward compatibility with existing code. For the same reason, it continued to permit types to be omitted in which case the type would default to <i>int</i>.</p>",
        "<p>The C99 standard removed the default <i>int</i> type from the language but continued to allow K&R-style function types in which there was no means to supply parameter type information in a declaration and it was optional to supply parameter type information in a definition.</p>",
        "<p>The mismatch between the number of arguments and parameters, their types and the expected and actual return type of a function provides potential for undefined behaviour. The purpose of this rule along with Rule 8.1 and Rule 8.4 is to avoid this undefined behaviour by requiring parameter types and function return types to be specified explicitly. Rule 17.3 ensures that this information is available at the time of a function call, thereby requiring the compiler to diagnose any mismatch that is detected.</p>",
        "<p>This rule also requires that names be specified for all the parameters in a declaration. The parameter names can provide useful information regarding the function interface and a mismatch between a declaration and definition might be indicative of a programming error.</p>",
        "<p><i>Note</i>: An empty parameter list is <b>not</b> valid in a prototype. If a function type has no parameters its <i>prototype form</i> uses the keyword <i>void</i>.</p>",
        "<p><b>Example</b></p>",
        "<p>The first example shows declarations of some functions and the corresponding definitions for some of those functions.</p>",
        "<pre><code language=\"C++\">",
        "  /* Compliant                                                  */",
        "  extern int16_t func1 ( int16_t n );",
        "",
        "  /* Non-compliant - parameter name not specified               */",
        "  extern void func2 ( int16_t );",
        "",
        "  /* Non-compliant - not in prototype form                      */",
        "  static int16_t func3 ( );",
        "",
        "  /* Compliant - prototype specifies 0 parameters               */",
        "  static int16_t func4 ( void );",
        "",
        "  /* Compliant                                                  */",
        "  int16_t func1 ( int16_t n )",
        "  {",
        "    return n;",
        "  }",
        "",
        "  /* Non-compliant - old style identifier and declaration list  */",
        "  static int16_t func3 ( vec, n )",
        "  int16_t *vec;",
        "  int16_t n;",
        "  {",
        "    return vec[ n - 1 ];",
        "  }",
        "</code></pre>",
        "<p>This example section shows the application of the rule to function types other than in function declarations and definitions.</p>",
        "<pre><code language=\"C++\">",
        "  /* Non-compliant - no prototype                   */",
        "  int16_t ( *pf1 ) ( );",
        "",
        "  /* Compliant - prototype specifies 0 parameters   */",
        "  int16_t ( *pf1 ) ( void );",
        "",
        "  /* Non-compliant - parameter name not specified   */",
        "  typedef int16_t ( *pf2_t ) ( int16_t );",
        "",
        "  /* Compliant                                      */",
        "  typedef int16_t ( *pf3_t ) ( int16_t n );",
        "</code></pre>"
      ]
    }
  },

  "MISRA12_10.7": {
    "tags": ["Language: C", "Language: C++", "Standard: MISRA C 2012", "Category: Required", "Expressions", "Types"],
    "key": "sti.ImplicitCastOfOperation",
    "name": "Published Standards/MISRA C 2012/10.7 Implicit Casts of Operations",
    "test": "CPP_T063",
    "desc": {
      "html": [
        "<p><b>Title</b></p>",
        "<p>If a <i>composite expression</i> is used as one operand of an operator in which the <i>usual arithmetic conversions</i> are performed then the other operand shall not have wider <i>essential type</i>.</p>",
        "<p><b>Rationale</b></p>",
        "<p>The rationale is described in the introduction on <i>composite operators</i> and expressions (see Section 8.10.3). Restricting implicit conversions on composite expressions means that sequences of arithmetic operations within an expression must be conducted in exactly the same <i>essential type</i>. This reduces possible developer confusion.</p>",
        "<p><i>Note</i>: this does not imply that all operands in an expression are of the same essential type.</p>",
        "<p>The expression <code>u32a + u16b + u16c</code> is compliant as both additions will notionally be performed in type <code>uint32_t</code>. In this case only <i>non-composite expressions</i> are implicitly converted.</p>",
        "<p>The expression <code>(u16a + u16b) + u32c</code> is non-compliant as the left addition is notionally performed in type <code>uint16_t</code> and the right in type <code>uint32_t</code>, requiring an implicit conversion of the <i>composite expression</i> <code>u16a + u16b</code> to <code>uint32_t</code>.</p>",
        "<p><b>Example</b></p>",
        "<p>The following are compliant:</p>",
        "<pre><code language=\"C++\">  u32a * u16a + u16b                   /* No comp osite conversion */",
        "( u32a * u16a ) + u16b                 /* No composite conversion */",
        "  u32a * ( ( uint32_t ) u16a + u16b )  /* Both operands of * have",
        "                                        * same essential type */",
        "u32a += ( u32b + u16b )                /* No composite conversion */",
        "</code></pre>",
        "<p>The following are non-compliant:</p>",
        "<pre><code language=\"C++\">u32a  * ( u16a + u16b )  /* Implicit conversion of ( u16a + u16b ) */",
        "u32a += ( u16a + u16b )  /* Implicit conversion of ( u16a + u16b ) */",
        "</code></pre>",
        "<p><b>See also</b></p>",
        "<p>Rule 10.4, Rule 10.6, Section 8.10.3</p>"
      ]
    }
  },

  "MISRA12_16.7": {
    "tags": ["Language: C", "Language: C++", "Standard: MISRA C 2012", "Control Flow", "Types"],
    "key": "switch-bool",
    "name": "Published Standards/MISRA C 2012/16.7 Switch Boolean",
    "test": "CPP_CF000",
    "desc": {
      "html": [
        "<p><b>Title</b></p>",
        "<p>A <i>switch-expression</i> shall not have <i>essentially Boolean type</i></p>",
        "<p><b>Rationale</b></p>",
        "<p>The Standard requires the controlling expression of a <i>switch</i> statement to have an integer type. Since the type that is used to implement Boolean values is an integer, it is possible to have a <i>switch</i> statement controlled by a Boolean expression. In this instance an <i>if-else</i> construct would be more appropriate.</p>",
        "<p><b>Example</b></p>",
        "<pre><code language=\"C++\">switch ( x == 0 )  /* Non-compliant - essentially Boolean */",
        "{                  /* In this case an \"if-else\" would be more logical */",
        "  case false:",
        "    y = x;",
        "    break;",
        "  default:",
        "    y = z;",
        "    break;",
        "}</code></pre>"
      ]
    }
  },

  "MISRA12_17.4": {
    "tags": ["Language: C", "Standard: MISRA C 2012", "Category: Required", "Functions"],
    "key": "return-type",
    "name": "Published Standards/MISRA C 2012/17.4 Always return a value in non-void functions",
    "test": "A8-4-2",
    "desc": {
      "html": [
        "<p>Always return a value in non-void functions.</p>",
        "<p><b>Rationale</b></p>",
        "<p>",
        "The expression given to the <i>return</i> statement provides the value that the function returns. If a non-<i>void</i> function does not return a value but the calling function uses the returned value, the behaviour is undefined. This can be avoided by ensuring that, in a non-<i>void</i> function:",
        "</p>",
        "<p>",
        "• Every <i>return</i> statement has an expression, and",
        "</p>",
        "<p>",
        "• Control cannot reach the end of the function without encountering a <i>return</i> statement.",
        "</p>",
        "<p>",
        "<i>Note</i>: C99 constrains every <i>return</i> statement in a non-<i>void</i> function to return a value.",
        "</p>",
        "<p><b>Example</b></p>",
        "<pre>",
        "int32_t absolute ( int32_t v )",
        "{",
        "  if ( v &lt; 0 )",
        "  {",
        "    return v;",
        "  }",
        "  /*",
        "   * Non-compliant - control can reach this point without",
        "   * returning a value",
        "   */",
        "}",
        "uint16_t lookup ( uint16_t v )",
        "{",
        "  if ( ( v &lt; V_MIN ) || ( v &gt; V_MAX ) )",
        "  {",
        "    /* Non-compliant - no value returned. Constraint in C99 */",
        "    return;",
        "  }",
        "  return table[ v ];",
        "}",
        "</pre>",
        "<p><b>See also</b></p>",
        "<p>",
        "Rule 15.5",
        "</p>",
        "<p><b>Developer's Notes</b></p>",
        "<p>This check utilizes the clang warning -Wreturn-type and this warning can occasionally produce false positives when analyzing complex control flows, such as Microsoft’s Structured Exception Handling (__try/__except) blocks, as Clang may conservatively assume an unhandled exception could bypass a return statement, even when all paths are covered.</p>"
      ]
    }
  },

  "MISRA12_17.7": {
    "tags": [ "Language: C", "Standard: MISRA C 2012", "Category: Required", "Functions" ],
    "key": "sti.IgnoredReturnValues",
    "name": "Published Standards/MISRA C 2012/17.7 The value returned by a function having non-void return type shall be used",
    "test": "A0-1-2",
    "desc": {
      "html": [
        "<p><b>Rationale</b></p>",
        "<p><p>It is possible to call a function without using the return value, which may be an error. If the return value of a function is intended not to be used explicitly, it should be cast to the void type. This has the effect of using the value without violating Rule 2.2.</p></p>",
        "<p><b>Example</b></p>",
        "",
        "<pre> uint16_t func ( uin t16_t para1 )",
        "  {",
        "    return para1;",
        "  }",
        "",
        "  uint16_t x;",
        "  void discarded ( uint16_t para2 )",
        "  {",
        "    func ( para2 ); /* Non-compliant - value discarded */",
        "    ( void ) func ( para2 ); /* Compliant */",
        "    x = func ( para2 ); /* Compliant */",
        "  }",
        "",
        "</pre>",
        "",
        "<p><b>See also</b></p>",
        "<p>Dir 4.7, Rule 2.2</p>"
      ]
    }
  },

  "MISRA23_2.6": {
    "tags": ["Language: C", "Standard: MISRA C 2023", "Category: Required", "Unnecessary Constructs"],
    "key": "unused-label",
    "name": "Published Standards/MISRA C 2023/2.6  A function should not contain unused label declarations",
    "desc": {
      "html": [
        "<p>A function should not contain unused label declarations</p>",
        "<p><b>Rationale</b></p>",
        "<p>If a label is declared but not used, then it is unclear to a reviewer if the label is redundant or it has been left unused by mistake.</p>",
        "<p><b>Example</b></p>",
        "<pre>",
        "void unused_label ( void )",
        "{",
        "  int16_t x = 6;",
        "label1:              /* Non-compliant */",
        "  use_int16 ( x );",
        "}",
        "</pre>"
      ]
    }
  },

  "MISRA23_2.8": {
    "tags": ["Language: C", "Language: C++", "Standard: MISRA C 2023", "Category: Advisory", "Variables"],
    "keys": ["unused-variable", "unused-const-variable"],
    "name": "Published Standards/MISRA C 2023/2.8 Unused Objects",
    "test": "CPP_V007",
    "desc": {
      "html": [
        "<p><b>Title</b></p>",
        "<p>A project should not contain unused object definitions.</p>",
        "<p><b>Amplification</b></p>",
        "<p>An object is unused if the definition (and any declarations) can be removed, and the program still compiles.</p>",
        "<p><b>Rationale</b></p>",
        "<p>If an object is defined but unused, then it is unclear to a reviewer if the object is redundant or it has been left unused by mistake.</p>",
        "<p><b>See also</b></p>",
        "<p>Rule 8.6</p>"
      ]
    }
  },

  "MISRA23_8.1": {
    "tags": ["Language: C", "Standard: MISRA C 2023", "Category: Required", "Types"],
    "key": "implicit-int",
    "name": "Published Standards/MISRA C 2023/8.1 Types shall be explicitly specified",
    "test": "CPP_T050",
    "desc": {
      "html": [
        "<p>Types shall be explicitly specified</p>",
        "<p><b>Rationale</b></p>",
        "The C90 standard permits types to be omitted in some circumstances, in which case the <i>int</i> type is implicitly specified. Examples of the circumstances in which an implicit <i>int</i> might be used are:",
        "<ul>",
        "<li>Object declarations;</li>",
        "<li>Parameter declarations;</li>",
        "<li>Member declarations;</li>",
        "<li><i>typedef</i> declarations;</li>",
        "<li>Function return types.</li>",
        "</ul>",
        "<p>The omission of an explicit type might lead to confusion. For example, in the declaration:</p>",
        "<pre>",
        "extern void g ( char c, const k );",
        "</pre>",
        "the type of <code>k</code> is <i>const int</i> whereas <i>const char</i> might have been expected.",
        "<p><b>Example</b></p>",
        "<p>The following examples show compliant and non-compliant object declarations:</p>",
        "<pre>",
        "extern         x; /* Non-compliant - implicit int type */",
        "extern int16_t x; /* Compliant - explicit type */",
        "const          y; /* Non-compliant - implicit int type */",
        "const int16_t  y; /* Compliant - explicit type */",
        "</pre>",
        "<p>The following examples show compliant and non-compliant function type declarations:</p>",
        "<pre>",
        "extern f ( void );                         /* Non-compliant - implicit",
        "                                            * int return type */",
        "extern int16_t f ( void );                 /* Compliant */",
        "",
        "extern void g ( char c, const k );         /* Non-compliant - implicit",
        "                                            * int for parameter k */",
        "extern void g ( char c, const int16_t k ); /* Compliant */",
        "</pre>",
        "<p>The following examples show compliant and non-compliant type definitions:</p>",
        "<pre>",
        "typedef ( *pfi ) ( void );           /* Non-compliant - implicit int",
        "                                      * return type */",
        "typedef int16_t ( *pfi ) ( void );   /* Compliant */",
        "typedef void ( *pfv ) ( const x );   /* Non-compliant - implicit int",
        "                                      * for parameter x */",
        "typedef void ( *pfv ) ( int16_t x ); /* Compliant */",
        "</pre>",
        "<p>The following examples show compliant and non-compliant member declarations:</p>",
        "<pre>",
        "struct str",
        "{",
        "  int16_t x; /* Compliant */",
        "  const   y; /* Non-compliant - implicit int for member y */",
        "} s;",
        "</pre>",
        "<p><b>See also</b></p>",
        "<p>Rule 8.2</p>"
      ]
    }
  },

  "MISRA23_10.7": {
    "tags": ["Language: C", "Language: C++", "Standard: MISRA C 2023", "Category: Required", "Expressions", "Types"],
    "key": "sti.ImplicitCastOfOperation",
    "name": "Published Standards/MISRA C 2023/10.7 Implicit Casts of Operations",
    "test": "CPP_T063",
    "desc": {
      "html": [
        "<p><b>Title</b></p>",
        "<p>If a <i>composite expression</i> is used as one operand of an operator in which the <i>usual arithmetic conversions</i> are performed then the other operand shall not have wider <i>essential type</i>.</p>",
        "<p><b>Rationale</b></p>",
        "<p>The rationale is described in the introduction on <i>composite operators</i> and expressions (see Section 8.10.3). Restricting implicit conversions on composite expressions means that sequences of arithmetic operations within an expression must be conducted in exactly the same <i>essential type</i>. This reduces possible developer confusion.</p>",
        "<p><i>Note</i>: this does not imply that all operands in an expression are of the same essential type.</p>",
        "<p>The expression <code>u32a + u16b + u16c</code> is compliant as both additions will notionally be performed in type <code>uint32_t</code>. In this case only <i>non-composite expressions</i> are implicitly converted.</p>",
        "<p>The expression <code>(u16a + u16b) + u32c</code> is non-compliant as the left addition is notionally performed in type <code>uint16_t</code> and the right in type <code>uint32_t</code>, requiring an implicit conversion of the <i>composite expression</i> <code>u16a + u16b</code> to <code>uint32_t</code>.</p>",
        "<p><b>Example</b></p>",
        "<p>The following are compliant:</p>",
        "<pre><code language=\"C++\">  u32a * u16a + u16b                   /* No comp osite conversion */",
        "( u32a * u16a ) + u16b                 /* No composite conversion */",
        "  u32a * ( ( uint32_t ) u16a + u16b )  /* Both operands of * have",
        "                                        * same essential type */",
        "u32a += ( u32b + u16b )                /* No composite conversion */",
        "</code></pre>",
        "<p>The following are non-compliant:</p>",
        "<pre><code language=\"C++\">u32a  * ( u16a + u16b )  /* Implicit conversion of ( u16a + u16b ) */",
        "u32a += ( u16a + u16b )  /* Implicit conversion of ( u16a + u16b ) */",
        "</code></pre>",
        "<p><b>See also</b></p>",
        "<p>Rule 10.4, Rule 10.6, Section 8.10.3</p>"
      ]
    }
  },

  "MISRA23_12.5": {
    "tags": ["Language: C", "Language: C++", "Standard: MISRA C 2023", "Category: Mandatory", "Pointers"],
    "key": "sizeof-array-argument",
    "name": "Published Standards/MISRA C 2023/17.4 Size of Array Parameter",
    "test": "CPP_P016",
    "desc": {
      "html": [
        "<p><b>Title</b></p>",
        "<p>The <i>sizeof</i> operator shall not have an operand which is a function parameter declared as \"array of type\"</p>",
        "<p><b>Amplification</b></p>",
        "<p>The function parameter <code>A</code> in <code>void f ( int32_t A[ 4 ] )</code> is declared as \"array of type\".</p>",
        "<p><b>Rationale</b></p>",
        "<p>The <i>sizeof</i> operator can be used to determine the number of elements in an array <code>A</code>:</p>",
        "<pre><code language=\"C++\">size_t arraySize = sizeof ( A ) / sizeof ( A[ 0 ] );</code></pre>",
        "<p>\"This works as expected when A is an identifier that designates an array, as it has type \"array of type\". It does not \"degenerate\" to a pointer and <code>sizeof ( A )</code> returns the size of the array.\"</p>",
        "<p>However, this is not the case when A is a function parameter. The C Standard states that a function parameter never has type \"array of type\" and a function parameter declared as an array will \"degenerate\" to \"pointer to type\". This means that <code>sizeof ( A )</code> is equivalent to",
        "<code>sizeof ( int32_t * )</code>, which does not return the size of an array.</p>",
        "<p><b>Example</b></p>",
        "<pre><code language=\"C++\">int32_t glbA[] = { 1, 2, 3, 4, 5 };",
        "void f ( int32_t A[ 4 ] )",
        "{",
          "/*",
          "* The following is non-compliant as it always gives the same answer,",
          "* irrespective of the number of members that appear to be in the array",
          "* (4 in this case), because A has type int32_t * and not int32_t[ 4 ].",
          "* As sizeof ( int32_t * ) is often the same as sizeof ( int32_t ),",
          "* numElements is likely to always have the value 1.",
          "*/",
          "uint32_t numElements = sizeof ( A ) / sizeof ( int32_t ); // UndCC_Violation",
          "/*",
          "* The following is compliant as numElements_glbA will be given the",
          "* expected value of 5.",
          "*/",
          "uint32_t numElements_glbA = sizeof ( glbA ) / sizeof ( glbA[ 0 ] );",
        "}</code></pre>"
      ]
    }
  },

  "MISRA23_16.7": {
    "tags": ["Language: C", "Language: C++", "Standard: MISRA C 2023", "Control Flow", "Types"],
    "key": "switch-bool",
    "name": "Published Standards/MISRA C 2023/16.7 Switch Boolean",
    "test": "CPP_CF000",
    "desc": {
      "html": [
        "<p><b>Title</b></p>",
        "<p>A <i>switch-expression</i> shall not have <i>essentially Boolean type</i></p>",
        "<p><b>Rationale</b></p>",
        "<p>The Standard requires the controlling expression of a <i>switch</i> statement to have an integer type. Since the type that is used to implement Boolean values is an integer, it is possible to have a <i>switch</i> statement controlled by a Boolean expression. In this instance an <i>if-else</i> construct would be more appropriate.</p>",
        "<p><b>Example</b></p>",
        "<pre><code language=\"C++\">switch ( x == 0 )  /* Non-compliant - essentially Boolean */",
        "{                  /* In this case an \"if-else\" would be more logical */",
        "  case false:",
        "    y = x;",
        "    break;",
        "  default:",
        "    y = z;",
        "    break;",
        "}</code></pre>"
      ]
    }
  },

  "MISRA23_17.4": {
    "tags": ["Language: C", "Standard: MISRA C 2023", "Category: Required", "Functions"],
    "key": "return-type",
    "name": "Published Standards/MISRA C 2023/17.4 All exit paths from a function with non-void return type shall have an explicit return statement with an expression",
    "test": "A8-4-2",
    "desc": {
      "html": [
        "<p>All exit paths from a function with non-void return type shall have an explicit return statement with an expression.</p>",
        "<p><b>Rationale</b></p>",
        "<p>",
        "The expression given to the <i>return</i> statement provides the value that the function returns. If a non-<i>void</i> function does not return a value but the calling function uses the returned value, the behaviour is undefined. This can be avoided by ensuring that, in a non-<i>void</i> function:",
        "</p>",
        "<p>",
        "• Every <i>return</i> statement has an expression, and",
        "</p>",
        "<p>",
        "• Control cannot reach the end of the function without encountering a <i>return</i> statement.",
        "</p>",
        "<p>",
        "<i>Note</i>: C99 and later constrain every <i>return</i> statement in a non-<i>void</i> function to return a value.",
        "</p>",
        "<p><b>Exception</b></p>",
        "<p>",
        "For C99 and later, the C Standard specifies that if control reaches the end of main without encountering a return statement, the effect is that of executing return 0. Therefore, for C99 and later, the return statement may be omitted for function main.",
        "</p>",
        "<p><b>Example</b></p>",
        "<pre>",
        "int32_t absolute ( int32_t v )",
        "{",
        "  if ( v &lt; 0 )",
        "  {",
        "    return v;",
        "  }",
        "  /*",
        "   * Non-compliant - control can reach this point without",
        "   * returning a value",
        "   */",
        "}",
        "uint16_t lookup ( uint16_t v )",
        "{",
        "  if ( ( v &lt; V_MIN ) || ( v &gt; V_MAX ) )",
        "  {",
        "    /* Non-compliant - no value returned. Constraint in C99 */",
        "    return;",
        "  }",
        "  return table[ v ];",
        "}",
        "</pre>",
        "<p><b>See also</b></p>",
        "<p>",
        "Rule 15.5",
        "</p>",
        "<p><b>Developer's Notes</b></p>",
        "<p>This check utilizes the clang warning -Wreturn-type and this warning can occasionally produce false positives when analyzing complex control flows, such as Microsoft’s Structured Exception Handling (__try/__except) blocks, as Clang may conservatively assume an unhandled exception could bypass a return statement, even when all paths are covered.</p>"
      ]
    }
  },

  "MISRA23_17.7": {
    "tags": [ "Language: C", "Standard: MISRA C 2023", "Category: Required", "Functions" ],
    "key": "sti.IgnoredReturnValues",
    "name": "Published Standards/MISRA C 2023/17.7 The value returned by a function having non-void return type shall be used",
    "test": "A0-1-2",
    "desc": {
      "html": [
        "<p><b>Rationale</b></p>",
        "<p><p>It is possible to call a function without using the return value, which may be an error. If the return value of a function is intended not to be used explicitly, it should be cast to the void type. This has the effect of using the value without violating Rule 2.2.</p></p>",
        "<p><b>Example</b></p>",
        "",
        "<pre> uint16_t func ( uin t16_t para1 )",
        "  {",
        "    return para1;",
        "  }",
        "",
        "  uint16_t x;",
        "  void discarded ( uint16_t para2 )",
        "  {",
        "    func ( para2 ); /* Non-compliant - value discarded */",
        "    ( void ) func ( para2 ); /* Compliant */",
        "    x = func ( para2 ); /* Compliant */",
        "  }",
        "",
        "</pre>",
        "",
        "<p><b>See also</b></p>",
        "<p>Dir 4.7, Rule 2.2</p>"
      ]
    }
  },

  "MISRA23_17.9": {
    "tags": ["Language: C", "Language: C++", "Standard: MISRA C 2023", "Category: Mandatory", "Functions"],
    "key": "invalid-noreturn",
    "name": "Published Standards/MISRA C 2023/17.9 Invalid _Noreturn",
    "test": "CPP_F067",
    "desc": {
      "html": [
        "<p><b>Title</b></p>",
        "<p>A function declared with a <i>_Noreturn</i> function specifier shall not return to its caller</p>",
        "<p><b>Rationale</b></p>",
        "<p>By definition, use of the <i>_Noreturn</i> function specifier indicates unambiguously that a function is not expected to return to its caller, by any path.</p>",
        "<p>Returning from such a function is indicative of an error in the program's control flow, resulting in undefined behaviour.</p>",
        "<p><b>Example</b></p>",
        "<pre><code language=\"C++\">_Noreturn void a ( void )",
        "{",
        "  return; /* Non-compliant - breaks _Noreturn contract */",
        "}",
        "",
        "_Noreturn void b ( void )",
        "{",
        "  while ( true ) /* Permitted by Rule 14.3 Exception 1 */",
        "  {",
        "    ...",
        "  }",
        "  /* Compliant - function can never return */",
        "}",
        "",
        "_Noreturn void c ( void )",
        "{",
        "  abort(); /* Compliant - no return from abort() */",
        "}",
        "",
        "_Noreturn void d ( int32_t i )",
        "{",
        "  if ( i > 0 )",
        "  {",
        "    abort();",
        "  }",
        "",
        "  /* Non-compliant - returns if i <= 0 */",
        "}</code></pre>",
        "<p><b>See also</b></p>",
        "<p>Rule 17.11</p>"
      ]
    }
  },

  "MISRA23_21.15": {
    "tags": ["Language: C", "Language: C++", "Standard: MISRA C 2023", "Category: Required", "Libraries", "Pointers", "Types"],
    "key": "sti.IncompatiblePointers",
    "name": "Published Standards/MISRA C 2023/21.15 Incompatible Pointers",
    "test": "CPP_L037",
    "desc": {
      "html": [
        "<p><b>Title</b></p>",
        "<p>The pointer arguments to the Standard Library functions <i>memcpy</i>, <i>memmove</i> and <i>memcmp</i> shall be pointers to qualified or unqualified versions of compatible types.</p>",
        "<p><b>Rationale</b></p>",
        "<p>The Standard Library functions</p>",
        "<pre><code language=\"C++\">void * memcpy  ( void * restrict s1, const void * restrict s2, size_t n );",
        "void * memmove ( void *s1, const void *s2, size_t n );",
        " int   memcmp  ( const void *s1, const void *s2, size_t n );</code></pre>",
        "<p>perform a byte by byte copy, move or comparison of the first <code>n</code> bytes of the two objects pointed at by <code>s1</code> and <code>s2</code>.</p>",
        "<p>An attempt to call one of these functions with arguments which are pointers to different types may indicate a mistake.</p>",
        "<p><b>Example</b></p>",
        "<pre><code language=\"C++\">/*",
        " * Is it intentional to only copy part of 's2'?",
        " */",
        "void f ( uint8_t s1[ 8 ], uint16_t s2[ 8 ] )",
        "{",
        "  ( void ) memcpy ( s1, s2, 8 );    /* Non-compliant */",
        "}</code></pre>",
        "<p><b>See also</b></p>",
        "<p>Rule 21.14, Rule 21.16</p>"
      ]
    }
  },

  "MISRA23_21.16": {
    "tags": ["Language: C", "Language: C++", "Structures and Unions", "Types"],
    "key": "sti.InvalidMemoryCompare",
    "name": "Published Standards/MISRA C 2023/21.16 Invalid Memory Compare",
    "test": "CPP_S005",
    "desc": {
      "html": [
        "<p><b>Title</b></p>",
        "<p>The pointer arguments to the Standard Library function <i>memcmp</i> shall point to either a pointer type, an <i>essentially signed</i> type, an <i>essentially unsigned</i> type, an <i>essentially Boolean</i> type or an <i>essentially</i> enum type.</p>",
        "<p><b>Rationale</b></p>",
        "<p>The Standard Library function</p>",
        "<pre><code language=\"C++\">int memcmp ( const void *s1, const void *s2, size_t n );</code></pre>",
        "<p>performs a byte by byte comparison of the first <code>n</code> bytes of the two objects pointed at by <code>s1</code> and <code>s2</code>.</p>",
        "<p>Structures shall not be compared using <i>memcmp</i> as it may incorrectly indicate that two structures are not equal, even when their members hold the same values. Structures may contain padding with an indeterminate value between their members and <i>memcmp</i> will include this in its comparison. It cannot be assumed that the padding will be equal, even when the values of the structure members are the same. Unions have similar concerns along with the added complication that they may incorrectly be reported as having the same value when the representation of different, overlapping members are coincidentally the same.</p>",
        "<p>Objects with <i>essentially floating</i> type shall not be compared with <i>memcmp</i> as the same value may be stored using different representations.</p>",
        "<p>If an <i>essentially char</i> array contains a null character, it is possible to treat the data as a character string rather than simply an array of characters. However that distinction is a matter of interpretation rather than syntax. Since <i>essentially char</i> arrays are most frequently used to store character strings, an attempt to compare such arrays using <i>memcmp</i> (rather than <i>strcmp</i> or <i>strncmp</i>) may indicate an error as the number of characters to be compared will be determined by the value of the <code>size_t</code> argument rather than the location of the null characters used to terminate the strings. The result may therefore depend on the comparison of characters which are not part of the respective strings.</p>",
        "<p><b>Example</b></p>",
        "<pre><code language=\"C++\">struct S;",
        "",
        "/*",
        " * Return value may indicate that 's1' and 's2' are different due to padding.",
        " */",
        "bool_t f1 ( struct S *s1, struct S *s2 )",
        "{",
        "  return ( memcmp ( s1, s2, sizeof ( struct S ) ) != 0 );    /* Non-compliant */",
        "}",
        "",
        "union U",
        "{",
        "  uint32_t range;",
        "  uint32_t height;",
        "};",
        "",
        "/*",
        " * Return value may indicate that 'u1' and 'u2' are the same",
        " * due to unintentional comparison of 'range' and 'height'.",
        " */",
        "bool_t f2 ( union U *u1, union U *u2 )",
        "{",
        "  return ( memcmp ( u1, u2, sizeof ( union U ) ) != 0 );    /* Non-compliant */",
        "}",
        "",
        "const char a[ 6 ] = \"task\";",
        "",
        "/*",
        " * Return value may incorrectly indicate strings are different as the",
        " * length of 'a' (4) is less than the number of bytes compared (6).",
        " */",
        "bool_t f3 ( const char b[ 6 ] )",
        "{",
        "  return ( memcmp ( a, b, 6 ) != 0 );    /* Non-compliant */",
        "}</code></pre>",
        "<p><b>See also</b></p>",
        "<p>Rule 21.14, Rule 21.15</p>"
      ]
    }
  },

  "MISRA23_21.18": {
    "tags": ["Language: C", "Language: C++", "Libraries"],
    "keys": ["float-equal","sti.OutOfBoundsStringFunctions"],
    "name": "Published Standards/MISRA C 2023/21.18 Out of Bounds with string.h",
    "test": "CPP_L041",
    "desc": {
      "html": [
        "<p><b>Title</b></p>",
        "<p>The <code>size_t</code> argument passed to any function in <code>&lt;string.h&gt;</code> shall have an appropriate value.</p>",
        "<p><b>Amplification</b></p>",
        "<p>The relevant functions in <code>&lt;string.h&gt;</code> are:</p>",
        "<p><code>memchr, memcmp, memcpy, memmove, memset, strncat, strncmp, strncpy, strxfrm</code></p>",
        "<p>An appropriate value is:</p>",
        "<ul>",
        "<li>Positive;</li>",
        "<li>No greater than the size of the smallest object passed to the function through a pointer parameter.</li>",
        "</ul>",
        "<p><b>Rationale</b></p>",
        "<p>Incorrect use of a function listed above may result in a read or write access beyond the bounds of an object passed as a parameter, resulting in <i>undefined behaviour</i>.</p>",
        "<p><b>Example</b></p>",
        "<pre><code language=\"C++\">char buf1[  5 ] = \"12345\";",
        "char buf2[ 10 ] = \"1234567890\";",
        "",
        "void f ( void )",
        "{",
        "  if ( memcmp ( buf1, buf2, 5 ) == 0 ) /* Compliant */",
        "  {",
        "  }",
        "",
        "  if ( memcmp ( buf1, buf2, 6 ) == 0 ) /* Non-compliant */",
        "  {",
        "  }",
        "}</code></pre>",
        "<p><b>See also</b></p>",
        "<p>Rule 21.17</p>"
      ]
    }
  },

  "MISRA23_23.2": {
    "tags": ["Language: C", "Expressions"],
    "keys": ["unevaluated-expression"],
    "name": "Published Standards/MISRA C 2023/23.2 Side Effects in Generic Selections",
    "test": "CPP_E053",
    "desc": {
      "html": [
        "<p><b>Title</b></p>",
        "<p>A generic selection that is not expanded from a macro shall not contain potential <i>side effects</i> in the controlling expression</p>",
        "<p><b>Amplification</b></p>",
        "<p>If the controlling expression of a generic selection is not expanded from a macro argument, it shall not appear to contain any side effects.</p>",
        "<p>A function call is considered to be a <i>side effect</i> for the purposes of this rule.</p>",
        "<p><b>Rationale</b></p>",
        "<p>The controlling expression of a generic selection is never evaluated. It is only used for its type, and usually has to be repeated in order to be combined with the result value in some way.</p>",
        "<p>If an expression is specified which syntactically contains a side effect, that effect will not be applied, even if the expression has a type that would cause it to be evaluated by <code>sizeof</code>, such as a VLA.</p>",
        "<p><b>Example</b></p>",
        "<pre><code language=\"C++\">#ifdef BIG",
        "typedef int64_t STATE;",
        "#else",
        "typedef int16_t STATE;",
        "#endif",
        "",
        "STATE shared_state;",
        "",
        "/* Compliant */",
        "_Static_assert ( _Generic ( shared_state",
        "               , int32_t: 0",
        "               , default: 1 )",
        "               , \"error on wrong type\");",
        "",
        "/* Non-compliant */",
        "_Static_assert ( _Generic ( ++shared_state",
        "               , int32_t: 0",
        "               , default: 1)",
        "               , \"error on wrong type\");</code></pre>",
        "<p><b>See also</b></p>",
        "<p>Rule 13.6, Rule 23.1, Rule 23.7</p>",
        "<p><b>Developer's Notes</b></p>",
        "<p>This checks for side effects in other contexts besides generic selections. Side effects in functions are not detected.</p>"
      ]
    }
  },

  "MISRA23_8.2.7": {
    "tags": ["Language: C", "Language: C++", "Standard: MISRA C++ 2023", "Category: Advisory", "Pointers"],
    "key": "sti.PointerToIntCast",
    "name": "Published Standards/MISRA C++ 2023/8.2.7 Pointer to Integer Cast",
    "desc": {
      "html": [
        "<p><b>Rationale</b></p>",
        "<p>Casting between a pointer and an integer type makes it harder for tools and developers to understand and reason about code behaviour. For example, pointer tracking within tools may become unreliable when pointers are cast to integers.</p>",
        "<p><i>Note</i>: casting between pointers and integers may be unavoidable when addressing memory mapped registers or other hardware specific features. When the advice given in this rule is not followed, the use of <code>std::uintptr_t</code> or <code>std::intptr_t</code> is required by Rule 8.2.8 as these types are guaranteed to be able to represent all possible pointer values.</p>",
        "",
        "<p><b>Example</b></p>",
        "<p>The following examples violate Rule 8.2.5, with the second also violating Rule 8.2.8:</p>",
        "<pre><code language=\"C++\">struct S;",
        "",
        "void f( S * s )",
        "{",
        "  std::intptr_t p = reinterpret_cast&lt; std::intptr_t &gt;( s );   // Non-compliant",
        "  std::uint8_t  q = reinterpret_cast&lt; std::uint8_t  &gt;( s );   // Non-compliant",
        "}",
        "</code></pre>",
        "",
        "<p><b>See also</b></p>",
        "<p>Rule 8.2.5, Rule 8.2.8</p>"
      ]
    }
  },

  "MISRA23_9.6.4": {
    "tags": ["Language: C", "Language: C++", "Standard: MISRA C++ 2023", "Category: Required", "Functions"],
    "key": "invalid-noreturn",
    "name": "Published Standards/MISRA C++ 2023/9.6.4 A function declared with the [[noreturn]] attribute shall not return",
    "test": "CPP_F067",
    "desc": {
      "html": [
        "<p><b>Amplification</b></p>",
        "<p>",
        "Leaving a function as the result of an exception is not a return.",
        "</p>",
        "<p>",
        "A function’s compliance with this rule is determined independently of the context in which the function is called. For example, a Boolean parameter is treated as if it may have a value of true or false, even if all the calls expressed in the current program use a value of true.",
        "</p>",
        "<p><b>Rationale</b></p>",
        "<p>",
        "Returning from a function declared as [[noreturn]] results in undefined behaviour.",
        "</p>",
        "<p>",
        "Note: a function may be declared as [[noreturn]] when:",
        "</p>",
        "<p>",
        "1. It only exits by throwing an exception; or",
        "</p>",
        "<p>",
        "2. It loops endlessly; or",
        "</p>",
        "<p>",
        "3. It causes program termination.",
        "</p>",
        "</p>",
        "<p><b>Example</b></p>",
        "<pre>",
        "[[noreturn]] void kill_the_process() // Compliant",
        "{",
        " std::abort(); // Note - std::abort is also [[noreturn]]",
        "}",
        "[[noreturn]] void throw_some() // Compliant - only exits with an exception",
        "{",
        " throw 42;",
        "}",
        "[[noreturn]] void g( bool b ) // Non-compliant - returns if 'b' is false",
        "{",
        " if ( b )",
        " {",
        "   throw std::exception{};",
        " }",
        "}",
        "</pre>",
        "<p><b>See also</b></p>",
        "<p>",
        "Rule 6.2.2",
        "</p>"
      ]
    }
  },
  "MISRA23_9.6.5": {
    "tags": ["Language: C", "Language: C++", "Standard: MISRA C++ 2023", "Category: Required", "Functions"],
    "key": "return-type",
    "name": "Published Standards/MISRA C++ 2023/9.6.5 A function with non-void return type shall return a value on all paths",
    "desc": {
      "html": [
        "<p><b>Amplification</b></p>",
        "<p>",
        "The compound statement of a lambda expression with a non-void return type is also considered to be a function covered by this rule.",
        "</p>",
        "<p>",
        "A return is not required after an explicit throw or after calling a function marked [[noreturn]].",
        "</p>",
        "<p>",
        "This rule does not apply to main, as it implicitly returns 0 if an exit path does not explicitly return a value.",
        "</p>",
        "<p>",
        "Note: flowing off the end of a function body, except within main, is equivalent to a return with no operand.",
        "</p>",
        "<p><b>Rationale</b></p>",
        "<p>",
        "The operand to return gives the value that the function returns. The absence of a return with an operand in an execution path through a function with a non-void return type results in undefined behaviour.",
        "</p>",
        "<p><b>Example</b></p>",
        "<pre>",
        "int32_t fn1() // Non-compliant",
        "{",
        "  // No return",
        "}",
        "int32_t fn2( int32_t x ) // Compliant",
        "{",
        " if ( x > 100 )",
        " {",
        "   throw 42; // Exiting via an exception",
        "  }",
        " else",
        " {",
        "   return x; // Value returned on other path",
        " }",
        "}",
        "</pre>",
        "<p><b>Developer's Notes</b></p>",
        "<p>This check utilizes the clang warning -Wreturn-type and this warning can occasionally produce false positives when analyzing complex control flows, such as Microsoft’s Structured Exception Handling (__try/__except) blocks, as Clang may conservatively assume an unhandled exception could bypass a return statement, even when all paths are covered.</p>"
      ]
    }
  },

  "MISRA23_8.2": {
    "tags": ["Language: C", "Language: C++", "Standard: MISRA C 2023", "Category: Required", "Functions"],
    "keys": ["strict-prototypes", "deprecated-non-prototype", "implicit-int", "sti.UnnamedParameters"],
    "name": "Published Standards/MISRA C 2023/8.2 Use Named Parameters and Prototype Form",
    "test": "CPP_F009",
    "desc": {
      "html": [
        "<p><b>Title</b></p>",
        "<p>Function types shall be in <i>prototype form</i> with named parameters.</p>",
        "<p><b>Rationale</b></p>",
        "<p>The early version of C, commonly referred to as K&R C [30], did not provide a mechanism for checking the number of arguments or their types against the corresponding parameters. The type of an object or function did not have to be declared in K&R C since the default type of an object and the default return type of a function was <i>int</i>.</p>",
        "<p>The C90 standard introduced function prototypes, a form of function declarator in which the parameter types were declared. This permitted argument types to be checked against parameter types. It also allowed the number of arguments to be checked except when a function prototype specified that a variable number of arguments was expected. The C90 standard did not <b>require</b> the use of function prototypes for reasons of backward compatibility with existing code. For the same reason, it continued to permit types to be omitted in which case the type would default to <i>int</i>.</p>",
        "<p>The C99 standard removed the default <i>int</i> type from the language but continued to allow K&R-style function types in which there was no means to supply parameter type information in a declaration and it was optional to supply parameter type information in a definition.</p>",
        "<p>The mismatch between the number of arguments and parameters, their types and the expected and actual return type of a function provides potential for undefined behaviour. The purpose of this rule along with Rule 8.1 and Rule 8.4 is to avoid this undefined behaviour by requiring parameter types and function return types to be specified explicitly. Rule 17.3 ensures that this information is available at the time of a function call, thereby requiring the compiler to diagnose any mismatch that is detected.</p>",
        "<p>This rule also requires that names be specified for all the parameters in a declaration. The parameter names can provide useful information regarding the function interface and a mismatch between a declaration and definition might be indicative of a programming error.</p>",
        "<p><i>Note</i>: An empty parameter list is <b>not</b> valid in a prototype. If a function type has no parameters its <i>prototype form</i> uses the keyword <i>void</i>.</p>",
        "<p><b>Example</b></p>",
        "<p>The first example shows declarations of some functions and the corresponding definitions for some of those functions.</p>",
        "<pre><code language=\"C++\">",
        "  /* Compliant                                                  */",
        "  extern int16_t func1 ( int16_t n );",
        "",
        "  /* Non-compliant - parameter name not specified               */",
        "  extern void func2 ( int16_t );",
        "",
        "  /* Non-compliant - not in prototype form                      */",
        "  static int16_t func3 ( );",
        "",
        "  /* Compliant - prototype specifies 0 parameters               */",
        "  static int16_t func4 ( void );",
        "",
        "  /* Compliant                                                  */",
        "  int16_t func1 ( int16_t n )",
        "  {",
        "    return n;",
        "  }",
        "",
        "  /* Non-compliant - old style identifier and declaration list  */",
        "  static int16_t func3 ( vec, n )",
        "  int16_t *vec;",
        "  int16_t n;",
        "  {",
        "    return vec[ n - 1 ];",
        "  }",
        "</code></pre>",
        "<p>This example section shows the application of the rule to function types other than in function declarations and definitions.</p>",
        "<pre><code language=\"C++\">",
        "  /* Non-compliant - no prototype                   */",
        "  int16_t ( *pf1 ) ( );",
        "",
        "  /* Compliant - prototype specifies 0 parameters   */",
        "  int16_t ( *pf1 ) ( void );",
        "",
        "  /* Non-compliant - parameter name not specified   */",
        "  typedef int16_t ( *pf2_t ) ( int16_t );",
        "",
        "  /* Compliant                                      */",
        "  typedef int16_t ( *pf3_t ) ( int16_t n );",
        "</code></pre>"
      ]
    }
  },

  "MISRA23_0.1.2": {
    "tags": [ "Language: C", "Language: C++", "Standard: MISRA C++ 2023", "Category: Required", "Functions" ],
    "key": "sti.IgnoredReturnValues",
    "name": "Published Standards/MISRA C++ 2023/0.1.2 The value returned by a function shall be used",
    "test": "A0-1-2",
    "desc": {
      "html": [
        "<p><b>Amplification</b></p>",
        "<p>This rule only applies when the function is called explicitly using function call syntax.</p>",
        "",
        "<p><b>Rationale</b></p>",
        "<p>It is possible to call a function without using the return value, which may be an error. If the return value of a function is intended to be explicitly discarded, it should be cast to void to ensure that it is used.</p>",
        "<p>Overloaded operators are excluded from this requirement, as they should behave in the same way as built-in operators.</p>",
        "<p>Note: this rule effectively requires all non-void functions to be treated as if they were declared [[nodiscard]].</p>",
        "",
        "<p><b>Example</b></p>",
        "<pre>uint16_t func();",
        "void discarded()",
        "{",
        " func(); // Non-compliant - implicitly discarded",
        " ( void )func(); // Compliant - void cast is a use",
        " auto b = func(); // Compliant - used as initializer",
        "}",
        "",
        "void f1( std::string q )",
        "{",
        " std::string s { q } ; // Rule does not apply - not function call syntax",
        " s = q; // Rule does not apply - not function call syntax",
        " s.operator=( q ); // Non-compliant",
        "}",
        "",
        "void f2( std::function< int() > & f )",
        "{",
        " f(); // Non-compliant - using function call syntax",
        " auto a = []() { return 10; };",
        " a(); // Non-compliant - using function call syntax",
        "}",
        "</pre>",
        "",
        "<p><b>See also</b></p>",
        "<p>Rule 28.6.4</p>"
      ]
    }
  },

  "MISRA23_0.2.1": {
    "tags": ["Language: C", "Language: C++", "Standard: MISRA C++ 2023", "Category: Advisory", "Variables"],
    "keys": ["unused-variable","unused-const-variable"],
    "name": "Published Standards/MISRA C++ 2023/0.2.1 Variables with limited visibility should be used at least once",
    "test": "CPP_V007",
    "desc": {
      "text": "Check for variables that are unused (C, C++, ObjC)",
      "html": [
        "<p><b>Amplification</b></p>",
        "<p>",
        "A variable has limited visibility if it is not a function parameter, and it has internal linkage or no linkage.",
        "</p>",
        "<p>",
        "A variable is used when:",
        "</p>",
        "<p>",
        "1. It is part of an id-expression; or",
        "</p>",
        "<p>",
        "2. The variable is of class type and has a user-provided constructor or a user-provided destructor.",
        "</p>",
        "<p><b>Rationale</b></p>",
        "<p>",
        "Variables that are declared and never used within a project do not contribute to program output; they constitute noise and may indicate that the wrong variable name has been used or that one or more statements are missing.",
        "</p>",
        "<p>",
        "Note: this rule allows the introduction of variables for the sole purpose of providing scoped resource allocation and release. For example: ",
        "</p>",
        "<pre>",
        "{",
        "  std::lock_guard< std::mutex > lock { mutex }; // Compliant - has user-provided constructor",
        "  // ...",
        "} // User-provided destructor implicitly called here",
        "</pre>",
        "<p><b>Exception</b></p>",
        "<p>",
        "This rule does not apply to:",
        "</p>",
        "<p>",
        "1. Variables that have at least one declaration with the [[maybe_unused]] attribute.",
        "</p>",
        "<p>",
        "2. Constant variables at namespace scope that are declared within a header file.",
        "</p>",
        "<p><b>Example</b></p>",
        "<pre>",
        "class C { }; // No user-provided constructor or destructor",
        "namespace",
        "{",
        " C c; // Non-compliant - unused",
        "}",
        "void maybeUnused( int32_t a )",
        "{",
        " [[maybe_unused]]",
        " bool b = a > 0; // Compliant (by exception #1 if NDEBUG is defined)",
        " assert( b ); // Does not use b if NDEBUG is defined",
        " usefn( a );",
        "}",
        "const int16_t x = 19; // Compliant - x is read in initializedButNotUsed",
        "const int16_t y = 21; // Non-compliant - would be compliant by exception #2",
        " // if declared in a header file",
        "void initializedButNotUsed()",
        "{",
        " int16_t local_1 = 42; // Non-compliant - local_1 is never read",
        " int16_t local_2; // Compliant",
        " local_2 = x; // Use of local_2 for the purposes of this rule",
        "}",
        "void userProvidedCtor()",
        "{",
        "  std::ifstream fs { 'cfg.ini' }; // Compliant - user-provided constructor",
        "}",
        "</pre>",
        "<p><b>See also</b></p>",
        "<p>Rule 0.2.2</p>"
      ]
    }
  },
  "MISRA23_18.5.2": {
    "tags": ["Language: C", "Language: C++", "Standard: MISRA C++ 2023", "Category: Advisory", "Control Flow"],
    "keys": ["sti.AbruptlyTerminate","exceptions"],
    "name": "Published Standards/MISRA C++ 2023/18.5.2 Program-terminating functions should not be used",
    "test": "A15-5-2",
    "desc": {
      "text": "Abrupt",
      "html": [
        "<p><b>Amplification</b></p>",
        "<p>A program should not contain calls to the C++ Standard Library functions abort, exit, _Exit, quick_exit or terminate.</p>",
        "<p>Additionally, the address of any of these functions should not be taken.</p>",
        "<p><b>Rationale</b></p>",
        "<p>If a program terminates due to a call to any of the functions listed above, then the stack will not be unwound and object destructors will not be called.</p>",
        "<p>This will potentially leave the environment in an undesirable state (e.g. a file permanently locked).</p>",
        "<p>Taking the address of the functions is not recommended to prevent them from being called via a function pointer.</p>",
        "<p>Notes:</p>",
        "<p>This rule only covers explicit calls to the termination functions.</p>",
        "<p>The majority of ways in which they may be called implicitly are prevented by Rule 18.1.2, Rule 18.3.1 and Rule 18.5.1.</p>",
        "<p>This rule aims to prevent program-terminating functions from being called without the system level implications (such as unreleased resources) being duly considered.</p>",
        "<p>If the safety architecture requires rapid termination on the detection of an error, then it may be appropriate to disapply this rule.</p>",
        "<p><b>Exception</b></p>",
        "<p>The call to abort that occurs due to the macro expansion of assert is not considered to be an explicit call, as it is not expected to be reachable.</p>",
        "<p>Note: a project may consider disallowing this exception if the behaviour of abort is not a suitable response to a failed assertion, such as when there is no external mechanism to recover the terminated program.</p>",
        "<p><b>See also</b></p>",
        "<p>Rule 18.1.2, Rule 18.3.1, Rule 18.5.1</p>"
      ]
    }
  },
  "MISRA23_21.8": {
    "tags": ["Language: C", "Language: C++", "Standard: MISRA C 2023", "Category: Required", "Control Flow"],
    "keys": ["sti.AbruptlyTerminate","exceptions"],
    "name": "Published Standards/MISRA C 2023/21.8 The Standard Library termination functions of <stdlib.h> shall not be used",
    "test": "A15-5-2",
    "desc": {
      "text": "Abrupt",
      "html": [
        "<p><b>Amplification</b></p>",
        "<p>The termination functions are abort, exit, _Exit and quick_exit.</p>",
        "<p>Identifiers with these names shall not be used and no macro with one of these names shall be expanded.</p>",
        "<p><b>Rationale</b></p>",
        "<p>These functions have undefined and implementation-defined behaviours associated with them.</p>",
        "<p><b>Devloper's Note</b></p>",
        "<p>This check may flag other funcitons with the same name</p>"
      ]
    }
  },
  "MISRA12_10.5": {
    "tags": ["Language: C", "Standard: MISRA C 2012", "Category: Advisory", "Types"],
    "key": "sti.CastToInappropriateType",
    "name": "Published Standards/MISRA C 2012/10.5 The value of an expression should not be cast to an inappropriate essential type",
    "desc": {
      "html": [
        "<p><b>Amplification</b></p>",
        "<p>The casts which should be avoided are shown in the following table, where values are cast (explicitly converted) to the essential type category of the first column.</p>",
        "<table>",
        "<tr>",
        "<th>Essential type category</th>",
        "<th></th>",
        "<th></th>",
        "<th></th>",
        "<th>from</th>",
        "<th></th>",
        "<th></th>",
        "</tr>",
        "<tr>",
        "<th>to</th>",
        "<th>Boolean</th>",
        "<th>character</th>",
        "<th>enum</th>",
        "<th>signed</th>",
        "<th>unsigned</th>",
        "<th>floating</th>",
        "</tr>",
        "<tr>",
        "<th>Boolean</th>",
        "<th></th>",
        "<th>Avoid</th>",
        "<th>Avoid</th>",
        "<th>Avoid</th>",
        "<th>Avoid</th>",
        "<th>Avoid</th>",
        "</tr>",
        "<tr>",
        "<th>character</th>",
        "<th>Avoid</th>",
        "<th></th>",
        "<th></th>",
        "<th></th>",
        "<th></th>",
        "<th>Avoid</th>",
        "</tr>",
        "<tr>",
        "<th>enum</th>",
        "<th>Avoid</th>",
        "<th>Avoid</th>",
        "<th>Avoid</th>",
        "<th>Avoid*</th>",
        "<th>Avoid</th>",
        "<th>Avoid</th>",
        "</tr>",
        "<tr>",
        "<th>signed</th>",
        "<th>Avoid</th>",
        "<th></th>",
        "<th></th>",
        "<th></th>",
        "<th></th>",
        "<th></th>",
        "</tr>",
        "<tr>",
        "<th>unsigned</th>",
        "<th>Avoid</th>",
        "<th></th>",
        "<th></th>",
        "<th></th>",
        "<th></th>",
        "<th></th>",
        "</tr>",
        "<tr>",
        "<th>floating</th>",
        "<th>Avoid</th>",
        "<th>Avoid</th>",
        "<th></th>",
        "<th></th>",
        "<th></th>",
        "<th></th>",
        "</tr>",
        "</table>",
        "<p>* Note: an enumerated type may be cast to an enumerated type provided that the cast is to the same essential enumerated type. Such casts are redundant.</p>",
        "<p>Casting from void to any other type is not permitted as it results in undefined behaviour. This is covered by Rule 1.3.</p>",
        "<p><b>Rationale</b></p>",
        "<p>An explicit cast may be introduced for legitimate functional reasons, for example:</p>",
        "<ul>",
        "<li>To change the type in which a subsequent arithmetic operation is performed;</li>",
        "<li>To truncate a value deliberately;</li>",
        "<li>To make a type conversion explicit in the interests of clarity.</li>",
        "</ul>",
        "<p>However, some explicit casts are considered inappropriate:</p>",
        "<ul>",
        "<li>In C99, the result of a cast or assignment to _Bool is always 0 or 1. This is not necessarily the case when casting to another type which is defined as essentially Boolean;</li>",
        "<li>A cast to an essentially enum type may result in a value that does not lie within the set of enumeration constants for that type;</li>",
        "<li>A cast from essentially Boolean to any other type is unlikely to be meaningful;</li>",
        "<li>Converting between floating and character types is not meaningful as there is no precise mapping between the two representations.</li>",
        "</ul>",
        "<p><b>Exception</b></p>",
        "<p>An integer constant expression with the value 0 or 1 of either signedness may be cast to a type which is defined as essentially Boolean. This allows the implementation of non-C99 Boolean models.</p>",
        "<p><b>Example</b></p>",
        "<pre><code language=\"C++\">( bool_t ) false /* Compliant - C99 'false' is essentially Boolean */",
        "( int32_t ) 3U /* Compliant */",
        "( bool_t ) 0 /* Compliant - by exception */",
        "( bool_t ) 3U /* Non-compliant */",
        "( int32_t ) ena /* Compliant */",
        "( enum enuma ) 3 /* Non-compliant */",
        "( char ) enc /* Compliant */",
        "</code></pre>"
      ]
    }
  },
  "MISRA23_10.5": {
    "tags": ["Language: C", "Standard: MISRA C 2023", "Category: Advisory", "Types"],
    "key": "sti.CastToInappropriateType",
    "name": "Published Standards/MISRA C 2023/10.5 The value of an expression should not be cast to an inappropriate essential type",
    "desc": {
      "html": [
        "<p><b>Amplification</b></p>",
        "<p>The casts which should be avoided are shown in the following table, where values are cast (explicitly converted) to the essential type category of the first column.</p>",
        "<table>",
        "<tr>",
        "<th>Essential type category</th>",
        "<th></th>",
        "<th></th>",
        "<th></th>",
        "<th>from</th>",
        "<th></th>",
        "<th></th>",
        "</tr>",
        "<tr>",
        "<th>to</th>",
        "<th>Boolean</th>",
        "<th>character</th>",
        "<th>enum</th>",
        "<th>signed</th>",
        "<th>unsigned</th>",
        "<th>floating</th>",
        "</tr>",
        "<tr>",
        "<th>Boolean</th>",
        "<th></th>",
        "<th>Avoid</th>",
        "<th>Avoid</th>",
        "<th>Avoid</th>",
        "<th>Avoid</th>",
        "<th>Avoid</th>",
        "</tr>",
        "<tr>",
        "<th>character</th>",
        "<th>Avoid</th>",
        "<th></th>",
        "<th></th>",
        "<th></th>",
        "<th></th>",
        "<th>Avoid</th>",
        "</tr>",
        "<tr>",
        "<th>enum</th>",
        "<th>Avoid</th>",
        "<th>Avoid</th>",
        "<th>Avoid</th>",
        "<th>Avoid*</th>",
        "<th>Avoid</th>",
        "<th>Avoid</th>",
        "</tr>",
        "<tr>",
        "<th>signed</th>",
        "<th>Avoid</th>",
        "<th></th>",
        "<th></th>",
        "<th></th>",
        "<th></th>",
        "<th></th>",
        "</tr>",
        "<tr>",
        "<th>unsigned</th>",
        "<th>Avoid</th>",
        "<th></th>",
        "<th></th>",
        "<th></th>",
        "<th></th>",
        "<th></th>",
        "</tr>",
        "<tr>",
        "<th>floating</th>",
        "<th>Avoid</th>",
        "<th>Avoid</th>",
        "<th></th>",
        "<th></th>",
        "<th></th>",
        "<th></th>",
        "</tr>",
        "</table>",
        "<p>* Note: an enumerated type may be cast to an enumerated type provided that the cast is to the same essential enumerated type. Such casts are redundant.</p>",
        "<p>Casting from void to any other type is not permitted as it results in undefined behaviour. This is covered by Rule 1.3.</p>",
        "<p><b>Rationale</b></p>",
        "<p>An explicit cast may be introduced for legitimate functional reasons, for example:</p>",
        "<ul>",
        "<li>To change the type in which a subsequent arithmetic operation is performed;</li>",
        "<li>To truncate a value deliberately;</li>",
        "<li>To make a type conversion explicit in the interests of clarity.</li>",
        "</ul>",
        "<p>However, some explicit casts are considered inappropriate:</p>",
        "<ul>",
        "<li>In C99, the result of a cast or assignment to _Bool is always 0 or 1. This is not necessarily the case when casting to another type which is defined as essentially Boolean;</li>",
        "<li>A cast to an essentially enum type may result in a value that does not lie within the set of enumeration constants for that type;</li>",
        "<li>A cast from essentially Boolean to any other type is unlikely to be meaningful;</li>",
        "<li>Converting between floating and character types is not meaningful as there is no precise mapping between the two representations.</li>",
        "</ul>",
        "<p><b>Exception</b></p>",
        "<p>An integer constant expression with the value 0 or 1 of either signedness may be cast to a type which is defined as essentially Boolean. This allows the implementation of non-C99 Boolean models.</p>",
        "<p><b>Example</b></p>",
        "<pre><code language=\"C++\">( bool_t ) false /* Compliant - C99 'false' is essentially Boolean */",
        "( int32_t ) 3U /* Compliant */",
        "( bool_t ) 0 /* Compliant - by exception */",
        "( bool_t ) 3U /* Non-compliant */",
        "( int32_t ) ena /* Compliant */",
        "( enum enuma ) 3 /* Non-compliant */",
        "( char ) enc /* Compliant */",
        "</code></pre>"
      ]
    }
  },
   "MISRA12_12.3": {
    "tags": ["Language: C", "Language: C++", "Standard: MISRA C 2012", "Category: Advisory", "Expressions"],
    "key": "comma",
    "name": "Published Standards/MISRA C 2012/12.3 The comma operator shall not be used.",
    "test": "CPP_E049",
    "desc": {
      "html": [
        "<p><b>Rationale</b></p>",
        "<p>The comma operator (represented by the token , ) is a binary operator that evaluates its first operand and discards the result, it then evaluates the second operand and returns this value (and type). The comma operator has the lowest precedence of any C operator, and acts as a sequence point.</p>",
        "<p>Use of the comma operator is generally detrimental to the readability of code, and the same effect can be achieved by other means.</p>",
        "<p><b>Example</b></p>",
        "<pre><code language=\"C++\">f ( ( 1, 2 ), 3 ); // Non-compliant – how many parameters?</code></pre>"
      ]
    }
  },
   "MISRA23_12.3": {
    "tags": ["Language: C", "Language: C++", "Standard: MISRA C 2023", "Category: Advisory", "Expressions"],
    "key": "comma",
    "name": "Published Standards/MISRA C 2023/12.3 The comma operator shall not be used.",
    "test": "CPP_E049",
    "desc": {
      "html": [
        "<p><b>Rationale</b></p>",
        "<p>The comma operator (represented by the token , ) is a binary operator that evaluates its first operand and discards the result, it then evaluates the second operand and returns this value (and type). The comma operator has the lowest precedence of any C operator, and acts as a sequence point.</p>",
        "<p>Use of the comma operator is generally detrimental to the readability of code, and the same effect can be achieved by other means.</p>",
        "<p><b>Example</b></p>",
        "<pre><code language=\"C++\">f ( ( 1, 2 ), 3 ); // Non-compliant – how many parameters?</code></pre>"
      ]
    }
  },
   "MISRA23_22.1": {
    "tags": ["Language: C", "Language: C++", "Standard: MISRA C 2023", "Category: Required", "Memory Allocation"],
    "key": "sti.FreedMemory",
    "name": "Published Standards/MISRA C 2023/22.1 All resources obtained dynamically by means of Standard Library functions shall be explicitly released",
    "desc": {
      "html": [
        "<p><b>Amplification</b></p>",
        "<p>This rule applies to malloc, calloc, realloc, aligned_alloc and fopen.</p>",
        "<p><b>Rationale</b></p>",
        "<p>If resources are not explicitly released then it is possible for a failure to occur due to exhaustion of those resources. Releasing resources as soon as possible reduces the possibility that exhaustion will occur.</p>",
        "<p><b>Example</b></p>",
        "<pre><code language=\"C++\">#include <stdlib.h>",
        "int main ( void )",
        "{",
        "void *b = malloc ( 40 );",
        "/* Non-compliant - dynamic memory not released */",
        "return 1;",
        "}",
        "#include <stdio.h>",
        "int main ( void )",
        "{",
        "FILE *fp = fopen ( \"tmp\", \"r\" );",
        "/* Non-compliant - file not closed */",
        "return 1;",
        "}</code></pre>",
        "<p>In the following non-compliant example, the handle on “tmp-1” is lost when “tmp-2” is opened.</p>",
        "<pre><code language=\"C++\">",
        "#include <stdio.h>",
        "int main ( void )",
        "{",
        "FILE *fp;",
        "fp = fopen ( \"tmp-1\", \"w\" );",
        "fprintf ( fp, \"*\" );",
        "* File \"tmp-1\" should be closed here, but stream 'leaks' *",
        "fp = fopen ( \"tmp-2\", \"w\" );",
        "fprintf ( fp, \"!\" );",
        "fclose ( fp );",
        "return ( 0 );",
        "}</code></pre>",
        "<p><b>See also</b></p>",
        "<p>Dir 4.12, Dir 4.13, Rule 21.3, Rule 21.6</p>"
      ]
    }
  },
   "MISRA12_22.1": {
    "tags": ["Language: C", "Language: C++", "Standard: MISRA C 2012", "Category: Required", "Memory Allocation"],
    "key": "sti.FreedMemory",
    "test": "MISRA23_22.1",
    "name": "Published Standards/MISRA C 2012/22.1 All resources obtained dynamically by means of Standard Library functions shall be explicitly released",
    "desc": {
      "html": [
        "<p><b>Amplification</b></p>",
        "<p>This rule applies to malloc, calloc, realloc, aligned_alloc and fopen.</p>",
        "<p><b>Rationale</b></p>",
        "<p>If resources are not explicitly released then it is possible for a failure to occur due to exhaustion of those resources. Releasing resources as soon as possible reduces the possibility that exhaustion will occur.</p>",
        "<p><b>Example</b></p>",
        "<pre><code language=\"C++\">#include <stdlib.h>",
        "int main ( void )",
        "{",
        "void *b = malloc ( 40 );",
        "/* Non-compliant - dynamic memory not released */",
        "return 1;",
        "}",
        "#include <stdio.h>",
        "int main ( void )",
        "{",
        "FILE *fp = fopen ( \"tmp\", \"r\" );",
        "/* Non-compliant - file not closed */",
        "return 1;",
        "}</code></pre>",
        "<p>In the following non-compliant example, the handle on “tmp-1” is lost when “tmp-2” is opened.</p>",
        "<pre><code language=\"C++\">",
        "#include <stdio.h>",
        "int main ( void )",
        "{",
        "FILE *fp;",
        "fp = fopen ( \"tmp-1\", \"w\" );",
        "fprintf ( fp, \"*\" );",
        "* File \"tmp-1\" should be closed here, but stream 'leaks' *",
        "fp = fopen ( \"tmp-2\", \"w\" );",
        "fprintf ( fp, \"!\" );",
        "fclose ( fp );",
        "return ( 0 );",
        "}</code></pre>",
        "<p><b>See also</b></p>",
        "<p>Dir 4.12, Dir 4.13, Rule 21.3, Rule 21.6</p>"
      ]
    }
  },
   "MISRA23_22.2": {
    "tags": ["Language: C", "Language: C++", "Standard: MISRA C 2023", "Category: Mandatory", "Memory Allocation"],
    "key": "sti.BadFree",
    "name": "Published Standards/MISRA C 2023/22.2 A block of memory shall only be freed if it was allocated by means of a Standard Library function",
    "desc": {
      "html": [
        "<p><b>Amplification</b></p>",
        "<p>The Standard Library functions that allocate memory are malloc, calloc and realloc.</p>",
        "<p>A block of memory is freed when its address is passed to free and potentially freed when its address is passed to realloc. Once freed, a block of memory is no longer considered to be allocated and therefore cannot subsequently be freed again.</p>",
        "<p><b>Rationale</b></p>",
        "<p>Freeing non-allocated memory, or freeing the same allocated memory more than once leads to undefined behaviour.</p>",
        "<p><b>Example</b></p>",
        "<pre><code language=\"C++\">#include <stdlib.h>",
        "void fn ( void )",
        "{",
        "int32_t a;",
        "/* Non-compliant - a does not point to allocated storage */",
        "free ( &a );",
        "}",
        "void g ( void )",
        "{",
        "char *p = ( char * ) malloc ( 512 );",
        "char *q = p;",
        "free ( p );",
        "/* Non-compliant - allocated block freed a second time */",
        "free ( q );",
        "/* Non-compliant - allocated block may be freed a third time */",
        "p = ( char * ) realloc ( p, 1024 );",
        "}</code></pre>",
        "<p><b>See also</b></p>",
        "<p>Dir 4.12, Dir 4.13, Rule 21.3</p>"
      ]
    }
  },
   "MISRA12_22.2": {
    "tags": ["Language: C", "Language: C++", "Standard: MISRA C 2012", "Category: Required", "Memory Allocation"],
    "key": "sti.BadFree",
    "test": "MISRA23_22.2",
    "name": "Published Standards/MISRA C 2012/22.2 A block of memory shall only be freed if it was allocated by means of a Standard Library function",
    "desc": {
      "html": [
        "<p><b>Amplification</b></p>",
        "<p>The Standard Library functions that allocate memory are malloc, calloc and realloc.</p>",
        "<p>A block of memory is freed when its address is passed to free and potentially freed when its address is passed to realloc. Once freed, a block of memory is no longer considered to be allocated and therefore cannot subsequently be freed again.</p>",
        "<p><b>Rationale</b></p>",
        "<p>Freeing non-allocated memory, or freeing the same allocated memory more than once leads to undefined behaviour.</p>",
        "<p><b>Example</b></p>",
        "<pre><code language=\"C++\">#include <stdlib.h>",
        "void fn ( void )",
        "{",
        "int32_t a;",
        "/* Non-compliant - a does not point to allocated storage */",
        "free ( &a );",
        "}",
        "void g ( void )",
        "{",
        "char *p = ( char * ) malloc ( 512 );",
        "char *q = p;",
        "free ( p );",
        "/* Non-compliant - allocated block freed a second time */",
        "free ( q );",
        "/* Non-compliant - allocated block may be freed a third time */",
        "p = ( char * ) realloc ( p, 1024 );",
        "}</code></pre>",
        "<p><b>See also</b></p>",
        "<p>Dir 4.12, Dir 4.13, Rule 21.3</p>"
      ]
    }
  },
   "MISRA23_8.19.1": {
    "tags": ["Language: C", "Language: C++", "Standard: MISRA C++ 2023", "Category: Advisory", "Expressions"],
    "key": "comma",
    "name": "Published Standards/MISRA C++ 2023/8.19.1 The comma operator shall not be used.",
    "test": "CPP_E049",
    "desc": {
      "html": [
        "<p><b>Rationale</b></p>",
        "<p>The comma operator (represented by the token , ) is a binary operator that evaluates its first operand and discards the result, it then evaluates the second operand and returns this value (and type). The comma operator has the lowest precedence of any C operator, and acts as a sequence point.</p>",
        "<p>Use of the comma operator is generally detrimental to the readability of code, and the same effect can be achieved by other means.</p>",
        "<p><b>Example</b></p>",
        "<pre><code language=\"C++\">f ( ( 1, 2 ), 3 ); // Non-compliant – how many parameters?</code></pre>"
      ]
    }
  },
  "MISRA23_7.0.6": {
    "tags": ["Language: C++", "Standard: MISRA C++ 2023", "Category: Required", "Types"],
    "key": "sti.InappropriateNumericAssignment",
    "name": "Published Standards/MISRA C++ 2023/7.0.6 Assignment between numeric types shall be appropriate",
    "desc": {
      "html": [
        "<p><b>Amplification</b></p>",
        "<p>This rule applies to all assignments where the source and target have numeric type.</p>",
        "<p>A call is non-extensible when it is:</p>",
        "<ul>",
        "<li>A qualified call to a member function (such as a.f(x), this->f(x), or A::f(x)); or</li>",
        "<li>A call to an operator().</li>",
        "</ul>",
        "<p>A function argument arg is overload-independent when the call is:</p>",
        "<ul>",
        "<li>Through a pointer to function or pointer to member function; or</li>",
        "<li>Non-extensible, and, for all overloads that are callable with the same number of arguments, the parameters corresponding to arg have the same type. Note that a parameter of a function template that is dependent on a function template parameter never has the same type.</li>",
        "</ul>",
        "<p>The source and target within an assignment shall have the same type when the source expression is:</p>",
        "<ol>",
        "<li>An argument to a function call (including an implicit constructor call) and the corresponding parameter is not overload-independent; or</li>",
        "<li>Passed through the ellipsis parameter in a function call (where the target type is the promoted type of the argument).</li>",
        "</ol>",
        "<p>For all other assignments:</p>",
        "<ol>",
        "<li>The source and target shall have types of the same type category, signedness and size; or</li>",
        "<li>The source and target shall have types of the same type category, signedness, the source size shall be smaller than the target size, and the source shall be an id-expression; or</li>",
        "<li>The source shall be an integer constant expression and the target shall be either:",
        "<ol type=\"a\">",
        "<li>Any numeric type with a range large enough to represent the value, even if the value is not exactly representable (when storing to a float, for example); or</li>",
        "<li>A bit-field whose value representation width and signedness are capable of representing the value.</li>",
        "</ol>",
        "</li>",
        "</ol>",
        "<p><b>Rationale</b></p>",
        "<p>The C++ built-in operators perform many implicit conversions on their operands. These conversions can lead to unexpected information loss, change of signedness, implementation-defined behaviour or undefined behaviour. This rule therefore places restrictions on the presence of implicit numeric conversions on assignment.</p>",
        "<p>For floating-point types, the exact representation of a value is often not possible, so loss of precision when assigning a constant value is not a violation of this rule, provided it is within the range of the target type.</p>",
        "<p>Additionally, implicit conversions on assignment to a function parameter are undesirable as they could result in a silent change in overload selection due to changes elsewhere within the code, such as the addition of a #include. For this reason, the implicit conversion of a function argument is not permitted — except when the corresponding parameter is overload-independent, in which case an implicit conversion of the type category is permitted as a silent change in overload selection cannot occur.</p>",
        "<p><b>Exception</b></p>",
        "<p>The assignment to a parameter within a call to a constructor that is callable with a single numeric argument is permitted to have a target type that is a wider version of the source type, provided that the class has no other constructors that are callable with a single argument, apart from copy or move constructors. This allows an instance of the class to be created and used as a function parameter without requiring an explicit widening conversion of the source type.</p>",
        "<p><b>Example</b></p>",
        "<pre><code language=\"C++\">u32 = 1;                      // Compliant",
        "s32 = 4u * 2u;                // Compliant",
        "u8 = 3u;                      // Compliant",
        "u8 = 300u;                    // Non-compliant - value does not fit",
        "",
        "struct S {",
        "    uint32_t b : 2;           // Bit-field is considered to be uint8_t",
        "};",
        "S s;",
        "s.b = 2;                      // Compliant",
        "s.b = 32u;                    // Non-compliant - value does not fit",
        "s.b = u8;                     // Compliant - same width, but may truncate",
        "s.b = u16;                    // Non-compliant - narrowing",
        "",
        "void sb1(uint32_t);",
        "void sb1(uint8_t);",
        "void sb2(uint8_t);",
        "void sb3() {",
        "    sb1(s.b);                 // Non-compliant - s.b considered to be uint8_t,",
        "                              // but sb1(uint32_t) is called",
        "    sb2(s.b);                 // Compliant",
        "}",
        "",
        "enum Colour : uint16_t { red, green, blue } c;",
        "u8 = red;                     // Compliant - value can be represented",
        "u32 = red;                    // Compliant - value can be represented",
        "u8 = c;                       // Non-compliant - different sizes (narrowing)",
        "u32 = c;                      // Compliant - widening of id-expression",
        "",
        "enum States { enabled, disabled };",
        "u8 = enabled;                 // Rule does not apply - source type not numeric",
        "",
        "unsigned long ul;",
        "unsigned int ui = ul;         // Compliant - if sizes are equal",
        "",
        "u8 = s8;                      // Non-compliant - different signedness",
        "u8 = u8 + u8;                 // Non-compliant - change of sign and narrowing",
        "flt1 = s32;                   // Non-compliant - different type category",
        "flt2 = 0.0;                   // Non-compliant - different sizes and not an",
        "                              // integral constant expression",
        "flt3 = 0.0f;                  // Compliant",
        "flt4 = 1;                     // Compliant",
        "flt5 = 9999999999;            // Compliant - loss of precision is possible",
        "",
        "int f(int8_t s8) {",
        "    int16_t val1 = s8;        // Compliant",
        "    int16_t val2{s8};         // Compliant",
        "    int16_t val3(s8);         // Compliant",
        "    int16_t val4{s8 + s8};    // Non-compliant - narrowing, as s8 + s8 is int",
        "    switch(s8) {",
        "        case 1:               // Compliant",
        "        case 0xFFFF'FFFF'FFFF: // Non-compliant - value does not fit in int8_t",
        "        return s8;            // Compliant - widening of id-expression",
        "    }",
        "    return s8 + s8;           // Compliant - s8 + s8 is of type int",
        "}",
        "",
        "// Function parameters",
        "void f1(int64_t i);",
        "f1(s32 + s32);                // Non-compliant - implicit widening conversion",
        "",
        "void f2(int i);",
        "f2(s32 + s64);                // Non-compliant - implicit narrowing conversion",
        "f2(s16 + s16);                // Compliant - result of addition is int",
        "",
        "struct A {",
        "    explicit A(int32_t i);",
        "    explicit A(int64_t i);",
        "};",
        "A a{s16};                     // Non-compliant",
        "",
        "void f3(long l);",
        "void (*fp)(long l) = &amp;f3;",
        "f3(2);                        // Non-compliant - implicit conversion from int to",
        "                              // long. Adding a #include would silently change",
        "                              // the selected overload if it added void f3(int)",
        "fp(2);                        // Compliant - calling through function pointer is",
        "                              // overload-independent",
        "",
        "struct MyInt {",
        "    explicit MyInt(int32_t);",
        "    MyInt(int32_t, int32_t);",
        "};",
        "void f4(MyInt);",
        "void bar(int16_t s) {",
        "    f4(MyInt{s});             // Compliant by exception - no need to cast s",
        "    MyInt i{s};               // Compliant by exception - no need to cast s",
        "}",
        "",
        "void log(char const *fmt, ...);",
        "void f(uint8_t c) {",
        "    log(\"f( %c )\", c);        // Non-compliant - conversion of c from uint8_t to int",
        "}",
        "",
        "// Overload-independent parameters",
        "struct A {",
        "    void set(short value);",
        "    void set(size_t index, int value);",
        "    void set(size_t index, std::string value);",
        "    void set(int index, double value) = delete;  // Not callable",
        "    void g();",
        "};",
        "",
        "void f(A &amp;a) {",
        "    a.set(42, \"answer\");      // Compliant - size_t can represent 42, and it is",
        "}                             // assigned to an overload-independent parameter",
        "",
        "void A::g() {",
        "    set(42, \"answer\");        // Non-compliant - even though this non-qualified",
        "}                             // call will only select an overload in the class",
        "",
        "struct B {",
        "    void set(int index, int value);",
        "    void set(long index, std::string value);",
        "};",
        "",
        "void f(B &amp;b) {",
        "    b.set(42, \"answer\");      // Non-compliant - conversion from int to long not",
        "}                             // allowed as parameter is not overload-independent",
        "",
        "struct C {",
        "    int32_t x;",
        "    int64_t y;",
        "    int64_t z;",
        "};",
        "C c1{s16 + s16,               // Compliant - s16 + s16 is of type int",
        "     s16 + s16,               // Non-compliant - widening from int",
        "     s16};                    // Compliant - widening of id-expression",
        "",
        "template&lt;typename T&gt;",
        "struct D {",
        "    void set1(T index, int value);",
        "    void set1(T index, std::string value);",
        "    template&lt;typename S1&gt;",
        "    void set2(S1 index, int value);",
        "    template&lt;typename S2&gt;",
        "    void set2(S2 index, std::string value);",
        "};",
        "",
        "void f(D&lt;size_t&gt; &amp;a) {",
        "    a.set1(42, \"X\");          // Compliant - size_t is same type",
        "    a.set2&lt;size_t&gt;(42, \"X\");  // Non-compliant - 'S1' is never the same as",
        "}                             // the specialized type of 'S2' (size_t)",
        "</code></pre>"
      ]
    }
  }
}
