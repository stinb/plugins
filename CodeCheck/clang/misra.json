{
  "MISRA08_4-5-3": {
    "tags": ["Language: C", "Language: C++", "Standard: MISRA C++ 2008", "Category: Required", "Expressions"],
    "key": "sti.CharOperators",
    "name": "Published Standards/MISRA-C++ 2008/4-5-3 Character Operators",
    "desc": {
      "text": "",
      "html": [
        "<p>Expressions with type (plain) <i>char</i> and <i>wchar_t</i> shall not be used as operands to built-in operators other than the assignment operator <i>=</i>, the equality operators <code>==</code> and <code>!=</code>, and the unary <code>&</code> operator.</p>",
        "<p><b>Rationale</b></p>",
        "<p>Manipulation of character data may generate results that are contrary to developer expectations. For example, ISO/IEC 14882:2003 [1] ยง2.2(3) only requires that the digits \"0\" to \"9\" have consecutive numerical values.</p>",
        "<p><b>Exception</b></p>",
        "<p>Exceptionally, the following operators may be used if the associated restriction is observed:</p>",
        "<ul>",
        "<li>",
        "The binary <code>+</code> operator may be used to add an integral value in the",
        "range 0 to 9 to '0';",
        "</li>",
        "<li>",
        "The binary <code>-</code> operator may be used to subtract character '0';",
        "</li>",
        "<li>",
        "The relational operators <code>&lt;</code>, <code>&lt;=</code>,",
        "<code>&gt;</code>, <code>&gt;=</code> may be used to determine if a character",
        "(or wide character) represents a digit.",
        "</li>",
        "</ul>",
        "<p><b>Example</b></p>",
        "<pre>",
        "char_t ch = 't';                      // Compliant",
        "uint8_t v;",
        "if ( ( ch &gt;= 'a' ) && ( ch &lt;= 'z' ) ) // Non-compliant",
        "{",
        "}",
        "if ( ( ch &gt;= '0' ) && ( ch &lt;= '9' ) ) // Compliant by exception",
        "{",
        "   v = ch - '0';                      // Compliant by exception",
        "   v = ch - '1';                      // Non-compliant",
        "}",
        "else",
        "{",
        "   // ...",
        "}",
        "ch = '0' + v;                         // Compliant by exception",
        "ch = 'A' + v;                         // Non-compliant",
        "</pre>",
        "<p><b>Developer's Notes</b></p>",
        "<p>Other operators are allowed which are not generally thought of as operators. This includes but is not limited to</p>",
        "<ul>",
        "<li>Scope resolution <code>::</code></li>",
        "<li>C-style cast <code>(type)</code></li>",
        "<li>Size-of <code>sizeof</code></li>",
        "<li>Alignment requirement <code>_Alignof</code></li>",
        "<li>Ternary conditional <code>?:</code></li>",
        "</ul>"
      ]
    }
  },

  "MISRA08_5-2-9": {
    "tags": ["Language: C", "Language: C++", "Standard: MISRA C++ 2008", "Category: Advisory", "Pointers"],
    "key": "sti.PointerToIntCast",
    "name": "Published Standards/MISRA-C++ 2008/5-2-9 Pointer to Integer Cast",
    "desc": {
      "html": [
        "<p><b>Rationale</b></p>",
        "<p>The size of integer that is required when a pointer is converted to an integer is <i>implementation-defined</i>. Casting between a pointer and an integer type should be avoided where possible, but may be unavoidable when addressing memory mapped registers or other hardware specific features.</p>",
        "<p>Note that C++ does not permit a pointer to be converted to any floating type.</p>",
        "",
        "<p><b>Example</b></p>",
        "<pre><code language=\"C++\">struct S",
        "{",
        "   int32_t i;",
        "   int32_t j;",
        "};",
        "void f ( S * s )",
        "{",
        "   int32_t p = reinterpret_cast&lt; int32_t &gt;( s );   // Non-compliant",
        "}",
        "</code></pre>"
      ]
    }
  },

  "MISRA08_0-1-2": {
    "tags": ["Language: C", "Language: C++", "Standard: MISRA C++ 2008", "Category: Required", "Expressions"],
    "keys": ["tautological-bitwise-compare", "tautological-compare", "tautological-constant-compare", "tautological-constant-in-range-compare", "tautological-constant-out-of-range-compare", "tautological-objc-bool-compare", "tautological-overlap-compare", "tautological-pointer-compare", "tautological-type-limit-compare", "tautological-undefined-compare", "tautological-unsigned-char-zero-compare", "tautological-unsigned-enum-zero-compare", "tautological-unsigned-zero-compare", "tautological-value-range-compare"],
    "name": "Published Standards/MISRA-C++ 2008/0-1-2 Infeasible Paths",
    "desc": {
      "html": [
        "<p>A <i>project</i> shall not contain <i>infeasible paths</i></p>",
        "<p><b>Rationale</b></p>",
        "<p><i>Infeasible paths</i> occur where there is a syntactic path but the semantics ensure that the control flow path cannot be executed by any input data. One of the major problems here is the explosion of <i>infeasible paths</i> caused by:</p>",
        "<ul>",
        "<li><i>if</i> ... <i>else</i> statement sequences;</li>",
        "<li>Sequences of poorly chosen loop constructs</li>",
        "</ul>",
        "<p>Errors in conditions and poorly designed logic contribute to this problem. It is always possible to rewrite the code to eliminate these constructs. This process may then reveal faults.</p>",
        "<p>There is the possibility that protective coding techniques generate infeasible code. This code is usually executable (and hence feasible) in a unit testing environment.</p>",
        "<p><b>Example</b></p>",
        "<pre>",
        "void infeas ( uint8_t para, uint8_t outp )",
        "{",
        "   // The condition below will always be true hence the path",
        "   // for the false condition is infeasible. Non-compliant.",
        "   if ( para &gt;= 0U )",
        "   {",
        "      outp = 1U;",
        "   }",
        "",
        "   // The following if statement combines with the if",
        "   // statement above to give four paths. One from",
        "   // the first condition is already infeasible and",
        "   // the condition below combined with assignment above",
        "   // makes the false branch infeasible. There is therefore",
        "   // only one feasible path through this code.",
        "   if ( outp == 1U )",
        "   {",
        "      outp = 0U;",
        "   }",
        "}",
        "",
        "enum ec { RED, BLUE, GREEN } col;",
        "",
        "if ( col &lt;= GREEN ) // Non-compliant - always true",
        "{",
        " // Will always get here",
        "}",
        "else",
        "{",
        " // Will never get here",
        "}",
        "",
        "// The following ifs exhibit similar behaviour.",
        "// Note that u16a is a 16-bit unsigned integer",
        "// and s8a is an 8-bit signed integer.",
        "",
        "if ( u16a &lt; 0U ) // Non-compliant - u16a is always &gt;= 0",
        "",
        "if ( u16a &lt;= 0xffffU ) // Non-compliant - always true",
        "",
        "if ( s8a &lt; 130 ) // Non-compliant - always true",
        "",
        "if ( ( s8a &lt; 10 ) && ( s8a &gt; 20 ) ) // Non-compliant - always false",
        "",
        "if ( ( s8a &lt; 10 ) || ( s8a &gt; 5 ) ) // Non-compliant - always true",
        "",
        "// Nested conditions can also cause problems",
        "if ( s8a &gt; 10 )",
        "{",
        "   if ( s8a &gt; 5 ) // Non-compliant, unless s8a volatile",
        "   {",
        "      // Will always get here.",
        "   }",
        "}",
        "</pre>",
        "<p><b>Developer's Notes</b></p>",
        "<p>This check does not find control-flow that is impossible to go to, such as sequences of poorly chosen loop constructs. It simply finds some expressions which are always true or always false.</p>",
        "<p>In the MISRA C++ 2008 example for rule 0-1-2, there are 2 non-compliant parts that this check misses. An enum can actually be outside of the enum range via casting, so this is not checked. The nested condition is also not checked.</p>"
      ]
    }
  },
  "MISRA08_0-1-3": {
    "tags": ["Language: C", "Language: C++", "Standard: MISRA C++ 2008", "Category: Required", "Variables"],
    "keys": ["unused-variable","unused-const-variable"],
    "name": "Published Standards/MISRA-C++ 2008/0-1-3 A project shall not contain unused variables",
    "desc": {
      "text": "Check for variables that are unused (C, C++, ObjC)",
      "html": [
        "<p><b>Unused Variables (C, C++, ObjC)</b></p><p>",
        "Variables declared and never used in a project constitute noise and may ",
        "indicate that the wrong variable name has been used somewhere. Removing these",
        "declarations reduces the possibility that they may later be used instead of ",
        "the correct variable. If padding is used within bit-fields, then the padding",
        "member should be unnamed to avoid violation of this rule.</p>",
        "<p>Check ignores references inside inactive code (ie #if 0...#endif).</p>",
        "<b>Example</b><pre>",
          "extern void usefn ( int16_t a, int16_t b );",
          "class C ",
          "{ ",
          "   ... ",
          "};",
          "C c;                         // Non-compliant - unused",
          "void withunusedvar ( void ) ",
          "{ ",
          "   int16_t unusedvar;        // Non-compliant - unused",
          "   struct s_tag ",
          "   { ",
          "      signed int a   : 3; ",
          "      signed int pad : 1;    // Non-compliant - should be unnamed ",
          "      signed int b   : 2; ",
          "   } s_var;",
          "   s_var.a = 0; ",
          "   s_var.b = 0; ",
          "   usefn ( s_var.a, s_var.b ); ",
          "}</pre>"
      ]
    }
  },

  "MISRA08_0-1-7": {
    "tags": [ "Language: C", "Language: C++", "Standard: MISRA C++ 2008", "Category: Required", "Functions" ],
    "key": "sti.IgnoredReturnValues",
    "name": "Published Standards/MISRA-C++ 2008/0-1-7 The value returned by a function having a non-void return type that is not an overloaded operator shall always be used",
    "desc": {
      "html": [
        "<p><b>Rationale</b></p>",
        "<p>In C++ it is possible to call a function without using the return value, which may be an error. The return value of a function shall always be used. Overloaded operators are excluded, as they should behave in the same way as built-in operators.</p>",
        "<p><b>Exception</b></p>",
        "<p>The return value of a function may be discarded by use of a (void) cast.</p>",
        "<p><b>Example</b></p><pre> uint16_t func ( uint16_t para1 )",
        "  {",
        "     return para1;",
        "  }",
        "  void discarded ( uint16_t para2 )",
        "  {",
        "     func ( para2 );         // value discarded ย Non-compliant",
        "     (void)func ( para2 );   // Compliant",
        "  }",
        "</pre>"
      ]
    }
  },

  "MISRA04_13.3": {
    "tags": ["Language: C", "Standard: MISRA C 2004", "Category: Required", "Expressions"],
    "keys": ["float-equal","sti.FloatingEqualityTest"],
    "name": "Published Standards/MISRA-C 2004/13.3 Floating-point expressions shall not be tested for equality or inequality",
    "desc": {
      "text": "Floating Equality Test",
      "html": [
        "<p>Floating-point expressions shall not be directly or indirectly tested for",
        "equality or inequality</p>",
        "<p><b>Rationale</b></p><p>",
        "The inherent nature of floating-point types is such that comparisons of equality",
        "will often not evaluate to true, even when they are expected to. Also, the",
        "behavior of such a comparison cannot be predicted before execution, and may",
        "well vary from one implementation to another.</p>",
        "<p>The recommended method for achieving deterministic floating-point comparisons",
        "is to write a library that implements the comparison operations. The library",
        "should take into account the floating-point granularity",
        "(<code>std::numeric_limits<float>::epsilon()</code>) and the magnitude of the",
        "numbers being compared.</p>",
        "<p><b>Example</b></p>",
        "<pre><code language=\"C++\">// The result of the test in the following code is unpredictable:",
        "float32_t x, y;",
        "if ( x == y )     // Non-compliant",
        "if ( x == 0.0f )  // Non-compliant",
        "// An indirect test is equally problematic and is also prohibited by this rule:",
        "if ( ( x &lt;= y ) && ( x &gt;= y ) )   // Non-compliant",
        "if ( ( x &lt; y ) || ( x &gt; y ) )     // Non-compliant",
        "// The following is better, but only if the magnitudes are appropriate:",
        "if ( fabs ( x - y ) &lt;= std::numeric_limits&lt;float&gt;::epsilon( ) ) //Compliant",
        "</code></pre>"
      ]
    }
  },
  "MISRA08_6-2-2": {
    "tags": ["Language: C", "Language: C++", "Standard: MISRA C++ 2008", "Category: Required", "Expressions"],
    "keys": ["float-equal","sti.FloatingEqualityTest"],
    "name": "Published Standards/MISRA-C++ 2008/6-2-2 Floating-point expressions shall not be directly or indirectly tested for equality or inequality",
    "desc": {
      "text": "Floating Equality Test",
      "html": [
        "<p>Floating-point expressions shall not be directly or indirectly tested for",
        "equality or inequality</p>",
        "<p><b>Rationale</b></p><p>",
        "The inherent nature of floating-point types is such that comparisons of equality",
        "will often not evaluate to true, even when they are expected to. Also, the",
        "behavior of such a comparison cannot be predicted before execution, and may",
        "well vary from one implementation to another.</p>",
        "<p>The recommended method for achieving deterministic floating-point comparisons",
        "is to write a library that implements the comparison operations. The library",
        "should take into account the floating-point granularity",
        "(<code>std::numeric_limits<float>::epsilon()</code>) and the magnitude of the",
        "numbers being compared.</p>",
        "<p><b>Example</b></p><pre><code language=\"C++\">",
        "// The result of the test in the following code is unpredictable:",
        "float32_t x, y;",
        "if ( x == y )     // Non-compliant",
        "if ( x == 0.0f )  // Non-compliant",
        "// An indirect test is equally problematic and is also prohibited by this rule:",
        "if ( ( x &lt;= y ) && ( x &gt;= y ) )   // Non-compliant",
        "if ( ( x &lt; y ) || ( x &gt; y ) )     // Non-compliant",
        "// The following is better, but only if the magnitudes are appropriate:",
        "if ( fabs ( x - y ) &lt;= std::numeric_limits&lt;float&gt;::epsilon( ) ) //Compliant",
        "</code></pre>"
      ]
    }
  },

  "MISRA08_15-3-6": {
    "tags": ["Language: C", "Language: C++", "Standard: MISRA C++ 2008", "Category: Required", "Exception Handling"],
    "key": "exceptions",
    "name": "Published Standards/MISRA-C++ 2008/15-3-6 Order of Catch Blocks with Derived Classes",
    "desc": {
      "html": [
        "<p>Where multiple handlers are provided in a single <i>try-catch</i> statement or <i>function-try-block</i> for a derived class and some or all of its bases, the handlers shall be ordered most-derived to base class</p>",
        "<p><b>Rationale</b></p>",
        "<p>When testing to see if the type of an exception matches the type of a handler, a derived class exception will match with a handler for its base class. If the base class handler is found before the handler for the derived class, the base class handler will be used. The derived class handler is <i>unreachable code</i> and can never be executed.</p>",
        "<p><b>Example</b></p>",
        "<pre>",
        "1  // classes used for exception handling",
        "2  class B {};",
        "3  class D: public B {};",
        "4  try",
        "5  {",
        "6    //...",
        "7  }",
        "8  catch ( D &d ) // Compliant - Derived class caught before base class",
        "9  {",
        "10   //...",
        "11 }",
        "12 catch ( B &b ) // Compliant - Base class caught after derived class",
        "13 {",
        "14   //...",
        "15 }",
        "16 // Using the classes from above",
        "17 try",
        "18 {",
        "19   //...",
        "20 }",
        "21 catch ( B &b )",
        "22 {",
        "23   //...",
        "24 }",
        "25 catch ( D &d ) // Non-compliant - Derived class will be caught above",
        "26 {",
        "27   // Any code here will be unreachable,",
        "28   // breaking rule 0-1-1",
        "29 }",
        "</pre>"
      ]
    }
  },

  "MISRA04_16.8": {
    "tags": ["Language: C", "Standard: MISRA C 2004", "Category: Required", "Functions"],
    "key": "return-type",
    "name": "Published Standards/MISRA-C 2004/16.8 Always return a value in non-void functions",
    "desc": {
      "html": [
        "<p>Always return a value in non-void functions.</p>",
        "<p>This expression gives the value that the function returns. The absence of a <i>return</i> with an expression leads to undefined behaviour (and the compiler may not give an error).</p>"
      ]
    }
  },
  "MISRA08_8-4-3": {
    "tags": ["Language: C", "Language: C++", "Standard: MISRA C++ 2008", "Category: Required", "Functions"],
    "key": "return-type",
    "name": "Published Standards/MISRA-C++ 2008/8-4-3 Always return a value in non-void functions",
    "desc": {
      "html": [
        "<p>Always return a value in non-void functions.</p>",
        "<p><b>Rationale</b></p>",
        "<p>This expression gives the value that the function returns. The absence of a <i>return</i> with an expression leads to <i>undefined behaviour</i> (and the compiler may not give an error).</p>",
        "<p><b>Exception</b></p>",
        "<p>This rule does not apply if a function exit is due to exception handling (i.e. a <i>throw</i> statement).</p>",
        "<p><b>Example</b></p>",
        "<pre>",
        "int32_t fn1 ( void )",
        "{",
        "} // Non-compliant",
        "int32_t fn3 ( int32_t x )",
        "{",
        "    if ( x &gt; 100 )",
        "    {",
        "        throw 42; // Compliant by exception",
        "    }",
        "    return ( x ); // Compliant",
        "}",
        "</pre>"
      ]
    }
  },
  "MISRA12_2.6": {
    "tags": ["Language: C", "Standard: MISRA C 2012", "Category: Required", "Unnecessary Constructs"],
    "key": "unused-label",
    "name": "Published Standards/MISRA C 2012/2.6 Unused Labels",
    "desc": {
      "html": [
        "<p>A function should not contain unused label declarations</p>",
        "<p><b>Rationale</b></p>",
        "<p>If a label is declared but not used, then it is unclear to a reviewer if the label is redundant or it has been left unused by mistake.</p>",
        "<p><b>Example</b></p>",
        "<pre>",
        "void unused_label ( void )",
        "{",
        "  int16_t x = 6;",
        "label1:              /* Non-compliant */",
        "  use_int16 ( x );",
        "}",
        "</pre>"
      ]
    }
  },
  "MISRA12_8.1": {
    "tags": ["Language: C", "Standard: MISRA C 2012", "Category: Required", "Types"],
    "key": "implicit-int",
    "name": "Published Standards/MISRA C 2012/8.1 Types shall be explicitly specified",
    "desc": {
      "html": [
        "<p>Types shall be explicitly specified</p>",
        "<p><b>Rationale</b></p>",
        "The C90 standard permits types to be omitted in some circumstances, in which case the <i>int</i> type is implicitly specified. Examples of the circumstances in which an implicit <i>int</i> might be used are:",
        "<ul>",
        "<li>Object declarations;</li>",
        "<li>Parameter declarations;</li>",
        "<li>Member declarations;</li>",
        "<li><i>typedef</i> declarations;</li>",
        "<li>Function return types.</li>",
        "</ul>",
        "<p>The omission of an explicit type might lead to confusion. For example, in the declaration:</p>",
        "<pre>",
        "extern void g ( char c, const k );",
        "</pre>",
        "the type of <code>k</code> is <i>const int</i> whereas <i>const char</i> might have been expected.",
        "<p><b>Example</b></p>",
        "<p>The following examples show compliant and non-compliant object declarations:</p>",
        "<pre>",
        "extern         x; /* Non-compliant - implicit int type */",
        "extern int16_t x; /* Compliant - explicit type */",
        "const          y; /* Non-compliant - implicit int type */",
        "const int16_t  y; /* Compliant - explicit type */",
        "</pre>",
        "<p>The following examples show compliant and non-compliant function type declarations:</p>",
        "<pre>",
        "extern f ( void );                         /* Non-compliant - implicit",
        "                                            * int return type */",
        "extern int16_t f ( void );                 /* Compliant */",
        "",
        "extern void g ( char c, const k );         /* Non-compliant - implicit",
        "                                            * int for parameter k */",
        "extern void g ( char c, const int16_t k ); /* Compliant */",
        "</pre>",
        "<p>The following examples show compliant and non-compliant type definitions:</p>",
        "<pre>",
        "typedef ( *pfi ) ( void );           /* Non-compliant - implicit int",
        "                                      * return type */",
        "typedef int16_t ( *pfi ) ( void );   /* Compliant */",
        "typedef void ( *pfv ) ( const x );   /* Non-compliant - implicit int",
        "                                      * for parameter x */",
        "typedef void ( *pfv ) ( int16_t x ); /* Compliant */",
        "</pre>",
        "<p>The following examples show compliant and non-compliant member declarations:</p>",
        "<pre>",
        "struct str",
        "{",
        "  int16_t x; /* Compliant */",
        "  const   y; /* Non-compliant - implicit int for member y */",
        "} s;",
        "</pre>",
        "<p><b>See also</b></p>",
        "<p>Rule 8.2</p>"
      ]
    }
  },

  "MISRA12_8.2": {
    "tags": ["Language: C", "Language: C++", "Standard: MISRA C 2012", "Functions"],
    "keys": ["strict-prototypes", "deprecated-non-prototype", "implicit-int", "sti.UnnamedParameters"],
    "name": "Published Standards/MISRA C 2012/8.2 Use Named Parameters and Prototype Form",
    "desc": {
      "html": [
        "<p><b>Title</b></p>",
        "<p>Function types shall be in <i>prototype form</i> with named parameters.</p>",
        "<p><b>Rationale</b></p>",
        "<p>The early version of C, commonly referred to as K&R C [30], did not provide a mechanism for checking the number of arguments or their types against the corresponding parameters. The type of an object or function did not have to be declared in K&R C since the default type of an object and the default return type of a function was <i>int</i>.</p>",
        "<p>The C90 standard introduced function prototypes, a form of function declarator in which the parameter types were declared. This permitted argument types to be checked against parameter types. It also allowed the number of arguments to be checked except when a function prototype specified that a variable number of arguments was expected. The C90 standard did not <b>require</b> the use of function prototypes for reasons of backward compatibility with existing code. For the same reason, it continued to permit types to be omitted in which case the type would default to <i>int</i>.</p>",
        "<p>The C99 standard removed the default <i>int</i> type from the language but continued to allow K&R-style function types in which there was no means to supply parameter type information in a declaration and it was optional to supply parameter type information in a definition.</p>",
        "<p>The mismatch between the number of arguments and parameters, their types and the expected and actual return type of a function provides potential for undefined behaviour. The purpose of this rule along with Rule 8.1 and Rule 8.4 is to avoid this undefined behaviour by requiring parameter types and function return types to be specified explicitly. Rule 17.3 ensures that this information is available at the time of a function call, thereby requiring the compiler to diagnose any mismatch that is detected.</p>",
        "<p>This rule also requires that names be specified for all the parameters in a declaration. The parameter names can provide useful information regarding the function interface and a mismatch between a declaration and definition might be indicative of a programming error.</p>",
        "<p><i>Note</i>: An empty parameter list is <b>not</b> valid in a prototype. If a function type has no parameters its <i>prototype form</i> uses the keyword <i>void</i>.</p>",
        "<p><b>Example</b></p>",
        "<p>The first example shows declarations of some functions and the corresponding definitions for some of those functions.</p>",
        "<pre><code language=\"C++\">",
        "  /* Compliant                                                  */",
        "  extern int16_t func1 ( int16_t n );",
        "",
        "  /* Non-compliant - parameter name not specified               */",
        "  extern void func2 ( int16_t );",
        "",
        "  /* Non-compliant - not in prototype form                      */",
        "  static int16_t func3 ( );",
        "",
        "  /* Compliant - prototype specifies 0 parameters               */",
        "  static int16_t func4 ( void );",
        "",
        "  /* Compliant                                                  */",
        "  int16_t func1 ( int16_t n )",
        "  {",
        "    return n;",
        "  }",
        "",
        "  /* Non-compliant - old style identifier and declaration list  */",
        "  static int16_t func3 ( vec, n )",
        "  int16_t *vec;",
        "  int16_t n;",
        "  {",
        "    return vec[ n - 1 ];",
        "  }",
        "</code></pre>",
        "<p>This example section shows the application of the rule to function types other than in function declarations and definitions.</p>",
        "<pre><code language=\"C++\">",
        "  /* Non-compliant - no prototype                   */",
        "  int16_t ( *pf1 ) ( );",
        "",
        "  /* Compliant - prototype specifies 0 parameters   */",
        "  int16_t ( *pf1 ) ( void );",
        "",
        "  /* Non-compliant - parameter name not specified   */",
        "  typedef int16_t ( *pf2_t ) ( int16_t );",
        "",
        "  /* Compliant                                      */",
        "  typedef int16_t ( *pf3_t ) ( int16_t n );",
        "</code></pre>"
      ]
    }
  },

  "MISRA12_17.4": {
    "tags": ["Language: C", "Standard: MISRA C 2012", "Category: Required", "Functions"],
    "key": "return-type",
    "name": "Published Standards/MISRA C 2012/17.4 Always return a value in non-void functions",
    "desc": {
      "html": [
        "<p>Always return a value in non-void functions.</p>",
        "<p><b>Rationale</b></p>",
        "<p>",
        "The expression given to the <i>return</i> statement provides the value that the function returns. If a non-<i>void</i> function does not return a value but the calling function uses the returned value, the behaviour is undefined. This can be avoided by ensuring that, in a non-<i>void</i> function:",
        "</p>",
        "<p>",
        "โข Every <i>return</i> statement has an expression, and",
        "</p>",
        "<p>",
        "โข Control cannot reach the end of the function without encountering a <i>return</i> statement.",
        "</p>",
        "<p>",
        "<i>Note</i>: C99 constrains every <i>return</i> statement in a non-<i>void</i> function to return a value.",
        "</p>",
        "<p><b>Example</b></p>",
        "<pre>",
        "int32_t absolute ( int32_t v )",
        "{",
        "  if ( v &lt; 0 )",
        "  {",
        "    return v;",
        "  }",
        "  /*",
        "   * Non-compliant - control can reach this point without",
        "   * returning a value",
        "   */",
        "}",
        "uint16_t lookup ( uint16_t v )",
        "{",
        "  if ( ( v &lt; V_MIN ) || ( v &gt; V_MAX ) )",
        "  {",
        "    /* Non-compliant - no value returned. Constraint in C99 */",
        "    return;",
        "  }",
        "  return table[ v ];",
        "}",
        "</pre>",
        "<p><b>See also</b></p>",
        "<p>",
        "Rule 15.5",
        "</p>"
      ]
    }
  },

  "MISRA12_17.7": {
    "tags": [ "Language: C", "Standard: MISRA C 2012", "Category: Required", "Functions" ],
    "key": "sti.IgnoredReturnValues",
    "name": "Published Standards/MISRA C 2012/17.7 The value returned by a function having non-void return type shall be used",
    "desc": {
      "html": [
        "<p><b>Rationale</b></p>",
        "<p><p>It is possible to call a function without using the return value, which may be an error. If the return value of a function is intended not to be used explicitly, it should be cast to the void type. This has the effect of using the value without violating Rule 2.2.</p></p>",
        "<p><b>Example</b></p>",
        "",
        "<pre> uint16_t func ( uin t16_t para1 )",
        "  {",
        "    return para1;",
        "  }",
        "",
        "  uint16_t x;",
        "  void discarded ( uint16_t para2 )",
        "  {",
        "    func ( para2 ); /* Non-compliant - value discarded */",
        "    ( void ) func ( para2 ); /* Compliant */",
        "    x = func ( para2 ); /* Compliant */",
        "  }",
        "",
        "</pre>",
        "",
        "<p><b>See also</b></p>",
        "<p>Dir 4.7, Rule 2.2</p>"
      ]
    }
  },

  "MISRA23_2.6": {
    "tags": ["Language: C", "Standard: MISRA C 2023", "Category: Required", "Unnecessary Constructs"],
    "key": "unused-label",
    "name": "Published Standards/MISRA C 2023/2.6  A function should not contain unused label declarations",
    "desc": {
      "html": [
        "<p>A function should not contain unused label declarations</p>",
        "<p><b>Rationale</b></p>",
        "<p>If a label is declared but not used, then it is unclear to a reviewer if the label is redundant or it has been left unused by mistake.</p>",
        "<p><b>Example</b></p>",
        "<pre>",
        "void unused_label ( void )",
        "{",
        "  int16_t x = 6;",
        "label1:              /* Non-compliant */",
        "  use_int16 ( x );",
        "}",
        "</pre>"
      ]
    }
  },

  "MISRA23_8.1": {
    "tags": ["Language: C", "Standard: MISRA C 2023", "Category: Required", "Types"],
    "key": "implicit-int",
    "name": "Published Standards/MISRA C 2023/8.1 Types shall be explicitly specified",
    "desc": {
      "html": [
        "<p>Types shall be explicitly specified</p>",
        "<p><b>Rationale</b></p>",
        "The C90 standard permits types to be omitted in some circumstances, in which case the <i>int</i> type is implicitly specified. Examples of the circumstances in which an implicit <i>int</i> might be used are:",
        "<ul>",
        "<li>Object declarations;</li>",
        "<li>Parameter declarations;</li>",
        "<li>Member declarations;</li>",
        "<li><i>typedef</i> declarations;</li>",
        "<li>Function return types.</li>",
        "</ul>",
        "<p>The omission of an explicit type might lead to confusion. For example, in the declaration:</p>",
        "<pre>",
        "extern void g ( char c, const k );",
        "</pre>",
        "the type of <code>k</code> is <i>const int</i> whereas <i>const char</i> might have been expected.",
        "<p><b>Example</b></p>",
        "<p>The following examples show compliant and non-compliant object declarations:</p>",
        "<pre>",
        "extern         x; /* Non-compliant - implicit int type */",
        "extern int16_t x; /* Compliant - explicit type */",
        "const          y; /* Non-compliant - implicit int type */",
        "const int16_t  y; /* Compliant - explicit type */",
        "</pre>",
        "<p>The following examples show compliant and non-compliant function type declarations:</p>",
        "<pre>",
        "extern f ( void );                         /* Non-compliant - implicit",
        "                                            * int return type */",
        "extern int16_t f ( void );                 /* Compliant */",
        "",
        "extern void g ( char c, const k );         /* Non-compliant - implicit",
        "                                            * int for parameter k */",
        "extern void g ( char c, const int16_t k ); /* Compliant */",
        "</pre>",
        "<p>The following examples show compliant and non-compliant type definitions:</p>",
        "<pre>",
        "typedef ( *pfi ) ( void );           /* Non-compliant - implicit int",
        "                                      * return type */",
        "typedef int16_t ( *pfi ) ( void );   /* Compliant */",
        "typedef void ( *pfv ) ( const x );   /* Non-compliant - implicit int",
        "                                      * for parameter x */",
        "typedef void ( *pfv ) ( int16_t x ); /* Compliant */",
        "</pre>",
        "<p>The following examples show compliant and non-compliant member declarations:</p>",
        "<pre>",
        "struct str",
        "{",
        "  int16_t x; /* Compliant */",
        "  const   y; /* Non-compliant - implicit int for member y */",
        "} s;",
        "</pre>",
        "<p><b>See also</b></p>",
        "<p>Rule 8.2</p>"
      ]
    }
  },
  "MISRA23_17.4": {
    "tags": ["Language: C", "Standard: MISRA C 2023", "Category: Required", "Functions"],
    "key": "return-type",
    "name": "Published Standards/MISRA C 2023/17.4 All exit paths from a function with non-void return type shall have an explicit return statement with an expression",
    "desc": {
      "html": [
        "<p>All exit paths from a function with non-void return type shall have an explicit return statement with an expression.</p>",
        "<p><b>Rationale</b></p>",
        "<p>",
        "The expression given to the <i>return</i> statement provides the value that the function returns. If a non-<i>void</i> function does not return a value but the calling function uses the returned value, the behaviour is undefined. This can be avoided by ensuring that, in a non-<i>void</i> function:",
        "</p>",
        "<p>",
        "โข Every <i>return</i> statement has an expression, and",
        "</p>",
        "<p>",
        "โข Control cannot reach the end of the function without encountering a <i>return</i> statement.",
        "</p>",
        "<p>",
        "<i>Note</i>: C99 and later constrain every <i>return</i> statement in a non-<i>void</i> function to return a value.",
        "</p>",
        "<p><b>Exception</b></p>",
        "<p>",
        "For C99 and later, the C Standard specifies that if control reaches the end of main without encountering a return statement, the effect is that of executing return 0. Therefore, for C99 and later, the return statement may be omitted for function main.",
        "</p>",
        "<p><b>Example</b></p>",
        "<pre>",
        "int32_t absolute ( int32_t v )",
        "{",
        "  if ( v &lt; 0 )",
        "  {",
        "    return v;",
        "  }",
        "  /*",
        "   * Non-compliant - control can reach this point without",
        "   * returning a value",
        "   */",
        "}",
        "uint16_t lookup ( uint16_t v )",
        "{",
        "  if ( ( v &lt; V_MIN ) || ( v &gt; V_MAX ) )",
        "  {",
        "    /* Non-compliant - no value returned. Constraint in C99 */",
        "    return;",
        "  }",
        "  return table[ v ];",
        "}",
        "</pre>",
        "<p><b>See also</b></p>",
        "<p>",
        "Rule 15.5",
        "</p>"
      ]
    }
  },

    "MISRA23_17.7": {
    "tags": [ "Language: C", "Standard: MISRA C 2023", "Category: Required", "Functions" ],
    "key": "sti.IgnoredReturnValues",
    "name": "Published Standards/MISRA C 2023/17.7 The value returned by a function having non-void return type shall be used",
    "desc": {
      "html": [
        "<p><b>Rationale</b></p>",
        "<p><p>It is possible to call a function without using the return value, which may be an error. If the return value of a function is intended not to be used explicitly, it should be cast to the void type. This has the effect of using the value without violating Rule 2.2.</p></p>",
        "<p><b>Example</b></p>",
        "",
        "<pre> uint16_t func ( uin t16_t para1 )",
        "  {",
        "    return para1;",
        "  }",
        "",
        "  uint16_t x;",
        "  void discarded ( uint16_t para2 )",
        "  {",
        "    func ( para2 ); /* Non-compliant - value discarded */",
        "    ( void ) func ( para2 ); /* Compliant */",
        "    x = func ( para2 ); /* Compliant */",
        "  }",
        "",
        "</pre>",
        "",
        "<p><b>See also</b></p>",
        "<p>Dir 4.7, Rule 2.2</p>"
      ]
    }
  },

  "MISRA23_8.2.7": {
    "tags": ["Language: C", "Language: C++", "Standard: MISRA C++ 2023", "Category: Advisory", "Pointers"],
    "key": "sti.PointerToIntCast",
    "name": "Published Standards/MISRA C++ 2023/8.2.7 Pointer to Integer Cast",
    "desc": {
      "html": [
        "<p><b>Rationale</b></p>",
        "<p>Casting between a pointer and an integer type makes it harder for tools and developers to understand and reason about code behaviour. For example, pointer tracking within tools may become unreliable when pointers are cast to integers.</p>",
        "<p><i>Note</i>: casting between pointers and integers may be unavoidable when addressing memory mapped registers or other hardware specific features. When the advice given in this rule is not followed, the use of <code>std::uintptr_t</code> or <code>std::intptr_t</code> is required by Rule 8.2.8 as these types are guaranteed to be able to represent all possible pointer values.</p>",
        "",
        "<p><b>Example</b></p>",
        "<p>The following examples violate Rule 8.2.5, with the second also violating Rule 8.2.8:</p>",
        "<pre><code language=\"C++\">struct S;",
        "",
        "void f( S * s )",
        "{",
        "  std::intptr_t p = reinterpret_cast&lt; std::intptr_t &gt;( s );   // Non-compliant",
        "  std::uint8_t  q = reinterpret_cast&lt; std::uint8_t  &gt;( s );   // Non-compliant",
        "}",
        "</code></pre>",
        "",
        "<p><b>See also</b></p>",
        "<p>Rule 8.2.5, Rule 8.2.8</p>"
      ]
    }
  },

  "MISRA23_9.6.4": {
    "tags": ["Language: C", "Language: C++", "Standard: MISRA C++ 2023", "Category: Required", "Functions"],
    "key": "invalid-noreturn",
    "name": "Published Standards/MISRA C++ 2023/9.6.4 A function declared with the [[noreturn]] attribute shall not return",
    "desc": {
      "html": [
        "<p><b>Amplification</b></p>",
        "<p>",
        "Leaving a function as the result of an exception is not a return.",
        "</p>",
        "<p>",
        "A functionโs compliance with this rule is determined independently of the context in which the function is called. For example, a Boolean parameter is treated as if it may have a value of true or false, even if all the calls expressed in the current program use a value of true.",
        "</p>",
        "<p><b>Rationale</b></p>",
        "<p>",
        "Returning from a function declared as [[noreturn]] results in undefined behaviour.",
        "</p>",
        "<p>",
        "Note: a function may be declared as [[noreturn]] when:",
        "</p>",
        "<p>",
        "1. It only exits by throwing an exception; or",
        "</p>",
        "<p>",
        "2. It loops endlessly; or",
        "</p>",
        "<p>",
        "3. It causes program termination.",
        "</p>",
        "</p>",
        "<p><b>Example</b></p>",
        "<pre>",
        "[[noreturn]] void kill_the_process() // Compliant",
        "{",
        " std::abort(); // Note - std::abort is also [[noreturn]]",
        "}",
        "[[noreturn]] void throw_some() // Compliant - only exits with an exception",
        "{",
        " throw 42;",
        "}",
        "[[noreturn]] void g( bool b ) // Non-compliant - returns if 'b' is false",
        "{",
        " if ( b )",
        " {",
        "   throw std::exception{};",
        " }",
        "}",
        "</pre>",
        "<p><b>See also</b></p>",
        "<p>",
        "Rule 6.2.2",
        "</p>"
      ]
    }
  },
  "MISRA23_9.6.5": {
    "tags": ["Language: C", "Language: C++", "Standard: MISRA C++ 2023", "Category: Required", "Functions"],
    "key": "return-type",
    "name": "Published Standards/MISRA C++ 2023/9.6.5 A function with non-void return type shall return a value on all paths",
    "desc": {
      "html": [
        "<p><b>Amplification</b></p>",
        "<p>",
        "The compound statement of a lambda expression with a non-void return type is also considered to be a function covered by this rule.",
        "</p>",
        "<p>",
        "A return is not required after an explicit throw or after calling a function marked [[noreturn]].",
        "</p>",
        "<p>",
        "This rule does not apply to main, as it implicitly returns 0 if an exit path does not explicitly return a value.",
        "</p>",
        "<p>",
        "Note: flowing off the end of a function body, except within main, is equivalent to a return with no operand.",
        "</p>",
        "<p><b>Rationale</b></p>",
        "<p>",
        "The operand to return gives the value that the function returns. The absence of a return with an operand in an execution path through a function with a non-void return type results in undefined behaviour.",
        "</p>",
        "<p><b>Example</b></p>",
        "<pre>",
        "int32_t fn1() // Non-compliant",
        "{",
        "  // No return",
        "}",
        "int32_t fn2( int32_t x ) // Compliant",
        "{",
        " if ( x > 100 )",
        " {",
        "   throw 42; // Exiting via an exception",
        "  }",
        " else",
        " {",
        "   return x; // Value returned on other path",
        " }",
        "}",
        "</pre>"
      ]
    }
  },

  "MISRA23_8.2": {
    "tags": ["Language: C", "Language: C++", "Standard: MISRA C 2023", "Category: Required", "Functions"],
    "keys": ["strict-prototypes", "deprecated-non-prototype", "implicit-int", "sti.UnnamedParameters"],
    "name": "Published Standards/MISRA C 2023/8.2 Use Named Parameters and Prototype Form",
    "desc": {
      "html": [
        "<p><b>Title</b></p>",
        "<p>Function types shall be in <i>prototype form</i> with named parameters.</p>",
        "<p><b>Rationale</b></p>",
        "<p>The early version of C, commonly referred to as K&R C [30], did not provide a mechanism for checking the number of arguments or their types against the corresponding parameters. The type of an object or function did not have to be declared in K&R C since the default type of an object and the default return type of a function was <i>int</i>.</p>",
        "<p>The C90 standard introduced function prototypes, a form of function declarator in which the parameter types were declared. This permitted argument types to be checked against parameter types. It also allowed the number of arguments to be checked except when a function prototype specified that a variable number of arguments was expected. The C90 standard did not <b>require</b> the use of function prototypes for reasons of backward compatibility with existing code. For the same reason, it continued to permit types to be omitted in which case the type would default to <i>int</i>.</p>",
        "<p>The C99 standard removed the default <i>int</i> type from the language but continued to allow K&R-style function types in which there was no means to supply parameter type information in a declaration and it was optional to supply parameter type information in a definition.</p>",
        "<p>The mismatch between the number of arguments and parameters, their types and the expected and actual return type of a function provides potential for undefined behaviour. The purpose of this rule along with Rule 8.1 and Rule 8.4 is to avoid this undefined behaviour by requiring parameter types and function return types to be specified explicitly. Rule 17.3 ensures that this information is available at the time of a function call, thereby requiring the compiler to diagnose any mismatch that is detected.</p>",
        "<p>This rule also requires that names be specified for all the parameters in a declaration. The parameter names can provide useful information regarding the function interface and a mismatch between a declaration and definition might be indicative of a programming error.</p>",
        "<p><i>Note</i>: An empty parameter list is <b>not</b> valid in a prototype. If a function type has no parameters its <i>prototype form</i> uses the keyword <i>void</i>.</p>",
        "<p><b>Example</b></p>",
        "<p>The first example shows declarations of some functions and the corresponding definitions for some of those functions.</p>",
        "<pre><code language=\"C++\">",
        "  /* Compliant                                                  */",
        "  extern int16_t func1 ( int16_t n );",
        "",
        "  /* Non-compliant - parameter name not specified               */",
        "  extern void func2 ( int16_t );",
        "",
        "  /* Non-compliant - not in prototype form                      */",
        "  static int16_t func3 ( );",
        "",
        "  /* Compliant - prototype specifies 0 parameters               */",
        "  static int16_t func4 ( void );",
        "",
        "  /* Compliant                                                  */",
        "  int16_t func1 ( int16_t n )",
        "  {",
        "    return n;",
        "  }",
        "",
        "  /* Non-compliant - old style identifier and declaration list  */",
        "  static int16_t func3 ( vec, n )",
        "  int16_t *vec;",
        "  int16_t n;",
        "  {",
        "    return vec[ n - 1 ];",
        "  }",
        "</code></pre>",
        "<p>This example section shows the application of the rule to function types other than in function declarations and definitions.</p>",
        "<pre><code language=\"C++\">",
        "  /* Non-compliant - no prototype                   */",
        "  int16_t ( *pf1 ) ( );",
        "",
        "  /* Compliant - prototype specifies 0 parameters   */",
        "  int16_t ( *pf1 ) ( void );",
        "",
        "  /* Non-compliant - parameter name not specified   */",
        "  typedef int16_t ( *pf2_t ) ( int16_t );",
        "",
        "  /* Compliant                                      */",
        "  typedef int16_t ( *pf3_t ) ( int16_t n );",
        "</code></pre>"
      ]
    }
  },

  "MISRA23_0.1.2": {
    "tags": [ "Language: C", "Language: C++", "Standard: MISRA C++ 2023", "Category: Required", "Functions" ],
    "key": "sti.IgnoredReturnValues",
    "name": "Published Standards/MISRA C++ 2023/0.1.2 The value returned by a function shall be used",
    "desc": {
      "html": [
        "<p><b>Amplification</b></p>",
        "<p>This rule only applies when the function is called explicitly using function call syntax.</p>",
        "",
        "<p><b>Rationale</b></p>",
        "<p>It is possible to call a function without using the return value, which may be an error. If the return value of a function is intended to be explicitly discarded, it should be cast to void to ensure that it is used.</p>",
        "<p>Overloaded operators are excluded from this requirement, as they should behave in the same way as built-in operators.</p>",
        "<p>Note: this rule effectively requires all non-void functions to be treated as if they were declared [[nodiscard]].</p>",
        "",
        "<p><b>Example</b></p>",
        "<pre>uint16_t func();",
        "void discarded()",
        "{",
        " func(); // Non-compliant - implicitly discarded",
        " ( void )func(); // Compliant - void cast is a use",
        " auto b = func(); // Compliant - used as initializer",
        "}",
        "",
        "void f1( std::string q )",
        "{",
        " std::string s { q } ; // Rule does not apply - not function call syntax",
        " s = q; // Rule does not apply - not function call syntax",
        " s.operator=( q ); // Non-compliant",
        "}",
        "",
        "void f2( std::function< int() > & f )",
        "{",
        " f(); // Non-compliant - using function call syntax",
        " auto a = []() { return 10; };",
        " a(); // Non-compliant - using function call syntax",
        "}",
        "</pre>",
        "",
        "<p><b>See also</b></p>",
        "<p>Rule 28.6.4</p>"
      ]
    }
  },

  "MISRA23_0.2.1": {
    "tags": ["Language: C", "Language: C++", "Standard: MISRA C++ 2023", "Category: Advisory", "Variables"],
    "keys": ["unused-variable","unused-const-variable"],
    "name": "Published Standards/MISRA C++ 2023/0.2.1 Variables with limited visibility should be used at least once",
    "desc": {
      "text": "Check for variables that are unused (C, C++, ObjC)",
      "html": [
        "<p><b>Amplification</b></p>",
        "<p>",
        "A variable has limited visibility if it is not a function parameter, and it has internal linkage or no linkage.",
        "</p>",
        "<p>",
        "A variable is used when:",
        "</p>",
        "<p>",
        "1. It is part of an id-expression; or",
        "</p>",
        "<p>",
        "2. The variable is of class type and has a user-provided constructor or a user-provided destructor.",
        "</p>",
        "<p><b>Rationale</b></p>",
        "<p>",
        "Variables that are declared and never used within a project do not contribute to program output; they constitute noise and may indicate that the wrong variable name has been used or that one or more statements are missing.",
        "</p>",
        "<p>",
        "Note: this rule allows the introduction of variables for the sole purpose of providing scoped resource allocation and release. For example: ",
        "</p>",
        "<pre>",
        "{",
        "  std::lock_guard< std::mutex > lock { mutex }; // Compliant - has user-provided constructor",
        "  // ...",
        "} // User-provided destructor implicitly called here",
        "</pre>",
        "<p><b>Exception</b></p>",
        "<p>",
        "This rule does not apply to:",
        "</p>",
        "<p>",
        "1. Variables that have at least one declaration with the [[maybe_unused]] attribute.",
        "</p>",
        "<p>",
        "2. Constant variables at namespace scope that are declared within a header file.",
        "</p>",
        "<p><b>Example</b></p>",
        "<pre>",
        "class C { }; // No user-provided constructor or destructor",
        "namespace",
        "{",
        " C c; // Non-compliant - unused",
        "}",
        "void maybeUnused( int32_t a )",
        "{",
        " [[maybe_unused]]",
        " bool b = a > 0; // Compliant (by exception #1 if NDEBUG is defined)",
        " assert( b ); // Does not use b if NDEBUG is defined",
        " usefn( a );",
        "}",
        "const int16_t x = 19; // Compliant - x is read in initializedButNotUsed",
        "const int16_t y = 21; // Non-compliant - would be compliant by exception #2",
        " // if declared in a header file",
        "void initializedButNotUsed()",
        "{",
        " int16_t local_1 = 42; // Non-compliant - local_1 is never read",
        " int16_t local_2; // Compliant",
        " local_2 = x; // Use of local_2 for the purposes of this rule",
        "}",
        "void userProvidedCtor()",
        "{",
        "  std::ifstream fs { 'cfg.ini' }; // Compliant - user-provided constructor",
        "}",
        "</pre>",
        "<p><b>See also</b></p>",
        "<p>Rule 0.2.2</p>"
      ]
    }
  },
  "MISRA23_18.5.2": {
    "tags": ["Language: C", "Language: C++", "Standard: MISRA C++ 2023", "Category: Advisory", "Control Flow"],
    "keys": ["sti.AbruptlyTerminate","exceptions"],
    "name": "Published Standards/MISRA C++ 2023/18.5.2 Program-terminating functions should not be used",
    "desc": {
      "text": "Abrupt",
      "html": [
        "<p><b>Amplification</b></p>",
        "<p>A program should not contain calls to the C++ Standard Library functions abort, exit, _Exit, quick_exit or terminate.</p>",
        "<p>Additionally, the address of any of these functions should not be taken.</p>",
        "<p><b>Rationale</b></p>",
        "<p>If a program terminates due to a call to any of the functions listed above, then the stack will not be unwound and object destructors will not be called.</p>",
        "<p>This will potentially leave the environment in an undesirable state (e.g. a file permanently locked).</p>",
        "<p>Taking the address of the functions is not recommended to prevent them from being called via a function pointer.</p>",
        "<p>Notes:</p>",
        "<p>This rule only covers explicit calls to the termination functions.</p>",
        "<p>The majority of ways in which they may be called implicitly are prevented by Rule 18.1.2, Rule 18.3.1 and Rule 18.5.1.</p>",
        "<p>This rule aims to prevent program-terminating functions from being called without the system level implications (such as unreleased resources) being duly considered.</p>",
        "<p>If the safety architecture requires rapid termination on the detection of an error, then it may be appropriate to disapply this rule.</p>",
        "<p><b>Exception</b></p>",
        "<p>The call to abort that occurs due to the macro expansion of assert is not considered to be an explicit call, as it is not expected to be reachable.</p>",
        "<p>Note: a project may consider disallowing this exception if the behaviour of abort is not a suitable response to a failed assertion, such as when there is no external mechanism to recover the terminated program.</p>",
        "<p><b>See also</b></p>",
        "<p>Rule 18.1.2, Rule 18.3.1, Rule 18.5.1</p>"
      ]
    }
  },
  "MISRA23_21.8": {
    "tags": ["Language: C", "Language: C++", "Standard: MISRA C 2023", "Category: Required", "Control Flow"],
    "keys": ["sti.AbruptlyTerminate","exceptions"],
    "name": "Published Standards/MISRA C 2023/21.8 The Standard Library termination functions of <stdlib.h> shall not be used",
    "desc": {
      "text": "Abrupt",
      "html": [
        "<p><b>Amplification</b></p>",
        "<p>The termination functions are abort, exit, _Exit and quick_exit.</p>",
        "<p>Identifiers with these names shall not be used and no macro with one of these names shall be expanded.</p>",
        "<p><b>Rationale</b></p>",
        "<p>These functions have undefined and implementation-defined behaviours associated with them.</p>"
      ]
    }
  },
  "MISRA12_10.5": {
    "tags": ["Language: C", "Standard: MISRA C 2012", "Category: Advisory", "Types"],
    "key": "sti.CastToInappropriateType",
    "name": "Published Standards/MISRA C 2012/10.5 The value of an expression should not be cast to an inappropriate essential type",
    "desc": {
      "html": [
        "<p><b>Amplification</b></p>",
        "<p>The casts which should be avoided are shown in the following table, where values are cast (explicitly converted) to the essential type category of the first column.</p>",
        "<table>",
        "<tr>",
        "<th>Essential type category</th>",
        "<th></th>",
        "<th></th>",
        "<th></th>",
        "<th>from</th>",
        "<th></th>",
        "<th></th>",
        "</tr>",
        "<tr>",
        "<th>to</th>",
        "<th>Boolean</th>",
        "<th>character</th>",
        "<th>enum</th>",
        "<th>signed</th>",
        "<th>unsigned</th>",
        "<th>floating</th>",
        "</tr>",
        "<tr>",
        "<th>Boolean</th>",
        "<th></th>",
        "<th>Avoid</th>",
        "<th>Avoid</th>",
        "<th>Avoid</th>",
        "<th>Avoid</th>",
        "<th>Avoid</th>",
        "</tr>",
        "<tr>",
        "<th>character</th>",
        "<th>Avoid</th>",
        "<th></th>",
        "<th></th>",
        "<th></th>",
        "<th></th>",
        "<th>Avoid</th>",
        "</tr>",
        "<tr>",
        "<th>enum</th>",
        "<th>Avoid</th>",
        "<th>Avoid</th>",
        "<th>Avoid</th>",
        "<th>Avoid*</th>",
        "<th>Avoid</th>",
        "<th>Avoid</th>",
        "</tr>",
        "<tr>",
        "<th>signed</th>",
        "<th>Avoid</th>",
        "<th></th>",
        "<th></th>",
        "<th></th>",
        "<th></th>",
        "<th></th>",
        "</tr>",
        "<tr>",
        "<th>unsigned</th>",
        "<th>Avoid</th>",
        "<th></th>",
        "<th></th>",
        "<th></th>",
        "<th></th>",
        "<th></th>",
        "</tr>",
        "<tr>",
        "<th>floating</th>",
        "<th>Avoid</th>",
        "<th>Avoid</th>",
        "<th></th>",
        "<th></th>",
        "<th></th>",
        "<th></th>",
        "</tr>",
        "</table>",
        "<p>* Note: an enumerated type may be cast to an enumerated type provided that the cast is to the same essential enumerated type. Such casts are redundant.</p>",
        "<p>Casting from void to any other type is not permitted as it results in undefined behaviour. This is covered by Rule 1.3.</p>",
        "<p><b>Rationale</b></p>",
        "<p>An explicit cast may be introduced for legitimate functional reasons, for example:</p>",
        "<ul>",
        "<li>To change the type in which a subsequent arithmetic operation is performed;</li>",
        "<li>To truncate a value deliberately;</li>",
        "<li>To make a type conversion explicit in the interests of clarity.</li>",
        "</ul>",
        "<p>However, some explicit casts are considered inappropriate:</p>",
        "<ul>",
        "<li>In C99, the result of a cast or assignment to _Bool is always 0 or 1. This is not necessarily the case when casting to another type which is defined as essentially Boolean;</li>",
        "<li>A cast to an essentially enum type may result in a value that does not lie within the set of enumeration constants for that type;</li>",
        "<li>A cast from essentially Boolean to any other type is unlikely to be meaningful;</li>",
        "<li>Converting between floating and character types is not meaningful as there is no precise mapping between the two representations.</li>",
        "</ul>",
        "<p><b>Exception</b></p>",
        "<p>An integer constant expression with the value 0 or 1 of either signedness may be cast to a type which is defined as essentially Boolean. This allows the implementation of non-C99 Boolean models.</p>",
        "<p><b>Example</b></p>",
        "<pre><code language=\"C++\">( bool_t ) false /* Compliant - C99 'false' is essentially Boolean */",
        "( int32_t ) 3U /* Compliant */",
        "( bool_t ) 0 /* Compliant - by exception */",
        "( bool_t ) 3U /* Non-compliant */",
        "( int32_t ) ena /* Compliant */",
        "( enum enuma ) 3 /* Non-compliant */",
        "( char ) enc /* Compliant */",
        "</code></pre>"
      ]
    }
  },
  "MISRA23_10.5": {
    "tags": ["Language: C", "Standard: MISRA C 2023", "Category: Advisory", "Types"],
    "key": "sti.CastToInappropriateType",
    "name": "Published Standards/MISRA C 2023/10.5 The value of an expression should not be cast to an inappropriate essential type",
    "desc": {
      "html": [
        "<p><b>Amplification</b></p>",
        "<p>The casts which should be avoided are shown in the following table, where values are cast (explicitly converted) to the essential type category of the first column.</p>",
        "<table>",
        "<tr>",
        "<th>Essential type category</th>",
        "<th></th>",
        "<th></th>",
        "<th></th>",
        "<th>from</th>",
        "<th></th>",
        "<th></th>",
        "</tr>",
        "<tr>",
        "<th>to</th>",
        "<th>Boolean</th>",
        "<th>character</th>",
        "<th>enum</th>",
        "<th>signed</th>",
        "<th>unsigned</th>",
        "<th>floating</th>",
        "</tr>",
        "<tr>",
        "<th>Boolean</th>",
        "<th></th>",
        "<th>Avoid</th>",
        "<th>Avoid</th>",
        "<th>Avoid</th>",
        "<th>Avoid</th>",
        "<th>Avoid</th>",
        "</tr>",
        "<tr>",
        "<th>character</th>",
        "<th>Avoid</th>",
        "<th></th>",
        "<th></th>",
        "<th></th>",
        "<th></th>",
        "<th>Avoid</th>",
        "</tr>",
        "<tr>",
        "<th>enum</th>",
        "<th>Avoid</th>",
        "<th>Avoid</th>",
        "<th>Avoid</th>",
        "<th>Avoid*</th>",
        "<th>Avoid</th>",
        "<th>Avoid</th>",
        "</tr>",
        "<tr>",
        "<th>signed</th>",
        "<th>Avoid</th>",
        "<th></th>",
        "<th></th>",
        "<th></th>",
        "<th></th>",
        "<th></th>",
        "</tr>",
        "<tr>",
        "<th>unsigned</th>",
        "<th>Avoid</th>",
        "<th></th>",
        "<th></th>",
        "<th></th>",
        "<th></th>",
        "<th></th>",
        "</tr>",
        "<tr>",
        "<th>floating</th>",
        "<th>Avoid</th>",
        "<th>Avoid</th>",
        "<th></th>",
        "<th></th>",
        "<th></th>",
        "<th></th>",
        "</tr>",
        "</table>",
        "<p>* Note: an enumerated type may be cast to an enumerated type provided that the cast is to the same essential enumerated type. Such casts are redundant.</p>",
        "<p>Casting from void to any other type is not permitted as it results in undefined behaviour. This is covered by Rule 1.3.</p>",
        "<p><b>Rationale</b></p>",
        "<p>An explicit cast may be introduced for legitimate functional reasons, for example:</p>",
        "<ul>",
        "<li>To change the type in which a subsequent arithmetic operation is performed;</li>",
        "<li>To truncate a value deliberately;</li>",
        "<li>To make a type conversion explicit in the interests of clarity.</li>",
        "</ul>",
        "<p>However, some explicit casts are considered inappropriate:</p>",
        "<ul>",
        "<li>In C99, the result of a cast or assignment to _Bool is always 0 or 1. This is not necessarily the case when casting to another type which is defined as essentially Boolean;</li>",
        "<li>A cast to an essentially enum type may result in a value that does not lie within the set of enumeration constants for that type;</li>",
        "<li>A cast from essentially Boolean to any other type is unlikely to be meaningful;</li>",
        "<li>Converting between floating and character types is not meaningful as there is no precise mapping between the two representations.</li>",
        "</ul>",
        "<p><b>Exception</b></p>",
        "<p>An integer constant expression with the value 0 or 1 of either signedness may be cast to a type which is defined as essentially Boolean. This allows the implementation of non-C99 Boolean models.</p>",
        "<p><b>Example</b></p>",
        "<pre><code language=\"C++\">( bool_t ) false /* Compliant - C99 'false' is essentially Boolean */",
        "( int32_t ) 3U /* Compliant */",
        "( bool_t ) 0 /* Compliant - by exception */",
        "( bool_t ) 3U /* Non-compliant */",
        "( int32_t ) ena /* Compliant */",
        "( enum enuma ) 3 /* Non-compliant */",
        "( char ) enc /* Compliant */",
        "</code></pre>"
      ]
    }
  },
   "MISRA12_12.3": {
    "tags": ["Language: C", "Language: C++", "Standard: MISRA C 2012", "Category: Advisory", "Expressions"],
    "key": "comma",
    "name": "Published Standards/MISRA C 2012/12.3 The comma operator shall not be used.",
    "desc": {
      "html": [
        "<p><b>Rationale</b></p>",
        "<p>The comma operator (represented by the token , ) is a binary operator that evaluates its first operand and discards the result, it then evaluates the second operand and returns this value (and type). The comma operator has the lowest precedence of any C operator, and acts as a sequence point.</p>",
        "<p>Use of the comma operator is generally detrimental to the readability of code, and the same effect can be achieved by other means.</p>",
        "<p><b>Example</b></p>",
        "<pre><code language=\"C++\">f ( ( 1, 2 ), 3 ); // Non-compliant โ how many parameters?</code></pre>"
      ]
    }
  },
   "MISRA23_12.3": {
    "tags": ["Language: C", "Language: C++", "Standard: MISRA C 2023", "Category: Advisory", "Expressions"],
    "key": "comma",
    "name": "Published Standards/MISRA C 2023/12.3 The comma operator shall not be used.",
    "desc": {
      "html": [
        "<p><b>Rationale</b></p>",
        "<p>The comma operator (represented by the token , ) is a binary operator that evaluates its first operand and discards the result, it then evaluates the second operand and returns this value (and type). The comma operator has the lowest precedence of any C operator, and acts as a sequence point.</p>",
        "<p>Use of the comma operator is generally detrimental to the readability of code, and the same effect can be achieved by other means.</p>",
        "<p><b>Example</b></p>",
        "<pre><code language=\"C++\">f ( ( 1, 2 ), 3 ); // Non-compliant โ how many parameters?</code></pre>"
      ]
    }
  },
   "MISRA23_8.19.1": {
    "tags": ["Language: C", "Language: C++", "Standard: MISRA C++ 2023", "Category: Advisory", "Expressions"],
    "key": "comma",
    "name": "Published Standards/MISRA C++ 2023/8.19.1 The comma operator shall not be used.",
    "desc": {
      "html": [
        "<p><b>Rationale</b></p>",
        "<p>The comma operator (represented by the token , ) is a binary operator that evaluates its first operand and discards the result, it then evaluates the second operand and returns this value (and type). The comma operator has the lowest precedence of any C operator, and acts as a sequence point.</p>",
        "<p>Use of the comma operator is generally detrimental to the readability of code, and the same effect can be achieved by other means.</p>",
        "<p><b>Example</b></p>",
        "<pre><code language=\"C++\">f ( ( 1, 2 ), 3 ); // Non-compliant โ how many parameters?</code></pre>"
      ]
    }
  }
}
