{
  "ARR39-C": {
    "tags": ["Language: C", "Standard: SEI CERT C", "Standard:", "Severity: 75", "Likelihood: Probable", "Remediation Cost: High", "Priority: P6", "Level: L2", "Expressions"],
    "key": "sti.ScaledPointerArithmetic",
    "name": "Published Standards/SEI Cert Standards/C/Do not add or subtract a scaled integer to a pointer",
    "desc": {
      "html": [
        "<p>Do not add or subtract a scaled integer to a pointer</p>",
        "<p><b>Risk Assessment</b></p>",
        "<p>Failure to understand and properly use pointer arithmetic can allow an attacker to execute arbitrary code.</p>",
        "<p>For the full standard:<i>https://wiki.sei.cmu.edu/confluence/display/c/ARR39-C.+Do+not+add+or+subtract+a+scaled+integer+to+a+pointer</i></p>",
        "<p><b>Exceptions</b></p>",
        "<p>Adding an array pointer to the number of array elements, for example, by using the <code>arr[sizeof(arr)/sizeof(arr[0])]</code> idiom, is allowed provided that <code>arr</code> refers to an array and not a pointer.</p>",
        "<p><b>Noncompliant Code Example</b></p>",
        "<pre>",
        "enum { INTBUFSIZE = 80 };",
        "",
        "extern int getdata(void);",
        "int buf[INTBUFSIZE];",
        "",
        "void func(void) {",
        "  int *buf_ptr = buf;",
        "",
        "  while (buf_ptr &lt; (buf + sizeof(buf))) {",
        "    *buf_ptr++ = getdata();",
        "  }",
        "}",
        "</pre>",
        "<p><b>Developer's Notes</b></p><p>In addition to <code>char</code> pointers, <code>void</code> pointers are also allowed because they do not scale added/subtracted integers. In addition to <code>sizeof</code> and <code>offsetof</code>, <code>_Alignof</code> is also not allowed because it scales. Interpretation of the division exception: if the addition/subtraction operand has a divisor and the divisor has a scaled integer, then the entire addition/subtraction operand will be allowed.</p>"
      ]
    }
  },

  "CON54-CPP": {
    "tags": ["Language: C", "Language: C++", "Standard: SEI CERT C++", "Severity: 50", "Likelihood: Unlikely", "Remediation Cost: Medium", "Priority: P2", "Level: L3", "Threads"],
    "key": "cert-con54-cpp",
    "name": "Published Standards/SEI Cert Standards/C++/Wrap functions that can spuriously wake up in a loop",
    "desc": {
      "html": [
        "<p>Wrap functions that can spuriously wake up in a loop</p>",
        "<p><b>Risk Assessment</b></p>",
        "<p>Failure to enclose calls to the wait(), wait_for(), or wait_until() member functions inside a while loop can lead to indefinite blocking and denial of service (DoS).</p>",
        "<p>For the full standard: <i>https://wiki.sei.cmu.edu/confluence/display/cplusplus/CON54-CPP.+Wrap+functions+that+can+spuriously+wake+up+in+a+loop</i></p>",
        "<p><b>Noncompliant Code Example</b></p>",
        "<pre>",
        "#include <condition_variable>",
        "#include <mutex>",
        "",
        "struct Node {",
        "  void *node;",
        "  struct Node *next;",
        "};",
        "",
        "static Node list;",
        "static std::mutex m;",
        "static std::condition_variable condition;",
        "",
        "void consume_list_element(std::condition_variable &condition) {",
        "  std::unique_lock<std::mutex> lk(m);",
        "",
        "  if (list.next == nullptr) {",
        "    condition.wait(lk);",
        "  }",
        "",
        "  // Proceed when condition holds.",
        "}",
        "</pre>",
        "<p><b>Developer's Notes</b></p><p>This check is automatically implemented with clang-tidy.</p>"
      ]
    }
  },

  "DCL30-C-B": {
    "tags": ["Language: C", "Standard: SEI CERT C", "Standard:", "Severity: 75", "Likelihood: Probable", "Remediation Cost: High", "Priority: P6", "Level: L2", "Declarations and Definitions"],
    "key": "return-stack-address",
    "name": "Published Standards/SEI Cert Standards/C/Declare objects with appropriate storage durations - returning addresses",
    "desc": {
      "html": [
        "<p>Declare objects with appropriate storage durations</p>",
        "<p><b>Risk Assessment</b></p>",
        "<p>Referencing an object outside of its lifetime can result in an attacker being able to execute arbitrary code.</p>",
        "<p>For the full standard: <i>https://wiki.sei.cmu.edu/confluence/display/c/DCL30-C.+Declare+objects+with+appropriate+storage+durations</i></p>",
        "<p><b>Noncompliant Code Example</b></p>",
        "<pre>",
        "#include &lt;stdio.h&gt;",
        "",
        "const char *p;",
        "void dont_do_this(void) {",
        "  const char c_str[] = \"This will change\";",
        "  p = c_str; /* Dangerous */",
        "}",
        "",
        "void innocuous(void) {",
        "  printf(\"%s\\n\", p);",
        "}",
        "",
        "int main(void) {",
        "  dont_do_this();",
        "  innocuous();",
        "  return 0;",
        "}",
        "",
        "char *init_array(void) {",
        "  char array[10];",
        "  /* Initialize array */",
        "  return array;",
        "}",
        "",
        "",
        "void squirrel_away(char **ptr_param) {",
        "  char local[10];",
        "  /* Initialize array */",
        "  *ptr_param = local;",
        "}",
        "",
        "void rodent(void) {",
        "  char *ptr;",
        "  squirrel_away(&ptr);",
        "  /* ptr is live but invalid here */",
        "}",

        "</pre>"
      ]
    }
  },

  "DCL41-C": {
    "tags": ["Language: C", "Standard: SEI CERT C", "Standard:", "Severity: 50", "Likelihood: Unlikely", "Remediation Cost: Medium", "Priority: P4", "Level: L3", "Variables"],
    "key": "unreachable-code",
    "name": "Published Standards/SEI Cert Standards/C/Do not declare variables inside a switch statement before the first case label",
    "desc": {
      "html": [
        "<p>Do not declare variables inside a switch statement before the first case label</p>",
        "<p><b>Risk Assessment</b></p>",
        "<p>Using test conditions or initializing variables before the first case statement in a <code>switch</code> block can result in unexpected behavior and undefined behavior.</p>",
        "<p>For the full standard: <i>https://wiki.sei.cmu.edu/confluence/display/c/DCL41-C.+Do+not+declare+variables+inside+a+switch+statement+before+the+first+case+label</i></p>",
        "<p><b>Noncompliant Code Example</b></p>",
        "<pre>",
        "#include &lt;stdio.h&gt;",
        "",
        "extern void f(int i);",
        "",
        "void func(int expr) {",
        "  switch (expr) {",
        "    int i = 4;",
        "    f(i);",
        "  case 0:",
        "    i = 17;",
        "    /* Falls through into default code */",
        "  default:",
        "    printf(\"%d\\n\", i);",
        "  }",
        "}",
        "</pre>"
      ]
    }
  },

  "DCL50-CPP": {
    "tags": ["Language: C", "Language: C++", "Standard: SEI CERT C++", "Severity: 75", "Likelihood: Probable", "Remediation Cost: Medium", "Priority: P12", "Level: L1", "Declarations and Definitions"],
    "key": "cert-dcl50-cpp",
    "name": "Published Standards/SEI Cert Standards/C++/Do not define a C-style variadic function",
    "desc": {
      "html": [
        "<p><b>Title</b></p>",
        "<p>Do not define a C-style variadic function</p>",
        "<p><b>Risk Assessment</b></p>",
        "<p>Incorrectly using a variadic function can result in abnormal program termination, unintended information disclosure, or execution of arbitrary code.</p>",
        "<p><b>Full Standard</b></p>",
        "<p><a href='https://wiki.sei.cmu.edu/confluence/display/cplusplus/DCL50-CPP.+Do+not+define+a+C-style+variadic+function'>https://wiki.sei.cmu.edu/confluence/display/cplusplus/DCL50-CPP.+Do+not+define+a+C-style+variadic+function</a></p>",
        "<p><b>Exceptions</b></p>",
        "<p>DCL50-CPP-EX1: It is permissible to define a C-style variadic function if that function also has external C language linkage. For instance, the function may be a definition used in a C library API that is implemented in C++.</p>",
        "<p>DCL50-CPP-EX2: As stated in the normative text, C-style variadic functions that are declared but never defined are permitted. For example, when a function call expression appears in an unevaluated context, such as the argument in a <code>sizeof</code> expression, overload resolution is performed to determine the result type of the call but does not require a function definition.</p>",
        "<p><b>Noncompliant Code Example</b></p>",
        "<pre><code language=\"C++\">",
        "#include &lt;cstdarg&gt;",
        "",
        "int add(int first, int second, ...) {",
        "  int r = first + second; ",
        "  va_list va;",
        "  va_start(va, second);",
        "  while (int v = va_arg(va, int)) {",
        "    r += v;",
        "  }",
        "  va_end(va);",
        "  return r;",
        "}",
        "</code></pre>"
      ]
    }
  },

  "DCL53-CPP": {
    "tags": [
      "Declarations and Definitions",
      "Language: C++",
      "Standard: SEI CERT C++",
      "Severity: 25",
      "Likelihood: Unlikely",
      "Remediation Cost: Medium",
      "Priority: P2",
      "Level: L3"
    ],
    "key": "vexing-parse",
    "name": "Published Standards/SEI Cert Standards/C++/Do not write syntactically ambiguous declarations",
    "desc": {
      "html": [
        "<p><b>Title</b></p>",
        "<p>Do not write syntactically ambiguous declarations</p>",
        "<p><b>Risk Assessment</b></p>",
        "<p>Syntactically ambiguous declarations can lead to unexpected program execution. However, it is likely that rudimentary testing would uncover violations of this rule.</p>",
        "<p><b>Full Standard</b></p>",
        "<p><a href='https://wiki.sei.cmu.edu/confluence/display/cplusplus/DCL53-CPP.+Do+not+write+syntactically+ambiguous+declarations'>https://wiki.sei.cmu.edu/confluence/display/cplusplus/DCL53-CPP.+Do+not+write+syntactically+ambiguous+declarations</a></p>",
        "<p><b>Noncompliant Code Example</b></p>",
        "<pre><code language=\"C++\">",
        "#include &lt;mutex&gt;",
        "",
        "static std::mutex m;",
        "static int shared_resource;",
        "",
        "void increment_by_42() {",
        "  std::unique_lock&lt;std::mutex&gt;(m);",
        "  shared_resource += 42;",
        "}",
        "</code></pre>"
      ]
    }
  },

  "DCL58-CPP": {
    "tags": ["Language: C", "Language: C++", "Standard: SEI CERT C++", "Severity: 75", "Likelihood: Unlikely", "Remediation Cost: Medium", "Priority: P6", "Level: L2", "Libraries"],
    "key": "cert-dcl58-cpp",
    "name": "Published Standards/SEI Cert Standards/C++/Do not modify the standard namespaces",
    "desc": {
      "html": [
        "<p><b>Title</b></p>",
        "<p>Do not modify the standard namespaces</p>",
        "<p><b>Risk Assessment</b></p>",
        "<p>Altering the standard namespace can cause undefined behavior in the C++ standard library.</p>",
        "<p><b>Full Standard</b></p>",
        "<p><a href='https://wiki.sei.cmu.edu/confluence/display/cplusplus/DCL58-CPP.+Do+not+modify+the+standard+namespaces'>https://wiki.sei.cmu.edu/confluence/display/cplusplus/DCL58-CPP.+Do+not+modify+the+standard+namespaces</a></p>",
        "<p><b>Noncompliant Code Example</b></p>",
        "<pre><code language=\"C++\">",
        "namespace std {",
        "int x;",
        "}",
        "</code></pre>"
      ]
    }
  },

  "DCL59-CPP": {
    "tags": ["Language: C", "Standard: SEI CERT C++", "Severity: 50", "Likelihood: Unlikely", "Remediation Cost: Medium", "Priority: P4", "Level: L3", "Headers"],
    "key": "cert-dcl59-cpp",
    "name": "Published Standards/SEI Cert Standards/C++/Do not define an unnamed namespace in a header file",
    "desc": {
      "html": [
        "<p><b>Title</b></p>",
        "<p>Do not define an unnamed namespace in a header file</p>",
        "<p><b>Risk Assessment</b></p>",
        "<p>Defining an unnamed namespace within a header file can cause data integrity violations and performance problems but is unlikely to go unnoticed with sufficient testing. One-definition rule violations result in undefined behavior.</p>",
        "<p><b>Full Standard</b></p>",
        "<p><a href='https://wiki.sei.cmu.edu/confluence/display/cplusplus/DCL59-CPP.+Do+not+define+an+unnamed+namespace+in+a+header+file'>https://wiki.sei.cmu.edu/confluence/display/cplusplus/DCL59-CPP.+Do+not+define+an+unnamed+namespace+in+a+header+file</a></p>",
        "<p><b>Noncompliant Code Example</b></p>",
        "<pre><code language=\"C++\">",
        "TODO",
        "</code></pre>"
      ]
    }
  },

  "ERR33-C": {
    "tags": ["Language: C", "Language: C++", "Standard: SEI CERT C", "Standard:", "Severity: 75", "Likelihood: Likely", "Remediation Cost: Medium", "Priority: P18", "Level: L1", "Exception Handling"],
    "key": "cert-err33-c",
    "name": "Published Standards/SEI Cert Standards/C/Detect and handle standard library errors",
    "desc": {
      "html": [
        "<p>Detect and handle standard library errors</p>",
        "<p><b>Risk Assessment</b></p>",
        "<p>Failing to detect error conditions can lead to unpredictable results, including abnormal program termination and denial-of-service attacks or, ",
        "in some situations, could even allow an attacker to run arbitrary code.</p>",
        "<p>For the full standard: <i>https://wiki.sei.cmu.edu/confluence/display/c/ERR33-C.+Detect+and+handle+standard+library+errors</i></p>",
        "<p><b>Exceptions</b></p>",
        "<p><i>ERR33-C-EX1: </i> It is acceptable to ignore the return value of a function if:</p>",
        "<p>1) that function cannot fail.</p>",
        "<p>2) its return value is inconsequential; that is, it does not indicate an error.</p>",
        "<p>3) it is one of a handful of functions whose return values are not traditionally checked.</p>",
        "<p><b>Noncompliant Code Example</b></p>",
        "<pre>",
        "#include &lt;locale.h&gt;",
        "#include &lt;stdlib.h&gt;",
        "",
        "int utf8_to_wcs(wchar_t *wcs, size_t n, const char *utf8,",
        "                size_t *size) {",
        "  if (NULL == size) {",
        "    return -1;",
        "  }",
        "  setlocale(LC_CTYPE, \"en_US.UTF-8\");",
        "  *size = mbstowcs(wcs, utf8, n);",
        "  return 0;",
        "}",
        "</pre>",
        "<p><b>Developer's Notes</b></p><p>This check is automatically implemented with clang-tidy.</p>"
      ]
    }
  },

  "ERR34-C": {
    "tags": ["Language: C", "Language: C++", "Standard: SEI CERT C", "Standard:", "Severity: 50", "Likelihood: Unlikely", "Remediation Cost: Medium", "Priority: P4", "Level: L3", "Exception Handling"],
    "key": "cert-err34-c",
    "name": "Published Standards/SEI Cert Standards/C/Detect errors when converting a string to a number",
    "desc": {
      "html": [
        "<p>Detect errors when converting a string to a number</p>",
        "<p><b>Risk Assessment</b></p>",
        "<p>It is rare for a violation of this rule to result in a security vulnerability unless it occurs in security-sensitive code. However, violations of this rule can easily result in lost or misinterpreted data.</p>",
        "<p>For the full standard: <i>https://wiki.sei.cmu.edu/confluence/display/c/ERR34-C.+Detect+errors+when+converting+a+string+to+a+number</i></p>",
        "<p><b>Noncompliant Code Example</b></p>",
        "<pre><code language=\"C++\">",
        "#include &lt;stdlib.h&gt;",
        "",
        "void func(const char *buff) {",
        "  int si;",
        "",
        "  if (buff) {",
        "    si = atoi(buff);",
        "  } else {",
        "    /* Handle error */",
        "  }",
        "}",
        "</code></pre>",
        "<p><b>Developer's Notes</b></p><p>This check is automatically implemented with clang-tidy.</p>"
      ]
    }
  },

  "ERR50-CPP": {
    "tags": [
      "Exception Handling",
      "Language: C++",
      "Standard: SEI CERT C++",
      "Severity: 25",
      "Likelihood: Probable",
      "Remediation Cost: Medium",
      "Priority: P4",
      "Level: L3"
    ],
    "keys": ["sti.SEIAbruptlyTerminate"],
    "name": "Published Standards/SEI Cert Standards/C++/Do not abruptly terminate the program",
    "desc": {
      "html": [
        "<p>Do not abruptly terminate the program.</p>",
        "<p><b>Risk Assessment</b></p>",
        "<p>Allowing the application to abnormally terminate can lead to resources not being freed, closed, and so on. It is frequently a vector for denial-of-service attacks.</p>",
        "<p>For the full standard: <i>https://wiki.sei.cmu.edu/confluence/display/cplusplus/ERR50-CPP.+Do+not+abruptly+terminate+the+program</i></p>",
        "<p><b>Exceptions</b></p>",
        "<p><i>ERR50-CPP-EX1: </i> It is acceptable, after indicating the nature of the problem to the operator, to explicitly call std::abort(), std::_Exit(), or std::terminate() in response to a critical program error for which no recovery is possible, as in this example.</p>",
        "<p><b>Noncompliant Code Example</b></p>",
        "<pre>#include &lt;cstdlib&gt;</pre>",
        "<pre>void throwing_func() noexcept(false);</pre>",
        "<pre>void f() { // Not invoked by the program except as an exit handler.</pre>",
        "<pre>  throwing_func();</pre>",
        "<pre>}</pre>",
        "<pre>int main() {</pre>",
        "<pre>  if (0 != std::atexit(f)) {</pre>",
        "<pre>    // Handle error</pre>",
        "<pre>  }</pre>",
        "<pre>  // ...</pre>",
        "<pre>}</pre>"
      ]
    }
  },

  "ERR54-CPP": {
    "tags": [
      "Language: C",
      "Language: C++",
      "Standard: SEI CERT C++",
      "Severity: 50",
      "Likelihood: Likely",
      "Remediation Cost: Low",
      "Priority: P18",
      "Level: L1"
    ],
    "keys": ["exceptions"],
    "name": "Published Standards/SEI Cert Standards/C++/Catch handlers should order their parameter types from most derived to least derived",
    "desc": {
      "html": [
        "<p><b>Title</b></p>",
        "<p>Catch handlers should order their parameter types from most derived to least derived</p>",
        "<p><b>Risk Assessment</b></p>",
        "<p>Exception handlers with inverted priorities cause unexpected control flow when an exception of the derived type occurs.</p>",
        "<p><b>Full Standard</b></p>",
        "<p><a href='https://wiki.sei.cmu.edu/confluence/display/cplusplus/ERR54-CPP.+Catch+handlers+should+order+their+parameter+types+from+most+derived+to+least+derived'>https://wiki.sei.cmu.edu/confluence/display/cplusplus/ERR54-CPP.+Catch+handlers+should+order+their+parameter+types+from+most+derived+to+least+derived</a></p>",
        "<p><b>Noncompliant Code Example</b></p>",
        "<pre><code language=\"C++\">// Classes used for exception handling",
        "class B {};",
        "class D : public B {};",
        " ",
        "void f() {",
        "  try {",
        "    // ...",
        "  } catch (B &b) {",
        "    // ...",
        "  } catch (D &d) {",
        "    // ...",
        "  }",
        "}",
        "</code></pre>"
      ]
    }
  },

  "ERR61-CPP": {
    "tags": [
      "Exception Handling",
      "Language: C",
      "Language: C++",
      "Standard: SEI CERT C++",
      "Severity: 25",
      "Likelihood: Unlikely",
      "Remediation Cost: Low",
      "Priority: P3",
      "Level: L3"
    ],
    "key": "cert-err61-cpp",
    "name": "Published Standards/SEI Cert Standards/C++/Catch exceptions by lvalue reference",
    "desc": {
      "html": [
        "<p><b>Title</b></p>",
        "<p>Catch exceptions by lvalue reference</p>",
        "<p><b>Risk Assessment</b></p>",
        "<p>Object slicing can result in abnormal program execution. This generally is not a problem for exceptions, but it can lead to unexpected behavior depending on the assumptions made by the exception handler.</p>",
        "<p><b>Full Standard</b></p>",
        "<p><a href='https://wiki.sei.cmu.edu/confluence/display/cplusplus/ERR61-CPP.+Catch+exceptions+by+lvalue+reference'>https://wiki.sei.cmu.edu/confluence/display/cplusplus/ERR61-CPP.+Catch+exceptions+by+lvalue+reference</a></p>",
        "<p><b>Noncompliant Code Example</b></p>",
        "<pre><code language=\"C++\">#include &lt;exception&gt;",
        "#include &lt;iostream&gt;",
        "",
        "struct S : std::exception {",
        "  const char *what() const noexcept override {",
        "    return \"My custom exception\";",
        "  }",
        "};",
        "",
        "void f() {",
        "  try {",
        "    throw S();",
        "  } catch (std::exception e) {",
        "    std::cout &lt;&lt; e.what() &lt;&lt; std::endl;",
        "  }",
        "}",
        "</code></pre>"
      ]
    }
  },

  "EXP30-C-B": {
    "tags": ["Language: C", "Standard: SEI CERT C", "Standard:", "Severity: 50", "Likelihood: Probable", "Remediation Cost: Medium", "Priority: P8", "Level: L2", "Expressions"],
    "key": "unsequenced",
    "name": "Published Standards/SEI Cert Standards/C/Do not depend on the order of evaluation for side effects - other",
    "desc": {
      "html": [
        "<p>Do not depend on the order of evaluation for side effects</p>",
        "<p><b>Risk Assessment</b></p>",
        "<p>Attempting to modify an object multiple times between sequence points may cause that object to take on an unexpected value, which can lead to unexpected program behavior.</p>",
        "<p>For the full standard: <i>https://wiki.sei.cmu.edu/confluence/display/c/EXP30-C.+Do+not+depend+on+the+order+of+evaluation+for+side+effects</i></p>",
        "<p><b>Noncompliant Code Example</b></p>",
        "<pre>",
        "#include &lt;stdio.h&gt;",
        "",
        "void func(int i, int *b) {",
        "  int a = i + b[++i];",
        "  printf(\"%d, %d\", a, i);",
        "}",
        "</pre>"
      ]
    }
  },

  "EXP32-C": {
    "tags": ["Language: C", "Standard: SEI CERT C", "Standard:", "Severity: 25", "Likelihood: Likely", "Remediation Cost: Medium", "Priority: P6", "Level: L2", "Types"],
    "key": "incompatible-pointer-types-discards-qualifiers",
    "name": "Published Standards/SEI Cert Standards/C/Do not access a volatile object through a nonvolatile reference",
    "desc": {
      "html": [
        "<p>Do not access a volatile object through a nonvolatile reference</p>",
        "<p><b>Risk Assessment</b></p>",
        "<pAccessing an object with a volatile-qualified type through a reference with a non-volatile-qualified type is undefined behavior.</p>",
        "<p>For the full standard: <i>https://wiki.sei.cmu.edu/confluence/display/c/EXP32-C.+Do+not+access+a+volatile+object+through+a+nonvolatile+reference</i></p>",
        "<p><b>Noncompliant Code Example</b></p>",
        "<pre>",
        "#include &lt;stdio.h&gt;",
        "",
        "void func(void) {",
        "  static volatile int **ipp;",
        "  static int *ip;",
        "  static volatile int i = 0;",
        "",
        "  printf(\"i = %d.\\n\", i);",
        "",
        "  ipp = &ip; /* May produce a warning diagnostic */",
        "  ipp = (int**) &ip; /* Constraint violation; may produce a warning diagnostic */",
        "  *ipp = &i; /* Valid */",
        "  if (*ip != 0) { /* Valid */",
        "    /* ... */",
        "  }",
        "}",
        "</pre>"
      ]
    }
  },

  "EXP42-C": {
    "tags": ["Language: C", "Language: C++", "Standard: SEI CERT C", "Standard:", "Severity: 50", "Likelihood: Probable", "Remediation Cost: Medium", "Priority: P8", "Level: L2", "Expressions"],
    "key": "cert-exp42-c",
    "name": "Published Standards/SEI Cert Standards/C/Do not compare padding data",
    "desc": {
      "html": [
        "<p>Do not compare padding data</p>",
        "<p><b>Risk Assessment</b></p>",
        "<p>Comparing padding bytes, when present, can lead to unexpected program behavior.</p>",
        "<p>For the full standard: <i>https://wiki.sei.cmu.edu/confluence/display/c/EXP42-C.+Do+not+compare+padding+data</i></p>",
        "<p><b>Exceptions</b></p>",
        "<p>See EXP42-C-EX1</p>",
        "<p><b>Noncompliant Code Example</b></p>",
        "<pre>",
        "#include &lt;string.h&gt;",
        "",
        "struct s {",
        "  char c;",
        "  int i;",
        "  char buffer[13];",
        "};",
        "",
        "void compare(const struct s *left, const struct s *right) { ",
        "  if ((left && right) &&",
        "      (0 == memcmp(left, right, sizeof(struct s)))) {",
        "    /* ... */",
        "  }",
        "}",
        "</pre>",
        "<p><b>Developer's Notes</b></p><p>This check is automatically implemented with clang-tidy.</p>"
      ]
    }
  },

  "FIO38-C": {
    "tags": ["Language: C", "Language: C++", "Standard: SEI CERT C", "Standard:", "Severity: 25", "Likelihood: Probable", "Remediation Cost: Medium", "Priority: P4", "Level: L3", "Libraries"],
    "key": "cert-fio38-c",
    "name": "Published Standards/SEI Cert Standards/C/Do not copy a FILE object",
    "desc": {
      "html": [
        "<p>Do not copy a FILE object</p>",
        "<p><b>Risk Assessment</b></p>",
        "<p>Using a copy of a FILE object in place of the original may result in a crash, which can be used in a denial-of-service attack.</p>",
        "<p>For the full standard: <i>https://wiki.sei.cmu.edu/confluence/display/c/FIO38-C.+Do+not+copy+a+FILE+object</i></p>",
        "<p><b>Noncompliant Code Example</b></p>",
        "<pre>",
        "#include &lt;stdio.h&gt;",
        "",
        "int main(void) {",
        "  FILE my_stdout = *stdout;",
        "  if (fputs(\"Hello, World!\\n\", &my_stdout) == EOF) {",
        "    /* Handle error */",
        "  }",
        "  return 0;",
        "}",
        "</pre>",
        "<p><b>Developer's Notes</b></p><p> This check is automatically implemented with clang-tidy.</p>"
      ]
    }
  },

  "FLP30-C": {
    "tags": ["Language: C", "Language: C++", "Standard: SEI CERT C", "Standard:", "Severity: 25", "Likelihood: Probable", "Remediation Cost: Low", "Priority: P6", "Level: L2", "Variables"],
    "key": "cert-flp30-c",
    "name": "Published Standards/SEI Cert Standards/C/Do not use floating-point variables as loop counters",
    "desc": {
      "html": [
        "<p>Do not use floating-point variables as loop counters</p>",
        "<p><b>Risk Assessment</b></p>",
        "<p>The use of floating-point variables as loop counters can result in  unexpected behavior.</p>",
        "<p>For the full standard: <i>https://wiki.sei.cmu.edu/confluence/display/c/FLP30-C.+Do+not+use+floating-point+variables+as+loop+counters</i></p>",
        "<p><b>Noncompliant Code Example</b></p>",
        "<pre>",
        "void func(void) {",
        "  for (float x = 0.1f; x &lt;= 1.0f; x += 0.1f) {",
        "    /* Loop may iterate 9 or 10 times */",
        "  }",
        "}",
        "</pre>",
        "<p><b>Developer's Notes</b></p><p>This check is automatically implemented with clang-tidy.</p>"
      ]
    }
  },

  "FLP37-C": {
    "tags": ["Language: C", "Language: C++", "Standard: SEI CERT C", "Standard:", "Severity: 25", "Likelihood: Unlikely", "Remediation Cost: Medium", "Priority: P2", "Level: L3", "Types"],
    "key": "cert-flp37-c",
    "name": "Published Standards/SEI Cert Standards/C/Do not use object representations to compare floating-point values",
    "desc": {
      "html": [
        "<p>Do not use object representations to compare floating-point values</p>",
        "<p><b>Risk Assessment</b></p>",
        "<p>Using the object representation of a floating-point value for comparisons can lead to incorrect equality results, which can lead to unexpected behavior.</p>",
        "<p>For the full standard: <i>https://wiki.sei.cmu.edu/confluence/display/c/FLP37-C.+Do+not+use+object+representations+to+compare+floating-point+values</i></p>",
        "<p><b>Noncompliant Code Example</b></p>",
        "<pre><code language=\"C++\">",
        "#include &lt;stdbool.h&gt;",
        "#include &lt;string.h&gt;",
        "",
        "struct S {",
        "  int i;",
        "  float f;",
        "};",
        "",
        "bool are_equal(const struct S *s1, const struct S *s2) {",
        "  if (!s1 && !s2)",
        "    return true;",
        "  else if (!s1 || !s2)",
        "    return false;",
        "  return 0 == memcmp(s1, s2, sizeof(struct S));",
        "}",
        "</code></pre>",
        "<p><b>Developer's Notes</b></p><p>This check is automatically implemented with clang-tidy.</p>"
      ]
    }
  },

  "INT33-C": {
    "tags": ["Language: C", "Standard: SEI CERT C", "Standard:", "Severity: 25", "Likelihood: Likely", "Remediation Cost: Medium", "Priority: P6", "Level: L2", "Expression"],
    "key": "core.DivideZero",
    "name": "Published Standards/SEI Cert Standards/C/Division by Zero",
    "desc": {
      "text": "Ensure that division and remainder operations do not result in divide-by-zero errors (C, C++, ObjC)",
      "html": [
        "<p>Division by Zero (C, C++, ObjC)</p>",
        "<p><b>Risk Assessment</b></p>",
        "<p>The result of the / operator is the quotient from the division of the first arithmetic operand by the second arithmetic operand. Division operations are susceptible to divide-by-zero errors.</p>",
        "<p>Overflow can also occur during two's complement signed integer division when the dividend is equal to the minimum (most negative) value for the signed integer type and the divisor is equal to -1.</p>",
        "<p><b>Exceptions</b></p>",
        "<p><i>N/A</i></p>",
        "<p><b>Noncompliant Code Example</b></p>",
        "<pre><code language=\"C++\">#include &lt;limits.h&gt;",
        "",
        "void func(signed long s_a, signed long s_b) {",
        "  signed long result;",
        "  if ((s_a == LONG_MIN) && (s_b == -1)) {",
        "          /* Handle error */",
        "  } else {",
        "          result = s_a % s_b;",
        "  }",
        "  /* ... */",
        "}</code></pre>"
      ]
    }
  },

  "INT36-C": {
    "tags": ["Language: C", "Language: C++", "Standard: SEI CERT C", "Standard:", "Severity: 25", "Likelihood: Probable", "Remediation Cost: High", "Priority: P2", "Level: L3", "Types"],
    "keys": ["int-conversion", "int-to-pointer-cast", "pointer-to-int-cast"],
    "name": "Published Standards/SEI Cert Standards/C/Converting a pointer to integer or integer to pointer",
    "desc": {
      "html": [
        "<p><b>Title</b></p>",
        "<p>Converting a pointer to integer or integer to pointer</p>",

        "<p><b>Risk Assessment</b></p>",
        "<p>Converting from pointer to integer or vice versa results in code that is not portable and may create unexpected pointers to invalid memory locations.</p>",

        "<p><b>Full Standard</b></p>",
        "<p><a href='https://wiki.sei.cmu.edu/confluence/display/c/INT36-C.+Converting+a+pointer+to+integer+or+integer+to+pointer'>https://wiki.sei.cmu.edu/confluence/display/c/INT36-C.+Converting+a+pointer+to+integer+or+integer+to+pointer</a></p>",

        "<p><b>Exceptions</b></p>",
        "<p>INT36-C-EX1: The integer value 0 can be converted to a pointer; it becomes the null pointer.</p>",
        "<p>INT36-C-EX2: Any valid pointer to <code>void</code> can be converted to <code>intptr_t</code> or <code>uintptr_t</code> or their underlying types and back again with no change in value. Use of underlying types instead of <code>intptr_t</code> or <code>uintptr_t</code> is discouraged, however, because it limits portability.</p>",

        "<p><b>Noncompliant Code Example</b></p>",
        "<pre><code language=\"C++\">",
        "void f(void) {",
        "  char *ptr;",
        "  /* ... */",
        "  unsigned int number = (unsigned int)ptr;",
        "  /* ... */",
        "}",
        "</code></pre>"
      ]
    }
  },

  "MEM57-CPP": {
    "tags": ["Language: C", "Language: C++", "Standard: SEI CERT C++", "Severity: 50", "Likelihood: Unlikely", "Remediation Cost: Low", "Priority: P6", "Level: L2", "Memory Allocation"],
    "key": "cert-mem57-cpp",
    "name": "Published Standards/SEI Cert Standards/C++/Avoid using default operator new for over-aligned types",
    "desc": {
      "html": [
        "<p><b>Title</b></p>",
        "<p>Avoid using default operator new for over-aligned types</p>",
        "<p><b>Risk Assessment</b></p>",
        "<p>Using improperly aligned pointers results in undefined behavior, typically leading to abnormal termination.</p>",
        "<p><b>Full Standard</b></p>",
        "<p><a href='https://wiki.sei.cmu.edu/confluence/display/cplusplus/MEM57-CPP.+Avoid+using+default+operator+new+for+over-aligned+types'>https://wiki.sei.cmu.edu/confluence/display/cplusplus/MEM57-CPP.+Avoid+using+default+operator+new+for+over-aligned+types</a></p>",
        "<p><b>Noncompliant Code Example</b></p>",
        "<pre><code language=\"C++\">",
        "struct alignas(32) Vector {",
        "  char elems[32];",
        "};",
        "",
        "Vector *f() {",
        "  Vector *pv = new Vector;",
        "  return pv;",
        "}",
        "</code></pre>"
      ]
    }
  },

  "MSC30-C": {
    "tags": ["Language: C", "Language: C++", "Standard: SEI CERT C", "Standard:", "Severity: 50", "Likelihood: Unlikely", "Remediation Cost: Low", "Priority: P6", "Level: L2", "Libraries"],
    "key": "cert-msc30-c",
    "name": "Published Standards/SEI Cert Standards/C/Do not use the rand() function for generating pseudorandom numbers",
    "desc": {
      "html": [
        "<p>Do not use the rand() function for generating pseudorandom numbers</p>",
        "<p><b>Risk Assessment</b></p>",
        "<p>The use of the rand() function can result in predictable random numbers.</p>",
        "<p>For the full standard: <i>https://wiki.sei.cmu.edu/confluence/display/c/MSC30-C.+Do+not+use+the+rand%28%29+function+for+generating+pseudorandom+numbers</i></p>",
        "<p><b>Noncompliant Code Example</b></p>",
        "<pre><code language=\"C++\">",
        "#include &lt;stdio.h&gt;",
        "#include &lt;stdlib.h&gt;",
        "",
        "enum { len = 12 };",
        "",
        "void func(void) {",
        "  /*",
        "   * id will hold the ID, starting with the characters",
        "   *  \"ID\" followed by a random integer.",
        "   */",
        "  char id[len]; ",
        "  int r;",
        "  int num;",
        "  /* ... */",
        "  r = rand();  /* Generate a random integer */",
        "  num = snprintf(id, len, \"ID%-d\", r);  /* Generate the ID */",
        "  /* ... */",
        "}",
        "</code></pre>",
        "<p><b>Developer's Notes</b></p><p>This check is automatically implemented with clang-tidy.</p>"
      ]
    }
  },

  "MSC37-C": {
    "tags": [
      "Functions",
      "Language: C",
      "Language: C++",
      "Standard: SEI CERT C",
      "Severity: 75",
      "Likelihood: Unlikely",
      "Remediation Cost: Low",
      "Priority: P9",
      "Level: L2"
    ],
    "key": "return-type",
    "name": "Published Standards/SEI Cert Standards/C/Ensure that control never reaches the end of a non-void function",
    "desc": {
      "text": "Ensure that control never reaches the end of a non-void function",
      "html": [
        "<p><b>Title</b></p>",
        "<p>Ensure that control never reaches the end of a non-void function</p>",
        "<p><b>Risk Assessment</b></p>",
        "<p>Using the return value from a non-<code>void</code> function where control reaches the end of the function without evaluating a <code>return</code> statement can lead to buffer overflow vulnerabilities as well as other unexpected program behaviors.</p>",
        "<p><b>Full Standard</b></p>",
        "<p><a href='https://wiki.sei.cmu.edu/confluence/display/c/MSC37-C.+Ensure+that+control+never+reaches+the+end+of+a+non-void+function'>https://wiki.sei.cmu.edu/confluence/display/c/MSC37-C.+Ensure+that+control+never+reaches+the+end+of+a+non-void+function</a></p>",
        "<p><b>Exceptions</b></p>",
        "<p>According to the C Standard, 5.1.2.2.3, paragraph 1 [ISO/IEC 9899:2011], \"Reaching the <code>}</code> that terminates the main function returns a value of 0.\" As a result, it is permissible for control to reach the end of the <code>main()</code> function without executing a return statement.</p>",
        "<p>It is permissible for a control path to not return a value if that code path is never taken and a function marked <code>_Noreturn</code> is called as part of that code path. For example:</p>",
        "<pre><code language=\"C++\">",
        "#include &lt;stdio.h&gt;",
        "#include &lt;stdlib.h&gt;",
        "",
        "_Noreturn void unreachable(const char *msg) {",
        "  printf(\"Unreachable code reached: %s\\n\", msg);",
        "  exit(1);",
        "}",
        "",
        "enum E {",
        "  One,",
        "  Two,",
        "  Three",
        "};",
        "",
        "int f(enum E e) {",
        "  switch (e) {",
        "  case One: return 1;",
        "  case Two: return 2;",
        "  case Three: return 3;",
        "  }",
        "  unreachable(\"Can never get here\");",
        "}",
        "</code></pre>",
        "<p><b>Noncompliant Code Example</b></p>",
        "<pre><code language=\"C++\">",
        "#include &lt;string.h&gt;",
        "#include &lt;stdio.h&gt;",
        "",
        "int checkpass(const char *password) {",
        "  if (strcmp(password, \"pass\") == 0) {",
        "    return 1;",
        "  }",
        "}",
        "",
        "void func(const char *userinput) {",
        "  if (checkpass(userinput)) {",
        "    printf(\"Success\\n\");",
        "  }",
        "}",
        "</code></pre>"
      ]
    }
  },

  "MSC50-CPP": {
    "tags": ["Language: C", "Language: C++", "Standard: SEI CERT C++", "Severity: 50", "Likelihood: Unlikely", "Remediation Cost: Low", "Priority: P6", "Level: L2", "Libraries"],
    "key": "cert-msc50-cpp",
    "name": "Published Standards/SEI Cert Standards/C++/Do not use the rand() function for generating pseudorandom numbers",
    "desc": {
      "html": [
        "<p><b>Title</b></p>",
        "<p>Do not use std::rand() for generating pseudorandom numbers</p>",
        "<p><b>Risk Assessment</b></p>",
        "<p>Using the <code>std::rand()</code> function could lead to predictable random numbers.</p>",
        "<p><b>Full Standard</b></p>",
        "<p><a href='https://wiki.sei.cmu.edu/confluence/display/cplusplus/MSC50-CPP.+Do+not+use+std%3A%3Arand%28%29+for+generating+pseudorandom+numbers'>https://wiki.sei.cmu.edu/confluence/display/cplusplus/MSC50-CPP.+Do+not+use+std%3A%3Arand%28%29+for+generating+pseudorandom+numbers</a></p>",
        "<p><b>Noncompliant Code Example</b></p>",
        "<pre><code language=\"C++\">",
        "#include &lt;cstdlib&gt;",
        "#include &lt;string&gt;",
        "",
        "void f() {",
          "std::string id(\"ID\"); // Holds the ID, starting with the characters \"ID\" followed",
                                "// by a random integer in the range [0-10000].",
          "id += std::to_string(std::rand() % 10000);",
          "// ...",
        "}",
        "</code></pre>"
      ]
    }
  },

  "MSC52-CPP": {
    "tags": ["Language: C", "Language: C++", "Standard: SEI CERT C++", "Severity: 50", "Likelihood: Probable", "Remediation Cost: Medium", "Priority: P8", "Level: L2", "Functions"],
    "keys": ["return-type"],
    "name": "Published Standards/SEI Cert Standards/C++/Value-returning functions must return a value from all exit paths",
    "desc": {
      "html": [
        "<p>The C++ Standard, [stmt.return], paragraph 2 [ISO/IEC 14882-2014], states the following:</p>",
        "<p><i>Flowing off the end of a function is equivalent to a return with no value; this results in undefined behavior in a value-returning function.</i></p>",
        "<p>A value-returning function must return a value from all code paths; otherwise, it will result in undefined behavior. This includes returning through less-common code paths, such as from a function-try-block, as explained in the C++ Standard, [except.handle], paragraph 15:</p>",
        "<p><i>Flowing off the end of a function-try-block is equivalent to a return with no value; this results in undefined behavior in a value-returning function (6.6.3).</i></p>",
        "<p><b>Noncompliant Code Example</b></p>",
        "<pre><code language=\"C++\">int absolute_value(int a) {",
        "  int absolute_value(int a) {",
        "    if (a &lt; 0) {",
        "      return -a;",
        "    }",
        "  }",
        "}</code></pre>",
        "<p><b>Link to full standard</b></p>",
        "<p><a href=\"https://wiki.sei.cmu.edu/confluence/display/cplusplus/MSC52-CPP.+Value-returning+functions+must+return+a+value+from+all+exit+paths\">https://wiki.sei.cmu.edu/confluence/display/cplusplus/MSC52-CPP.+Value-returning+functions+must+return+a+value+from+all+exit+paths</a></p>"
      ]
    }
  },

  "MSC53-CPP": {
    "tags": ["Language: C", "Language: C++", "Standard: SEI CERT C++", "Severity: 50", "Likelihood: Unlikely", "Remediation Cost: Low", "Priority: P2", "Level: L3", "Functions"],
    "keys": ["invalid-noreturn"],
    "name": "Published Standards/SEI Cert Standards/C++/Do not return from a function declared [[noreturn]]",
    "desc": {
      "html": [
        "<p>The [[noreturn]] attribute specifies that a function does not return. The C++ Standard, [dcl.attr.noreturn] paragraph 2 [ISO/IEC 14882-2014], states the following:</p>",
        "<p><i>If a function f is called where f was previously declared with the noreturn attribute and f eventually returns, the behavior is undefined.</i></p>",
        "<p>A function that specifies [[noreturn]] can prohibit returning by throwing an exception, entering an infinite loop, or calling another function designated with the [[noreturn]] attribute.</p>",
        "<p><b>Noncompliant Code Example</b></p>",
        "<p>In this noncompliant code example, if the value 0 is passed, control will flow off the end of the function, resulting in an implicit return and undefined behavior.</p>",
        "<pre><code language=\"C++\">#include &lt;cstdlib&gt;",
        "",
        "[[noreturn]] void f(int i) {",
        "  if (i &gt; 0)",
        "    throw \"Received positive input\";",
        "  else if (i &lt; 0)",
        "    std::exit(0);",
        "}</code></pre>",
        "<p><b>Compliant Code Example</b></p>",
        "<p>In this compliant solution, the function does not return on any code path.</p>",
        "<pre><code language=\"C++\">#include &lt;cstdlib&gt;",
        "",
        "[[noreturn]] void f(int i) {",
        "  if (i &gt; 0)",
        "    throw \"Received positive input\";",
        "  std::exit(0);",
        "}",
        "<p><b>Link to full standard</b></p>",
        "<p><a href=\"https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=88046346\">https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=88046346</a></p>"
      ]
    }
  },

  "MSC54-CPP": {
    "tags": ["Language: C", "Language: C++", "Standard: SEI CERT C++", "Severity: 75", "Likelihood: Probable", "Remediation Cost: High", "Priority: P6", "Level: L2", "Functions"],
    "key": "cert-msc54-cpp",
    "name": "Published Standards/SEI Cert Standards/C++/A signal handler must be a plain old function",
    "desc": {
      "html": [
        "<p><b>Title</b></p>",
        "<p>A signal handler must be a plain old function</p>",
        "",
        "<p><b>Risk Assessment</b></p>",
        "<p>Failing to use a plain old function as a signal handler can result in",
        "implementation-defined behavior as well as undefined behavior. Given the number",
        "of features that exist in C++ that do not also exist in C, the consequences that",
        "arise from failure to comply with this rule can range from benign (harmless)",
        "behavior to abnormal program termination, or even arbitrary code execution.</p>",
        "",
        "<p><b>Full Standard</b></p>",
        "<p><a href='https://wiki.sei.cmu.edu/confluence/display/cplusplus/MSC54-CPP.+A+signal+handler+must+be+a+plain+old+function'>https://wiki.sei.cmu.edu/confluence/display/cplusplus/MSC54-CPP.+A+signal+handler+must+be+a+plain+old+function</a></p>",
        "",
        "<p><b>Noncompliant Code Example</b></p>",
        "<pre><code language=\"C++\">#include &lt;csignal&gt;",
        "",
        "static void sig_handler(int sig) {",
        "  // Implementation details elided.",
        "}",
        "",
        "void install_signal_handler() {",
        "  if (SIG_ERR == std::signal(SIGTERM, sig_handler)) {",
        "    // Handle error",
        "  }",
        "}",
        "</code></pre>"
      ]
    }
  },

  "OOP52-CPP": {
    "tags": ["Language: C++", "Standard: SEI CERT C++", "Severity: 25", "Likelihood: Likely", "Remediation Cost: Low", "Priority: P9", "Level: L2", "Destructors"],
    "key": "delete-non-abstract-non-virtual-dtor",
    "name": "Published Standards/SEI Cert Standards/C++/Do not delete a polymorphic object without a virtual destructor",
    "desc": {
      "html": [
        "<p><b>Title</b></p>",
        "<p>Do not delete a polymorphic object without a virtual destructor</p>",

        "<p><b>Risk Assessment</b></p>",
        "<p>Attempting to destruct a polymorphic object that does not have a <code>virtual</code> destructor declared results in undefined behavior. In practice, potential consequences include abnormal program termination and memory leaks.</p>",

        "<p><b>Full Standard</b></p>",
        "<p><a href='https://wiki.sei.cmu.edu/confluence/display/cplusplus/OOP52-CPP.+Do+not+delete+a+polymorphic+object+without+a+virtual+destructor'>https://wiki.sei.cmu.edu/confluence/display/cplusplus/OOP52-CPP.+Do+not+delete+a+polymorphic+object+without+a+virtual+destructor</a></p>",

        "<p><b>Exceptions</b></p>",
        "<p>OOP52-CPP:EX0: Deleting a polymorphic object without a virtual destructor is permitted if the object is referenced by a pointer to its class, rather than via a pointer to a class it inherits from.</p>",
        "<p>Note that if <code>Derived</code> were not marked as <code>final</code>, then <code>delete this</code> could actually reference a subclass of <code>Derived</code>, violating this rule.</p>",
        "<p>OOP52-CPP:EX1: Deleting a polymorphic object without a virtual destructor is permitted if its base class has a destroying <code>operator delete</code> that will figure out the correct derived class's destructor to call by other means.</p>",

        "<p><b>Noncompliant Code Example</b></p>",
        "<pre><code language=\"C++\">",
        "struct Base {",
        "  virtual void f();",
        "};",
        "",
        "struct Derived : Base {};",
        "",
        "void f() {",
        "  Base *b = new Derived();",
        "  // ...",
        "  delete b;",
        "}",
        "</code></pre>"
      ]
    }
  },

  "OOP53-CPP": {
    "tags": ["Language: C++", "Standard: SEI CERT C++", "Severity: 50", "Likelihood: Unlikely", "Remediation Cost: Medium", "Priority: P4", "Level: L3", "Constructors"],
    "key": "reorder-ctor",
    "name": "Published Standards/SEI Cert Standards/C++/Write constructor member initializers in the canonical order",
    "desc": {
      "html": [
        "<p><b>Title</b></p>",
        "<p>Write constructor member initializers in the canonical order</p>",

        "<p><b>Full Standard</b></p>",
        "<p><a href='https://wiki.sei.cmu.edu/confluence/display/cplusplus/OOP53-CPP.+Write+constructor+member+initializers+in+the+canonical+order'>https://wiki.sei.cmu.edu/confluence/display/cplusplus/OOP53-CPP.+Write+constructor+member+initializers+in+the+canonical+order</a></p>",

        "<p><b>Exceptions</b></p>",
        "<b>OOP53-CPP-EX0</b>: <p>Constructors that do not use member initializers do not violate this rule.</p>",

        "<p><b>Noncompliant Code Example</b></p>",
        "<pre><code language=\"C++\">",
        "class C {",
        "  int dependsOnSomeVal;",
        "  int someVal;",
        "",
        "public:",
        "  C(int val) : someVal(val), dependsOnSomeVal(someVal + 1) {}",
        "};",
        "</code></pre>"
      ]
    }
  },

  "OOP54-CPP": {
    "tags": ["Language: C", "Language: C++", "Standard: SEI CERT C++", "Severity: 25", "Likelihood: Probable", "Remediation Cost: High", "Priority: P2", "Level: L3", "Assignment Operators"],
    "key": "cert-oop54-cpp",
    "name": "Published Standards/SEI Cert Standards/C++/Gracefully handle self-copy assignment",
    "desc": {
      "html": [
        "<p><b>Title</b></p>",
        "<p>Gracefully handle self-copy assignment</p>",
        "<p><b>Risk Assessment</b></p>",
        "<p>Allowing a copy assignment operator to corrupt an object could lead to undefined behavior.</p>",
        "<p><b>Full Standard</b></p>",
        "<p><a href='https://wiki.sei.cmu.edu/confluence/display/cplusplus/OOP54-CPP.+Gracefully+handle+self-copy+assignment'>https://wiki.sei.cmu.edu/confluence/display/cplusplus/OOP54-CPP.+Gracefully+handle+self-copy+assignment</a></p>",
        "<p><b>Noncompliant Code Example</b></p>",
        "<pre><code language=\"C++\">",
        "#include &lt;new&gt;",
        "",
        "struct S { S(const S &) noexcept; /* ... */ };",
        "",
        "class T {",
        "  int n;",
        "  S *s1;",
        "",
        "public:",
        "  T(const T &rhs) : n(rhs.n), s1(rhs.s1 ? new S(*rhs.s1) : nullptr) {}",
        "  ~T() { delete s1; }",
        "",
        "  // ...",
        "",
        "  T& operator=(const T &rhs) {",
        "    n = rhs.n;",
        "    delete s1;",
        "    s1 = new S(*rhs.s1);",
        "    return *this;",
        "  }",
        "};",
        "</code></pre>"
      ]
    }
  },

  "OOP58-CPP": {
    "tags": ["Language: C", "Language: C++", "Standard: SEI CERT C++", "Severity: 25", "Likelihood: Likely", "Remediation Cost: Low", "Priority: P9", "Level: L2", "Functions"],
    "key": "cert-oop58-cpp",
    "name": "Published Standards/SEI Cert Standards/C++/Copy operations must not mutate the source object",
    "desc": {
      "html": [
        "<p><b>Title</b></p>",
        "<p>Copy operations must not mutate the source object</p>",
        "<p><b>Risk Assessment</b></p>",
        "<p>Copy operations that mutate the source operand or global state can lead to unexpected program behavior. Using such a type in a Standard Template Library container or algorithm can also lead to undefined behavior.</p>",
        "<p><b>Full Standard</b></p>",
        "<p><a href='https://wiki.sei.cmu.edu/confluence/display/cplusplus/OOP58-CPP.+Copy+operations+must+not+mutate+the+source+object'>https://wiki.sei.cmu.edu/confluence/display/cplusplus/OOP58-CPP.+Copy+operations+must+not+mutate+the+source+object</a></p>",
        "<p><b>Exceptions</b></p>",
        "<p>OOP58-CPP-EX0: Reference counting, and implementations such as <code>std::shared_ptr<></code> constitute an exception to this rule. Any copy or assignment operation of a reference-counted object requires the reference count to be incremented. The semantics of reference counting are well-understood, and it can be argued that the reference count is not a salient part of the <code>shared_pointer</code> object.</p>",
        "<p><b>Noncompliant Code Example</b></p>",
        "<pre><code language=\"C++\">",
        "#include &lt;algorithm&gt;",
        "#include &lt;vector&gt;",
        "",
        "class A {",
        "  mutable int m;",
        "",
        "public:",
        "  A() : m(0) {}",
        "  explicit A(int m) : m(m) {}",
        "",
        "  A(const A &other) : m(other.m) {",
        "    other.m = 0;",
        "  }",
        "",
        "  A& operator=(const A &other) {",
        "    if (&other != this) {",
        "      m = other.m;",
        "      other.m = 0;",
        "    }",
        "    return *this;",
        "  }",
        "",
        "  int get_m() const { return m; }",
        "};",
        "",
        "void f() {",
        "  std::vector&lt;A&gt; v{10};",
        "  A obj(12);",
        "  std::fill(v.begin(), v.end(), obj);",
        "}",
        "</code></pre>"
      ]
    }
  },

  "POS44-C": {
    "tags": ["Language: C", "Language: C++", "Standard: SEI CERT C", "Standard:", "Severity: 25", "Likelihood: Probable", "Remediation Cost: Low", "Priority: P6", "Level: L2", "Threads"],
    "key": "cert-pos44-c",
    "name": "Published Standards/SEI Cert Standards/C/Do not use signals to terminate threads",
    "desc": {
      "html": [
        "<p>Do not use signals to terminate threads</p>",
        "<p><b>Risk Assessment</b></p>",
        "<p>Sending the signal to a process causes it to be abnormally terminated.</p>",
        "<p>For the full standard: <i>https://wiki.sei.cmu.edu/confluence/display/c/POS44-C.+Do+not+use+signals+to+terminate+threads</i></p>",
        "<p><b>Noncompliant Code Example</b></p>",
        "<pre><code language=\"C++\">",
        "void func(void *foo) {",
        "  /* Execution of thread */",
        "}",
        "",
        "int main(void) {",
        "  int result;",
        "  pthread_t thread;",
        "",
        "  if ((result = pthread_create(&thread, NULL, func, 0)) != 0) {",
        "    /* Handle Error */",
        "  }",
        "  if ((result = pthread_kill(thread, SIGTERM)) != 0) {",
        "    /* Handle Error */",
        "  }",
        "",
        "  /* This point is not reached because the process terminates in pthread_kill() */",
        "",
        "  return 0;",
        "}",
        "</code></pre>",
        "<p><b>Developer's Notes</b></p><p>This check is automatically implemented with clang-tidy.</p>"
      ]
    }
  },

  "POS47-C": {
    "tags": ["Language: C", "Language: C++", "Standard: SEI CERT C", "Standard:", "Severity: 50", "Likelihood: Probable", "Remediation Cost: Low", "Priority: P12", "Level: L1", "Threads"],
    "key": "cert-pos47-c",
    "name": "Published Standards/SEI Cert Standards/C/Do not use threads that can be canceled asynchronously",
    "desc": {
      "html": [
        "<p>Do not use threads that can be canceled asynchronously</p>",
        "<p><b>Risk Assessment</b></p>",
        "<p>Incorrectly using threads that asynchronously cancel may result in silent corruption, resource leaks, and, in the worst case, unpredictable interactions.</p>",
        "<p>For the full standard: <i>https://wiki.sei.cmu.edu/confluence/display/c/POS47-C.+Do+not+use+threads+that+can+be+canceled+asynchronously</i></p>",
        "<p><b>Noncompliant Code Example</b></p>",
        "<pre><code language=\"C++\">",
        "void release_global_lock(void* dummy) {",
        "  int result;",
        "  if ((result = pthread_mutex_unlock(&global_lock)) != 0) {",
        "    /* handle error */",
        "  }",
        "}",
        "",
        "void* worker_thread(void* dummy) {",
        "  int i;",
        "  int c;",
        "  int result;",
        "",
        "  if ((result = pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS,&i)) != 0) {",
        "    /* handle error */",
        "  }",
        "",
        "  while (1) {",
        "    if ((result = pthread_mutex_lock(&global_lock)) != 0) {",
        "      /* handle error */",
        "    }",
        "    pthread_cleanup_push( release_global_lock, NULL);",
        "    c = b;",
        "    b = a;",
        "    a = c;",
        "    pthread_cleanup_pop(1);",
        "  }",
        "  return NULL",
        "}",
        "</code></pre>",
        "<p><b>Developer's Notes</b></p><p>This check is automatically implemented with clang-tidy.</p>"
      ]
    }
  },

  "STR38-C": {
    "tags": ["Language: C", "Standard: SEI CERT C", "Standard:", "Severity: 75", "Likelihood: Likely", "Remediation Cost: Low", "Priority: P27", "Level: L1", "Types"],
    "keys": ["incompatible-pointer-types"],
    "name": "Published Standards/SEI Cert Standards/C/Do not confuse narrow and wide character strings and functions",
    "desc": {
      "html": [
        "<p>Do not confuse narrow and wide character strings and functions</p>",
        "<p><b>Risk Assessment</b></p>",
        "<p>Confusing narrow and wide character strings can result in buffer overflows, data truncation, and other defects.</p>",
        "<p>For the full standard: <i>https://wiki.sei.cmu.edu/confluence/display/c/STR38-C.+Do+not+confuse+narrow+and+wide+character+strings+and+functions</i></p>",
        "<p><b>Noncompliant Code Example</b></p>",
        "<pre>",
        "#include &lt;stddef.h&gt;",
        "#include &lt;string.h&gt;",
        "",
        "void func(void) {",
        "  wchar_t wide_str1[]  = L\"0123456789\";",
        "  wchar_t wide_str2[] =  L\"0000000000\";",
        "",
        "  strncpy(wide_str2, wide_str1, 10);",
        "}",
        "</pre>"
      ]
    }
  }
}
