{
  "M4-5-3": {
    "tags": ["Language: C", "Language: C++", "Standard: AUTOSAR", "Category: Required", "Automation: Automated", "Expressions"],
    "key": "sti.CharOperators",
    "name": "Published Standards/AUTOSAR/Character Operators",
    "desc": {
      "text": "",
      "html": [
        "<p>Expressions with type (plain) <i>char</i> and <i>wchar_t</i> shall not be used as operands to built-in operators other than the assignment operator <i>=</i>, the equality operators <code>==</code> and <code>!=</code>, and the unary <code>&</code> operator.</p>",
        "<p><b>Rationale</b></p>",
        "<p>Manipulation of character data may generate results that are contrary to developer expectations. For example, ISO/IEC 14882:2003 [1] §2.2(3) only requires that the digits \"0\" to \"9\" have consecutive numerical values.</p>",
        "<p><b>Exception</b></p>",
        "<p>Exceptionally, the following operators may be used if the associated restriction is observed:</p>",
        "<ul>",
        "<li>",
        "The binary <code>+</code> operator may be used to add an integral value in the",
        "range 0 to 9 to '0';",
        "</li>",
        "<li>",
        "The binary <code>-</code> operator may be used to subtract character '0';",
        "</li>",
        "<li>",
        "The relational operators <code>&lt;</code>, <code>&lt;=</code>,",
        "<code>&gt;</code>, <code>&gt;=</code> may be used to determine if a character",
        "(or wide character) represents a digit.",
        "</li>",
        "</ul>",
        "<p><b>Example</b></p>",
        "<pre>",
        "char_t ch = 't';                      // Compliant",
        "uint8_t v;",
        "if ( ( ch &gt;= 'a' ) && ( ch &lt;= 'z' ) ) // Non-compliant",
        "{",
        "}",
        "if ( ( ch &gt;= '0' ) && ( ch &lt;= '9' ) ) // Compliant by exception",
        "{",
        "   v = ch - '0';                      // Compliant by exception",
        "   v = ch - '1';                      // Non-compliant",
        "}",
        "else",
        "{",
        "   // ...",
        "}",
        "ch = '0' + v;                         // Compliant by exception",
        "ch = 'A' + v;                         // Non-compliant",
        "</pre>",
        "<p><b>Developer's Notes</b></p>",
        "<p>Other operators are allowed which are not generally thought of as operators. This includes but is not limited to</p>",
        "<ul>",
        "<li>Scope resolution <code>::</code></li>",
        "<li>C-style cast <code>(type)</code></li>",
        "<li>Size-of <code>sizeof</code></li>",
        "<li>Alignment requirement <code>_Alignof</code></li>",
        "<li>Ternary conditional <code>?:</code></li>",
        "</ul>"
      ]
    }
  },

  "A0-1-2": {
    "tags": [ "Language: C", "Language: C++", "Standard: AUTOSAR", "Category: Required", "Automation: Automated", "Functions" ],
    "key": "sti.IgnoredReturnValues",
    "name": "Published Standards/AUTOSAR/The value returned by a function shall be used",
    "desc": {
      "html": [
        "<p>The value returned by a function having a non-void return type that is not an overloaded operator shall be used.</p>",
        "<p><b>Rationale</b></p>",
        "<p>A called function may provide essential information about its process status and result through return statement. Calling a function without using the return value should be a warning that incorrect assumptions about the process were made.</p>",
        "<p>Overloaded operators are excluded, as they should behave in the same way as built-in operators.</p>",
        "<p><b>Exception</b></p>",
        "<p>The return value of a function call may be discarded by use of a static_cast&lt;void&gt; cast, so intentions of a programmer are explicitly stated.</p>",
        "<p><b>Example</b></p>",
        "<pre>// $Id: A0-1-2.cpp 289436 2017-10-04 10:45:23Z michal.szczepankiewicz $",
        "#include &lt;algorithm&gt;",
        "#include &lt;cstdint&gt;",
        "#include &lt;vector&gt;",
        "std::uint8_t Fn1() noexcept",
        "{",
        "  return 0U;",
        "}",
        "void Fn2() noexcept",
        "{",
        "  std::uint8_t x = Fn1(); // Compliant",
        "  Fn1(); // Non-compliant",
        "  static_cast&lt;void&gt;(Fn1()); // Compliant by exception",
        "}",
        "void Fn3()",
        "{",
        "  std::vector&lt;std::int8_t&gt; v{0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5};",
        "  std::unique(v.begin(), v.end()); // Non-compliant",
        "  v.erase(std::unique(v.begin(), v.end()), v.end()); // Compliant",
        "}",
        "</pre>"
      ]
    }
  },

  "A5-0-2": {
    "tags": ["Language: C", "Language: C++", "Standard: AUTOSAR", "Category: Required", "Automation: Automated", "Expressions"],
    "key": "sti.ConditionOfIfStatementShallBeBool",
    "name": "Published Standards/AUTOSAR/Condition of if statement shall be bool",
    "desc": {
      "text": "Check for the condition of an if-statement or iteration statement not having type bool (C, C++, ObjC)",
      "html": [
        "<p><b>Condition Of If Statement Shall Be Bool (C, C++, ObjC)</b></p>",
        "<p>Check for the condition of an if-statement or iteration statement not having type bool.</p>"
      ]
    }
  },
  "A5-0-1": {
    "key": "unsequenced",
    "tags": ["Language: C", "Language: C++", "Standard: AUTOSAR", "Category: Required", "Automation: Automated", "Expressions"],
    "name": "Published Standards/AUTOSAR/The value of an expression shall be the same under any order of evaluation that the standard permits",
    "desc": {
      "text": "The value of an expression shall be the same under any order of evaluation that the standard permits.",
      "html": [
        "<p><b>Rule</b></p>",
        "<p>The value of an expression shall be the same under any order of evaluation that the standard permits.</p>",
        "<p><b>Rationale</b></p>",
        "<p>Apart from a few operators (notably &&, ||, ?: and ,) the order in which subexpressions are evaluated is unspecified and can vary. This means that no reliance can be placed on the order of evaluation of sub-expressions and, in particular, no reliance can be placed on the order in which side effects occur. Those points in the evaluation of an expression at which all previous side effects can be guaranteed to have taken place are called \"sequencing\". Sequencing and side effects are described in Section 1.9(7) of ISO/IEC 14882:2014 [3].</p>",
        "<p>Note that the \"order of evaluation\" problem is not solved by the use of parentheses, as this is not a precedence issue.</p>",
        "<p><b>Example</b></p>",
        "<pre>",
        "1   // $Id: A5-0-1.cpp 289436 2017-10-04 10:45:23Z michal.szczepankiewicz $",
        "2   #include &lt;cstdint&gt;",
        "3   #include &lt;stack&gt;",
        "4   // The following notes give some guidance on how dependence on order of",
        "5   // evaluation may occur, and therefore may assist in adopting the rule.",
        "6"  ,
        "7   // 1) Increment or decrement operators",
        "8   // As an example of what can go wrong, consider",
        "9   void F1(std::uint8_t (&arr)[10], std::uint8_t idx) noexcept(false)",
        "10  {",
        "11    std::uint16_t x = arr[idx] + idx++;",
        "12  }",
        "13  // This will give different results depending on whether arr[idx] is evaluated",
        "14  // before idx++ or vice versa. The problem could be avoided by putting the",
        "15  // increment operation in a separate statement. For example:",
        "16  void F2(std::uint8_t (&arr)[10], std::uint8_t idx) noexcept(false)",
        "17  {",
        "18    std::uint8_t x = arr[idx] + idx;",
        "19    idx++;",
        "20  }",
        "21" ,
        "22  // 2) Function arguments",
        "23  // The order of evaluation of function arguments is unspecified.",
        "24  extern std::uint8_t Func(std::uint8_t x, std::uint8_t y);",
        "25  void F3() noexcept(false)",
        "26  {",
        "27    std::uint8_t i = 0;",
        "28    std::uint8_t x = Func(i++, i);",
        "29  }",
        "30  // This will give different results depending on which of the functions two",
        "31  // parameters is evaluated first.",
        "32" ,
        "33  // 3) Function pointers",
        "34  // If a function is called via a function pointer there shall be no",
        "35  // dependence",
        "36  // on the order in which function-designator and function arguments are",
        "37  // evaluated.",
        "38  struct S",
        "39  {",
        "40    void TaskStartFn(S* obj) noexcept(false);",
        "41  };",
        "42  void F4(S* p) noexcept(false)",
        "43  {",
        "44    p-&gt;TaskStartFn(p++);",
        "45  }",
        "46" ,
        "47  // 4) Function calls",
        "48  // Functions may have additional effects when they are called (e.g. modifying",
        "49  // some global data). Dependence on order of evaluation could be avoided by",
        "50  // invoking the function prior to the expression that uses it, making use of a",
        "51  // temporary variable for the value. For example:",
        "52  extern std::uint16_t G(std::uint8_t) noexcept(false);",
        "53  extern std::uint16_t Z(std::uint8_t) noexcept(false);",
        "54  void F5(std::uint8_t a) noexcept(false)",
        "55  {",
        "56    std::uint16_t x = G(a) + Z(a);",
        "57  }",
        "58  // could be written as",
        "59  void F6(std::uint8_t a) noexcept(false)",
        "60  {",
        "61    std::uint16_t x = G(a);",
        "62    x += Z(a);",
        "63  }",
        "64  // As an example of what can go wrong, consider an expression to take two values",
        "65  // off a stack, subtract the second from the first, and push the result back on",
        "66  // the stack:",
        "67  std::int32_t Pop(std::stack&lt;std::int32_t&gt;& s)",
        "68  {",
        "69    std::int32_t ret = s.top();",
        "70    s.pop();",
        "71    return ret;",
        "72  }",
        "73  void F7(std::stack&lt;std::int32_t&gt;& s)",
        "74  {",
        "75    s.push(Pop(s) - Pop(s));",
        "76  }",
        "77  // This will give different results depending on which of the pop() function",
        "78  // calls is evaluated first (because pop() has side effects).",
        "79" ,
        "80  // 5) Nested assignment statements",
        "81  // Assignments nested within expressions cause additional side effects. The best",
        "82  // way to avoid any possibility of this leading to a dependence on order of",
        "83  // evaluation is not to embed assignments within expressions. For example, the",
        "84  // following is not recommended:",
        "85  void F8(std::int32_t& x) noexcept(false)",
        "86  {",
        "87    std::int32_t y = 4;",
        "88    x = y = y++; // It is undefined whether the final value of y is 4 or 5",
        "89  }",
        "90  // 6) Accessing a volatile",
        "91  // The volatile type qualifier is provided in C++ to denote objects whose value",
        "92  // can change independently of the execution of the program (for example an",
        "93  // input register). If an object of volatile qualified type is accessed this may",
        "94  // change its value. C++ compilers will not optimize out reads of a volatile. In",
        "95  // addition, as far as a C++ program is concerned, a read of a volatile has a",
        "96  // side effect (changing the value of the volatile). It will usually be",
        "97  // necessary to access volatile data as part of an expression, which then means",
        "98  // there may be dependence on order of evaluation. Where possible, though, it is",
        "99  // recommended that volatiles only be accessed in simple assignment statements,",
        "100 // such as the following:",
        "101 void F9(std::uint16_t& x) noexcept(false)",
        "102 {",
        "103   volatile std::uint16_t v;",
        "104   // ...",
        "105   x = v;",
        "106 }",
        "107",
        "108 // The rule addresses the order of evaluation problem with side effects. Note",
        "109 // that there may also be an issue with the number of times a sub-expression is",
        "110 // evaluated, which is not covered by this rule. This can be a problem with",
        "111 // function invocations where the function is implemented as a macro. For",
        "112 // example, consider the following function-like macro and its invocation:",
        "113 #define MAX(a, b) (((a) &gt; (b)) ? (a) : (b))",
        "114 // ...",
        "115 void F10(std::uint32_t& i, std::uint32_t j)",
        "116 {",
        "117   std::uint32_t z = MAX(i++, j);",
        "118 }",
        "119 // The definition evaluates the first parameter twice if a &gt; b but only once if",
        "120 // a = b. The macro invocation may thus increment i either once or twice,",
        "121 // depending on the values of i and j.",
        "122 // It should be noted that magnitude-dependent effects, such as those due to",
        "123 // floating-point rounding, are also not addressed by this rule. Although",
        "124 // the",
        "125 // order in which side effects occur is undefined, the result of an operation is",
        "126 // otherwise well-defined and is controlled by the structure of the expression.",
        "127 // In the following example, f1 and f2 are floating-point variables; F3, F4",
        "128 // and",
        "129 // F5 denote expressions with floating-point types.",
        "130",
        "131 // f1 = F3 + ( F4 + F5 );",
        "132 // f2 = ( F3 + F4 ) + F5;",
        "133",
        "134 // The addition operations are, or at least appear to be, performed in the order",
        "135 // determined by the position of the parentheses, i.e. firstly F4 is added to F5",
        "136 // then secondly F3 is added to give the value of f1. Provided that F3, F4 and",
        "137 // F5 contain no side effects, their values are independent of the order in",
        "138 // which they are evaluated. However, the values assigned to f1 and f2 are not",
        "139 // guaranteed to be the same because floating-point rounding following the",
        "140 // addition operations are dependent on the values being added.",
        "</pre>",
        "<p><b>See also</b></p>",
        "<ul>",
        "<li>MISRA C++ 2008 [7]: Rule 5-0-1 The value of an expression shall be the same under any order of evaluation that the standard permits</li>",
        "<li>HIC++ v4.0 [9]: 5.1.2: Do not rely on the sequence of evaluation within an expression.</li>",
        "<li>C++ Core Guidelines [11]: ES.40: Avoid complicated expressions</li>",
        "<li>C++ Core Guidelines [11]: ES.43: Avoid expressions with undefined order of evaluation.</li>",
        "<li>C++ Core Guidelines [11]: ES.44: Don't depend on order of evaluation of function arguments.</li>",
        "<li>C++ Core Guidelines [11]: R.13: Perform at most one explicit resource allocation in a single expression statement.</li>",
        "</ul>"
      ]
    }
  },

  "A5-2-6": {
    "tags": ["Language: C", "Language: C++", "Standard: AUTOSAR", "Category: Required", "Automation: Automated", "Expressions"],
    "key": "sti.OperandsOfLogicalBooleanOperators",
    "name": "Published Standards/AUTOSAR/Operands of Logical Boolean Operators",
    "desc": {
      "html": [
        "<p><b>Title</b></p>",
        "<p>The operands of a logical <code>&&</code> or <code>||</code> shall be parenthesized if the operands contain binary operators.</p>",
        "",
        "<p><b>Rationale</b></p>",
        "<p>Parentheses are required to add clarity in logical expressions making code easier to review versus code based only C++ operator precedence rules.</p>",
        "",
        "<p><b>Example</b></p>",
        "<pre><code language=\"C++\">// $Id: A5-2-6.cpp$",
        "",
        "#include &lt;cstdint&gt;",
        "",
        "void Fn(std::int32_t value) noexcept",
        "{",
        "    if (value &gt; 0 && value &lt; 3) // Non-compliant",
        "    {",
        "        // do some work",
        "    }",
        "    else if ((value &gt; 1) && (value &lt; 2)) // Compliant",
        "    {",
        "        // do some work",
        "    }",
        "    else",
        "    {",
        "        // do some work",
        "    }",
        "    return;",
        "}</code></pre>",
        "",
        "<p><b>See also</b></p>",
        "<ul>",
        "<li>MISRA C++ 2008 [7]: M5-2-1: Each operand of a logical && or || shall be a postfix expression.</li>",
        "<li>JSF December 2005 [8]: AV Rule 158: The operands of a logical <code>&&</code> or <code>||</code> shall be parenthesized if the operands contain binary operators.</li>",
        "<li>C++ Core Guidelines [11]: ES.41: If in doubt about operator precedence, parenthesize</li>",
        "</ul>"
      ]
    },
    "options": [
      {
        "id": "sti.OperandsOfLogicalBooleanOperators:AllowChained",
        "text": "Allow chained operations with the same operator",
        "value": true
      }
    ]
  },

  "M5-2-9": {
    "tags": ["Language: C", "Language: C++", "Standard: AUTOSAR", "Category: Required", "Automation: Automated", "Pointers"],
    "key": "sti.PointerToIntCast",
    "name": "Published Standards/AUTOSAR/Pointer to Integer Cast",
    "desc": {
      "html": [
        "<p><b>Rationale</b></p>",
        "<p>The size of integer that is required when a pointer is converted to an integer is <i>implementation-defined</i>. Casting between a pointer and an integer type should be avoided where possible, but may be unavoidable when addressing memory mapped registers or other hardware specific features.</p>",
        "<p>Note that C++ does not permit a pointer to be converted to any floating type.</p>",
        "",
        "<p><b>Example</b></p>",
        "<pre><code language=\"C++\">struct S",
        "{",
        "   int32_t i;",
        "   int32_t j;",
        "};",
        "void f ( S * s )",
        "{",
        "   int32_t p = reinterpret_cast&lt; int32_t &gt;( s );   // Non-compliant",
        "}",
        "</code></pre>"
      ]
    }
  },

  "A4-7-1": {
    "tags": ["Language: C", "Language: C++", "Standard: AUTOSAR", "Category: Required", "Automation: Automated", "Expressions"],
    "keys": ["implicit-int-conversion", "int-conversion", "shorten-64-to-32", "integer-overflow", "constant-conversion"],
    "name": "Published Standards/AUTOSAR/An integer expression shall not lead to data loss.",
    "desc": {
      "text": "An integer expression shall not lead to data loss.",
      "html": [
        "<p><b>Rule</b></p>",
        "<p>An integer expression shall not lead to data loss.</p>",
        "<p><b>Rationale</b></p>",
        "<p>Implicit conversions, casts and arithmetic expressions may lead to data loss, e.g. overflows, underflows or wrap-around.</p>",
        "<p>Integral expressions need to be performed on proper integral types that ensure that the data loss will not occur or appropriate guards should be used to statically detect or counteract such a data loss.</p>",
        "<p><b>Example</b></p>",
        "<pre>",
        "1  // $Id: A4-7-1.cpp 289436 2017-10-04 10:45:23Z michal.szczepankiewicz $",
        "2  #include <cstdint>",
        "3  #include <stdexcept>",
        "4  std::int8_t Fn1(std::int8_t x, std::int8_t y) noexcept",
        "5  {",
        "6    return (x + y); // Non-compliant - may lead to overflow]",
        "7  }",
        "8  std::int8_t Fn2(std::int8_t x, std::int8_t y)",
        "9  {",
        "10   if (x > 100 || y > 100) // Range check",
        "11   {",
        "12     throw std::logic_error(\"Preconditions check error\");",
        "13   }",
        "14   return (x + y); // Compliant - ranges of x and y checked before the",
        "15   // arithmetic operation",
        "16 }",
        "17 std::int16_t Fn3(std::int8_t x, std::int8_t y) noexcept",
        "18 {",
        "19   return (static_cast<std::int16_t>(x) + y); // Compliant - std::int16_t type",
        "20   // is enough for this arithmetic",
        "21   // operation",
        "22 }",
        "23 std::uint8_t Fn4(std::uint8_t x, std::uint8_t y) noexcept",
        "24 {",
        "25   return (x * y); // Non-compliant - may lead to wrap-around",
        "26 }",
        "27 std::int8_t Fn5(std::int16_t x)",
        "28 {",
        "29   return static_cast<std::int8_t>(x); // Non-compliant - data loss",
        "30 }",
        "31 std::int8_t Fn6(std::int16_t x)",
        "32 {",
        "33   return x; // Non-compliant - data loss by implicit conversion",
        "34 }",
        "35 void F()",
        "36 {",
        "37   std::int8_t x1 =",
        "38     Fn1(5, 10); // Compliant - overflow will not occur for these values",
        "39   std::int8_t x2 = Fn1(250, 250); // Non-compliant - Overflow occurs",
        "40   try",
        "41   {",
        "42     std::int8_t x3 =",
        "43       Fn2(250, 250); // Compliant - No overflow, range checks",
        "44     // inside fn2() function",
        "45   }",
        "46   catch (std::logic_error&)",
        "47   {",
        "48     // Handle an error",
        "49   }",
        "50   std::int16_t x4 = Fn3(250, 250); // Compliant - No overflow, arithmetic",
        "51   // operation underlying type is wider than",
        "52   // std::int8_t",
        "53   std::uint8_t x5 = Fn4(50, 10); // Non-compliant - Wrap-around occurs",
        "54   std::int8_t x6 = Fn5(100); // Compliant - data loss will not occur",
        "55   std::int8_t x7 = Fn5(300); // Non-compliant - Data loss occurs",
        "56   std::int8_t x8 = Fn6(300); // Non-compliant - Data loss occurs",
        "57",
        "58   std::int8_t x9 = 150;",
        "59   std::int16_t x10 = static_cast<std::int16_t>(x9 + x9); // Non-compliant",
        "60   x10 = x9 + x9; // Non-compliant",
        "61   x10 = static_cast<std::int16_t>(x9) + x9; // Compliant",
        "62",
        "63   std::int8_t x11 = x9 << 5; // Non-compliant",
        "64",
        "65   std::int8_t x12 = 127;",
        "66   ++x12; // Non-compliant",
        "67",
        "68   std::uint8_t x13 = 255;",
        "69   ++x13; // Non-compliant",
        "70 }",
        "<p><b>See also</b></p>",
        "<ul>",
        "<li>MISRA C++ 2008 [7]: Rule 5-0-6 An implicit integral or floating-point conversion shall not reduce the size of the underlying type.</li>",
        "<li>MISRA C++ 2008 [7]: Rule 5-0-8 An explicit integral or floating-point conversion shall not increase the size of the underlying type of a cvalue expression.</li>",
        "<li>HIC++ v4.0 [9]: 4.2.2 Ensure that data loss does not demonstrably occur in an integral expression.</li>",
        "<li>JSF December 2005 [8]: AV Rule 212: Underflow or overflow functioning shall not be depended on in any special way.</li>",
        "<li>C++ Core Guidelines [11]: ES.46: Avoid lossy (narrowing, truncating) arithmetic conversions.</li>",
        "</ul>"
      ]
    }
  },

  "M5-0-15": {
    "tags": ["Language: C", "Language: C++", "Standard: AUTOSAR", "Category: Required", "Automation: Automated", "Pointers"],
    "key": "sti.ArrayIndexingOverPointerArithmetic",
    "name": "Published Standards/AUTOSAR/Array indexing over pointer arithmetic",
    "desc": {
      "text": "Array indexing shall be the only form of pointer arithmetic",
      "html": [
        "<p><b>Array indexing over pointer arithmetic</b></p>",
        "<p>Array indexing is the only acceptable form of pointer arithmetic, because it is clearer and hence",
        "less error prone than pointer manipulation. This rule bans the explicit calculation of pointer values.",
        "Array indexing shall only be applied to objects defined as an array type.",
        "Any explicitly calculated pointer value has the potential to access unintended or invalid memory",
        "addresses. Pointers may go out of bounds of arrays or structures, or may even point to effectively",
        "arbitrary locations.</p>",
        "<p><b>Limitations</b></p>",
        "<p>This doesn't check the if the array index is operating on a pointer or an array.",
        "Passing an array via a parameter doesn't actually pass an array, it passes a sugared pointer.",
        "Real arrays have different semantics (like their address can't be changed) that sugared pointers don't have.",
        "There is no way to know if a pointer points to an array in general.",
        "</p>"
      ]
    }
  },

  "M6-2-1": {
    "tags": ["Language: C", "Language: C++", "Standard: AUTOSAR", "Category: Required", "Automation: Automated", "Assignment Operators"],
    "key": "sti.AssignmentSubExpressions",
    "name": "Published Standards/AUTOSAR/Assignment operators shall not be used in sub-expressions",
    "desc": {
      "text": "Assignment operators shall not be used in subexpressions.",
      "html": [
        "<p><b>Assignment operators shall not be used in subexpressions</b></p>",
        "<p>Assignments used in a sub-expression add an additional side effect to that of the full expression,",
        "potentially resulting in a value inconsistent with developer expectations. In addition, this helps to",
        "avoid getting = and == confused.</p>"
      ]
    }
  },

  "M6-2-2": {
    "tags": ["Language: C", "Language: C++", "Standard: AUTOSAR", "Category: Required", "Automation: Partially Automated", "Expressions"],
    "keys": ["float-equal","sti.FloatingEqualityTest"],
    "name": "Published Standards/AUTOSAR/Floating-point expressions shall not be directly or indirectly tested for equality or inequality",
    "desc": {
      "text": "Floating Equality Test",
      "html": [
        "<p>Floating-point expressions shall not be directly or indirectly tested for",
        "equality or inequality</p>",
        "<p><b>Rationale</b></p>",
        "<p>The inherent nature of floating-point types is such that comparisons of equality",
        "will often not evaluate to true, even when they are expected to. Also, the",
        "behavior of such a comparison cannot be predicted before execution, and may",
        "well vary from one implementation to another.</p>",
        "<p>The recommended method for achieving deterministic floating-point comparisons",
        "is to write a library that implements the comparison operations. The library",
        "should take into account the floating-point granularity",
        "(<code>std::numeric_limits<float>::epsilon()</code>) and the magnitude of the",
        "numbers being compared.</p>",
        "<p><b>Example</b></p><pre>",
        "// The result of the test in the following code is unpredictable:",
        "float32_t x, y;",
        "if ( x == y )     // Non-compliant",
        "if ( x == 0.0f )  // Non-compliant",
        "// An indirect test is equally problematic and is also prohibited by this rule:",
        "if ( ( x &lt;= y ) && ( x &gt;= y ) )   // Non-compliant",
        "if ( ( x &lt; y ) || ( x &gt; y ) )     // Non-compliant",
        "// The following is better, but only if the magnitudes are appropriate:",
        "if ( fabs ( x - y ) &lt;= std::numeric_limits&lt;float&gt;::epsilon( ) ) //Compliant",
        "</pre>"
      ]
    }
  },


  "A15-4-3": {
    "tags": ["Language: C", "Language: C++", "Standard: AUTOSAR", "Category: Required", "Automation: Automated", "Functions"],
    "keys": ["microsoft-exception-spec"],
    "name": "Published Standards/AUTOSAR/The noexcept specification of a function shall either be identical across all translation units, or identical or more restrictive between a virtual member function and an overrider",
    "desc": {
      "html": [
        "<p><b>Rationale</b></p>",
        "<p>Declarations of the same function, even in different translation units, have to specify the same noexcept specification. Overriding functions have to specify the same or a stricter noexcept specification than the base class function which they override.</p>",
        "<p>Note that in many cases, a violation of this rule will lead to a compilation error. This is not guaranteed, however, in particular when function declarations appear in separate translation units.</p>",
        "<p><b>Example</b></p>",
        "<pre><code language=\"C++\">1 //% $Id: A15-4-3.cpp 317753 2018-04-27 07:44:02Z jan.babst $",
        "// f1.hpp",
        "void Fn() noexcept;",
        "",
        "// f1.cpp",
        "// #include &lt;f1.hpp&gt;",
        "void Fn() noexcept // Compliant",
        "{",
        "// Implementation",
        "}",
        "",
        "// f2.cpp",
        "// #include &lt;f1.hpp&gt;",
        "void Fn() noexcept(false) // Non-compliant - different exception specifier",
        "{",
        "// Implementation",
        "}",
        "",
        "class A",
        "{",
        "public:",
        "void F() noexcept;",
        "void G() noexcept(false);",
        "virtual void V1() noexcept = 0;",
        "virtual void V2() noexcept(false) = 0;",
        "};",
        "void A::F() noexcept // Compliant",
        "// void A::F() noexcept(false) // Non-compliant - different exception specifier",
        "// than in declaration",
        "{",
        "// Implementation",
        "}",
        "void A::G() noexcept(false) // Compliant",
        "// void A::G() noexcept // Non-compliant - different exception specifier than",
        "// in declaration",
        "{",
        "// Implementation",
        "}",
        "class B : public A",
        "{",
        "public:",
        "void V1() noexcept override // Compliant",
        "// void V1() noexcept(false) override // Non-compliant - less restrictive",
        "// exception specifier in derived method, non-compilable",
        "{",
        "// Implementation",
        "}",
        "void V2() noexcept override // Compliant - stricter noexcept specification",
        "{",
        "// Implementation",
        "}",
        "};",
        "</code></pre>",
        "<p><b>See also</b></p>",
        "<p>MISRA C++ 2008 [7]: 15-4-1: If a function is declared with an exceptionspecification, then all declarations of the same function (in other translation units) shall be declared with the same set of type-ids.</p>"
      ]
    }
  },
  "M0-1-2": {
    "tags": ["Language: C", "Language: C++", "Standard: AUTOSAR", "Category: Required", "Automation: Automated", "Expressions"],
    "keys": ["tautological-bitwise-compare", "tautological-compare", "tautological-constant-compare", "tautological-constant-in-range-compare", "tautological-constant-out-of-range-compare", "tautological-objc-bool-compare", "tautological-overlap-compare", "tautological-pointer-compare", "tautological-type-limit-compare", "tautological-undefined-compare", "tautological-unsigned-char-zero-compare", "tautological-unsigned-enum-zero-compare", "tautological-unsigned-zero-compare", "tautological-value-range-compare"],
    "name": "Published Standards/AUTOSAR/A project shall not contain infeasible paths",
    "desc": {
      "html": [
        "<p>A <i>project</i> shall not contain <i>infeasible paths</i></p>",
        "<p><b>Rationale</b></p>",
        "<p><i>Infeasible paths</i> occur where there is a syntactic path but the semantics ensure that the control flow path cannot be executed by any input data. One of the major problems here is the explosion of <i>infeasible paths</i> caused by:</p>",
        "<ul>",
        "<li><i>if</i> ... <i>else</i> statement sequences;</li>",
        "<li>Sequences of poorly chosen loop constructs</li>",
        "</ul>",
        "<p>Errors in conditions and poorly designed logic contribute to this problem. It is always possible to rewrite the code to eliminate these constructs. This process may then reveal faults.</p>",
        "<p>There is the possibility that protective coding techniques generate infeasible code. This code is usually executable (and hence feasible) in a unit testing environment.</p>",
        "<p><b>Example</b></p>",
        "<pre>",
        "void infeas ( uint8_t para, uint8_t outp )",
        "{",
        "   // The condition below will always be true hence the path",
        "   // for the false condition is infeasible. Non-compliant.",
        "   if ( para &gt;= 0U )",
        "   {",
        "      outp = 1U;",
        "   }",
        "",
        "   // The following if statement combines with the if",
        "   // statement above to give four paths. One from",
        "   // the first condition is already infeasible and",
        "   // the condition below combined with assignment above",
        "   // makes the false branch infeasible. There is therefore",
        "   // only one feasible path through this code.",
        "   if ( outp == 1U )",
        "   {",
        "      outp = 0U;",
        "   }",
        "}",
        "",
        "enum ec { RED, BLUE, GREEN } col;",
        "",
        "if ( col &lt;= GREEN ) // Non-compliant - always true",
        "{",
        " // Will always get here",
        "}",
        "else",
        "{",
        " // Will never get here",
        "}",
        "",
        "// The following ifs exhibit similar behaviour.",
        "// Note that u16a is a 16-bit unsigned integer",
        "// and s8a is an 8-bit signed integer.",
        "",
        "if ( u16a &lt; 0U ) // Non-compliant - u16a is always &gt;= 0",
        "",
        "if ( u16a &lt;= 0xffffU ) // Non-compliant - always true",
        "",
        "if ( s8a &lt; 130 ) // Non-compliant - always true",
        "",
        "if ( ( s8a &lt; 10 ) && ( s8a &gt; 20 ) ) // Non-compliant - always false",
        "",
        "if ( ( s8a &lt; 10 ) || ( s8a &gt; 5 ) ) // Non-compliant - always true",
        "",
        "// Nested conditions can also cause problems",
        "if ( s8a &gt; 10 )",
        "{",
        "   if ( s8a &gt; 5 ) // Non-compliant, unless s8a volatile",
        "   {",
        "      // Will always get here.",
        "   }",
        "}",
        "</pre>",
        "<p><b>Developer's Notes</b></p>",
        "<p>This check does not find control-flow that is impossible to go to, such as sequences of poorly chosen loop constructs. It simply finds some expressions which are always true or always false.</p>",
        "<p>In the MISRA C++ 2008 example for rule 0-1-2, there are 2 non-compliant parts that this check misses. An enum can actually be outside of the enum range via casting, so this is not checked. The nested condition is also not checked.</p>"
      ]
    }
  },

  "M0-1-3": {
    "tags": ["Language: C", "Language: C++", "Standard: AUTOSAR", "Category: Required", "Automation: Automated", "Variables"],
    "keys": ["unused-variable","unused-const-variable"],
    "name": "Published Standards/AUTOSAR/A project shall not contain unused variables",
    "test": "CPP_V007",
    "desc": {
      "text": "Check for variables that are unused (C, C++, ObjC)",
      "html": [
        "<p><b>Unused Variables (C, C++, ObjC)</b></p>",
        "<p>Variables declared and never used in a project constitute noise and may ",
        "indicate that the wrong variable name has been used somewhere. Removing these",
        "declarations reduces the possibility that they may later be used instead of ",
        "the correct variable. If padding is used within bit-fields, then the padding",
        "member should be unnamed to avoid violation of this rule.</p>",
        "<p>Check ignores references inside inactive code (ie #if 0...#endif).</p>",
        "<p><b>Example</b></p><pre>",
          "extern void usefn ( int16_t a, int16_t b );",
          "class C ",
          "{ ",
          "   ... ",
          "};",
          "C c;                         // Non-compliant - unused",
          "void withunusedvar ( void ) ",
          "{ ",
          "   int16_t unusedvar;        // Non-compliant - unused",
          "   struct s_tag ",
          "   { ",
          "      signed int a   : 3; ",
          "      signed int pad : 1;    // Non-compliant - should be unnamed ",
          "      signed int b   : 2; ",
          "   } s_var;",
          "   s_var.a = 0; ",
          "   s_var.b = 0; ",
          "   usefn ( s_var.a, s_var.b ); ",
          "}</pre>"
      ]
    }
  },

  "A8-4-2": {
    "tags": ["Language: C", "Language: C++", "Standard: AUTOSAR", "Category: Required", "Automation: Automated", "Functions"],
    "key": "return-type",
    "name": "Published Standards/AUTOSAR/Always return a value in non-void functions",
    "desc": {
      "html": [
        "<p>Always return a value in non-void functions.</p>",
        "<p><b>Rationale</b></p>",
        "<p>In a function with non-void return type, return expression gives the value that the function returns. The absence of a return with an expression leads to undefined behavior (and the compiler may not give an error).</p>",
        "<p><b>Exception</b></p>",
        "<p>A function may additionally exit due to exception handling (i.e. a throw statement).</p>",
        "<p><b>Example</b></p>",
        "<pre>",
        "// $Id: A8-4-2.cpp 289436 2017-10-04 10:45:23Z michal.szczepankiewicz $",
        "#include &lt;cstdint&gt;",
        "#include &lt;stdexcept&gt;",
        "std::int32_t F1() noexcept // Non-compliant",
        "{",
        "}",
        "std::int32_t F2(std::int32_t x) noexcept(false)",
        "{",
        "if (x &gt; 100)",
        "    {",
        "        throw std::logic_error(\"Logic Error\"); // Compliant by exception",
        "    }",
        "    return x; // Compliant",
        "}",
        "std::int32_t F3(std::int32_t x, std::int32_t y)",
        "{",
        "    if (x &gt; 100 || y &gt; 100)",
        "    {",
        "        throw std::logic_error(\"Logic Error\"); // Compliant by exception",
        "    }",
        "    if (y &gt; x)",
        "    {",
        "        return (y - x); // Compliant",
        "    }",
        "    return (x - y); // Compliant",
        "}",
        "</pre>",
        "<p><b>See also</b></p>",
        "<p>MISRA C++ 2008 [7]: Rule 8-4-3 All exit paths from a function with non-void return type shall have an explicit return statement with an expression.</p>",
        "<p>SEI CERT C++ [10]: MSC52-CPP. Value-returning functions must return a value from all exit paths.</p>",
        "<p><b>Developer's Notes</b></p>",
        "<p>This check utilizes the clang warning -Wreturn-type and this warning can occasionally produce false positives when analyzing complex control flows, such as Microsoft’s Structured Exception Handling (__try/__except) blocks, as Clang may conservatively assume an unhandled exception could bypass a return statement, even when all paths are covered.</p>"
      ]
    }
  },

  "A10-3-2": {
    "tags": ["Language: C++", "Standard: AUTOSAR", "Category: Required", "Automation: Automated", "Functions"],
    "key": "modernize-use-override",
    "name": "Published Standards/AUTOSAR/Use Override",
    "desc": {
      "html": [
        "<p><b>Title</b></p>",
        "<p>Each overriding virtual function shall be declared with the override or final",
        "specifier.</p>",

        "<p><b>Rationale</b></p>",
        "<p>Explicit use of the override or final specifier enables the compiler to catch mismatch of types and names between base and derived classes virtual functions.</p>",
        "<p>Note that this rule applies to virtual destructor overriders, too.</p>",
        "<p>Also, note that this rule applies to a pure virtual function which overrides another pure virtual function.</p>",

        "<p><b>Example</b></p>",
        "<pre><code language=\"C++\">// $Id: A10-3-2.cpp 289436 2017-10-04 10:45:23Z michal.szczepankiewicz $",
        "class A",
        "{",
        "  public:",
        "    virtual ~A() {}",
        "    virtual void F() noexcept = 0;",
        "    virtual void G() noexcept {}",
        "    virtual void Z() noexcept {}",
        "    virtual A& operator+=(A const& oth) = 0;",
        "};",
        "class B : public A",
        "{",
        "  public:",
        "    ~B() override {}   // Compliant",
        "    void F() noexcept  // Non-compliant",
        "    {",
        "    }",
        "    virtual void G() noexcept  // Non-compliant",
        "    {",
        "    }",
        "    void Z() noexcept override  // Compliant",
        "    {",
        "    }",
        "    B& operator+=(A const& oth) override  // Compliant",
        "    {",
        "        return *this;",
        "    }",
        "};",
        "class C : public A",
        "{",
        "  public:",
        "    ~C() {}                     // Non-compliant",
        "    void F() noexcept override  // Compliant",
        "    {",
        "    }",
        "    void G() noexcept override  // Compliant",
        "    {",
        "    }",
        "    void Z() noexcept override  // Compliant",
        "    {",
        "    }",
        "    C& operator+=(A const& oth)  // Non-compliant",
        "    {",
        "        return *this;",
        "    }",
        "};</code></pre>",

        "<p><b>See also</b></p>",
        "<ul>",
        "<li>HIC++ v4.0 [9]: 10.2.1 Use the override special identifier when overriding a virtual function</li>",
        "<li>C++ Core Guidelines [11]: C.128: Virtual functions should specify exactly one of virtual, override, or final.</li>",
        "</ul>"
      ]
    }
  },

  "A17-0-1": {
    "tags": ["Language: C", "Language: C++", "Standard: AUTOSAR", "Category: Required", "Automation: Automated", "Libraries"],
    "key": "builtin-macro-redefined",
    "name": "Published Standards/AUTOSAR/Reserved Builtin Macros",
    "desc": {
      "text": "Reserved identifiers, macros and functions in the C++ standard library shall not be defined, redefined or undefined (C, C++, ObjC)",
      "html": [
        "<p><b>Reserved Builtin Macros (C, C++, ObjC)</b></p>",
        "<p>Reserved identifiers, macros and functions in the C++ standard library shall not be defined, redefined or undefined.</p>"
      ]
    }
  },

  "A5-3-3": {
    "tags": ["Language: C", "Language: C++", "Standard: AUTOSAR", "Category: Required", "Automation: Automated", "Pointers"],
    "key": "delete-incomplete",
    "name": "Published Standards/AUTOSAR/Deleting Pointers to Incomplete Class Types",
    "desc": {
      "text": "Pointers to incomplete class types shall not be deleted (C, C++, ObjC)",
      "html": [
        "<p><b>Deleting Pointers to Incomplete Class Types (C, C++, ObjC)</b></p>",
        "<p>Incomplete class types are forward declared class types, for which the compiler has not yet seen a definition. It is undefined behavior",
        "if a pointer to an incomplete class type is deleted, and the class has a non-trivial destructor or a deallocation function. This rule ",
        "prohibits deletion of such a pointer even in the harmless case of a trivially destructible class type without a deallocation function, ",
        "since a non-trivial destructor or a deallocation function may be added later as the code evolves.</p>"
      ]
    }
  },

  "A15-5-3": {
    "tags": ["Language: C", "Language: C++", "Standard: AUTOSAR", "Category: Required", "Automation: Automated", "Control Flow"],
    "key": "sti.NoImplicitTerminate",
    "name": "Published Standards/AUTOSAR/The std::terminate() function shall not be called implicitly",
    "desc": {
      "text": "The std::terminate() function shall not be called implicitly (C, C++, ObjC)",
      "html": [
        "<p><b>Implicit calls to std::terminate() (C, C++, ObjC)</b></p>",
        "<p>It is implementation-defined whether the call stack is unwound before std::terminate() is called. There is no guarantee that the destructors of automatic thread or static storage duration objects will be called.</p>"
      ]
    }
  },

  "A15-5-2": {
    "tags": ["Language: C", "Language: C++", "Standard: AUTOSAR", "Category: Required", "Automation: Automated", "Control Flow"],
    "keys": ["sti.AbruptlyTerminate","exceptions"],
    "name": "Published Standards/AUTOSAR/Program shall not be abruptly terminated",
    "desc": {
      "text": "Abrupt",
      "html": [
        "<p>Program shall not be abruptly terminated. In particular, an implicit or explicit invocation of std::abort(), std::quick_exit(), std::_Exit(),std::terminate() shall not be done.</p>",
        "<p><b>Rationale</b></p>",
        "<p>Functions that are used to terminate the program in an immediate fashion, i.e. std::abort(), std::quick_exit(), std::_Exit(), do so without calling exit handlers or calling destructors of automatic, thread or static storage duration objects. It is implementationdefined whether opened streams are flushed and closed, and temporary files are removed.</p>",
        "<p>The std::terminate() function calls std::abort() implicitly in its terminate handler, and it is implementation-defined whether or not stack unwinding will occur.</p>",
        "<p>Note: std::terminate_handler shall not be used.</p>",
        "<p><b>Example</b></p>",
        "<pre>",
        "1  //% $Id: A15-5-2.cpp 289436 2017-10-04 10:45:23Z michal.szczepankiewicz $",
        "2  #include <cstdlib>",
        "3  #include <exception>",
        "4  void F1() noexcept(false);",
        "5  void F2() // Non-compliant",
        "6  {",
        "7    F1(); // A call to throwing f1() may result in an implicit call to",
        "8    // std::terminate()",
        "9  }",
        "10 void F3() // Compliant",
        "11 {",
        "12   try",
        "13   {",
        "14     F1(); // Handles all exceptions from f1() and does not re-throw",
        "15   }",
        "16   catch (...)",
        "17   {",
        "18     // Handle an exception",
        "19   }",
        "20 }",
        "21 void F4(const char* log)",
        "22 {",
        "23   // Report a log error",
        "24   // ...",
        "25   std::exit(0); // Call std::exit() function which safely cleans up resources",
        "26 }",
        "27 void F5() // Compliant by exception",
        "28 {",
        "29   try",
        "30   {",
        "31     F1();",
        "32   }",
        "33   catch (...)",
        "34   {",
        "35     F4(\"f1() function failed\");",
        "36   }",
        "37 }",
        "38 int main(int, char**)",
        "39 {",
        "40   if (std::atexit(&F2) != 0)",
        "41   {",
        "42     // Handle an error",
        "43   }",
        "44",
        "45   if (std::atexit(&F3) != 0)",
        "46   {",
        "47     // Handle an error",
        "48   }",
        "49",
        "50   // ...",
        "51   return 0;",
        "52 }",
        "</pre>"
      ]
    }
  },

  "M6-4-7": {
    "tags": ["Language: C", "Language: C++", "Standard: AUTOSAR", "Category: Required", "Automation: Automated", "Control Flow"],
    "key": "switch-bool",
    "name": "Published Standards/AUTOSAR/The condition of a switch statement shall not have bool type",
    "test": "CPP_CF000",
    "desc": {
      "html": [
        "<p><b>Rationale</b></p>",
        "<p>An <i>if</i> statement gives a clearer representation for a Boolean choice.</p>",
        "<p><b>Example</b></p>",
        "<pre>",
        "switch ( x == 0)   // Non-compliant",
        "{",
        "   ...",
        "}",
        "</pre>"
      ]
    }
  },

  "A5-6-1B": {
    "tags": ["Language: C", "Language: C++", "Standard: AUTOSAR", "Category: Required", "Automation: Automated", "Expressions"],
    "key": "division-by-zero",
    "name": "Published Standards/AUTOSAR/The right hand operand of the integer division or remainder operators shall not be equal to zero",
    "desc": {
      "html": [
        "<p><b>Rationale</b></p>",
        "<p>The result is undefined if the right hand operand of the integer division or",
        "the remainder operator is zero.</p>",
        "<p><b>Example</b></p>",
        "<pre>",
        "1  // $Id: A5-6-1.cpp 305629 2018-01-29 13:29:25Z piotr.serwa $",
        "2  #include <cstdint>",
        "3  #include <stdexcept>",
        "4  std::int32_t Division1(std::int32_t a, std::int32_t b) noexcept",
        "5  {",
        "6    return (a / b); // Non-compliant - value of b could be zero",
        "7  }",
        "8  std::int32_t Division2(std::int32_t a, std::int32_t b)",
        "9  {",
        "10   if (b == 0)",
        "11   {",
        "12     throw std::runtime_error(\"Division by zero error\");",
        "13   }",
        "14   return (a / b); // Compliant - value of b checked before division",
        "15 }",
        "16 double Fn()",
        "17 {",
        "18   std::int32_t x = 20 / 0; // Non-compliant - undefined behavior",
        "19   x = Division1(20, 0); // Undefined behavior",
        "20   x = Division2(20,",
        "21   0); // Preconditions check will throw a runtime_error from",
        "22   // division2() function",
        "23   std::int32_t remainder = 20 % 0; // Non-compliant - undefined behavior",
        "24 }",
        "</pre>",
        "<p><b>Developer's Notes</b></p>",
        "<p>Part A of this check will check for simple violations that regard variables",
        "that could possibly equal zero. Also this check only checks for if it is used",
        "in an if statement. It does not check the actual logic of the if statement.</p>",
        "<p>Part B of this check uses utilize clang warnings that catch violations",
        "regarding literal digits and their expressions</p>"
      ]
    }
  },

  "A5-2-5B": {
    "tags": ["Language: C", "Language: C++", "Standard: AUTOSAR", "Category: Required", "Automation: Automated", "Types"],
    "key": "array-bounds",
    "name": "Published Standards/AUTOSAR/An array or container shall not be accessed beyond its range Part B",
    "desc": {
      "html": [
        "<p><b>Rationale</b></p>",
        "<p>To avoid undefined behavior, range checks should be coded to ensure that container access via iterator arithmetic or subscript operator is within defined bounds. This could also be achieved by accessing an array via a subscript operator with constant indices only.</p>",
        "<p>When copying data via standard library algorithms (such as std::copy or std::transform), the target destination must be guaranteed to be large enough to hold the data.</p>",
        "<p>Note: This rule applies to C-style arrays and all other containers (including std::basic_string) that access their elements via iterators or via an index. The term iterator includes pointers.</p>",
        "<p>Note: Calculating an iterator one past the last element of the array is well defined, but dereferencing such an iterator is not.</p>",
        "<p><b>Example</b></p>",
        "<pre>",
        "1  // $Id: A5-2-5.cpp 289436 2017-10-04 10:45:23Z michal.szczepankiewicz $",
        "2  #include <array>",
        "3  #include <cstdint>",
        "4  #include <iostream>",
        "5  void Fn1() noexcept",
        "6  {",
        "7    constexpr std::int32_t arraySize = 16;",
        "8    std::int32_t array[arraySize]{0};",
        "9",
        "10   std::int32_t elem1 =",
        "11   array[0]; // Compliant - access with constant literal that",
        "12   // is less than ArraySize",
        "13   std::int32_t elem2 =",
        "14   array[12]; // Compliant - access with constant literal that",
        "15   // is less than ArraySize",
        "16   for (std::int32_t idx = 0; idx < 20; ++idx)",
        "17   {",
        "18     std::int32_t elem3 =",
        "19     array[idx]; // Non-compliant - access beyond ArraySize",
        "20     // bounds, which has 16 elements",
        "21   }",
        "22",
        "23   std::int32_t shift = 25;",
        "24   std::int32_t elem4 =",
        "25   *(array + shift); // Non-compliant - access beyond ArraySize bounds",
        "26",
        "27   std::int32_t index = 0;",
        "28   std::cin >> index;",
        "29   std::int32_t elem5 =",
        "30   array[index]; // Non-compliant - index may exceed the ArraySize bounds",
        "31   if (index < arraySize)",
        "32   {",
        "33     std::int32_t elem6 = array[index]; // Compliant - range check coded",
        "34   }",
        "35 }",
        "36 void Fn2() noexcept",
        "37 {",
        "38   constexpr std::int32_t arraySize = 32;",
        "39   std::array<std::int32_t, arraySize> array;",
        "40   array.fill(0);",
        "41",
        "42   std::int32_t elem1 =",
        "43   array[10]; // Compliant - access with constant literal that",
        "44   // is less than ArraySize",
        "45   std::int32_t index = 40;",
        "46   std::int32_t elem2 =",
        "47   array[index]; // Non-compliant - access beyond ArraySize bounds",
        "48   try",
        "49   {",
        "50     std::int32_t elem3 =",
        "51     array.at(50); // Compliant - at() method provides a",
        "52     // range check, throwing an exception if",
        "53     // input exceeds the bounds",
        "54   }",
        "55   catch (std::out_of_range&)",
        "56   {",
        "57     // Handle an error",
        "58   }",
        "59",
        "60   for (auto&& e : array) // The std::array provides a possibility to iterate",
        "61   // over its elements with range-based loop",
        "62   {",
        "63     // Iterate over all elements",
        "64   }",
        "65 }",
        "</pre>"
      ]
    }
  },

  "A5-5-1": {
    "tags": ["Language: C", "Language: C++", "Standard: AUTOSAR", "Category: Required", "Automation: Automated", "Pointers"],
    "key": "sti.PointerToNonExistentClassMembers",
    "name": "Published Standards/AUTOSAR/A pointer to member shall not access non-existent class members",
    "desc": {
      "html": [
        "<p><b>Rationale</b></p>",
        "<p>Usage of a pointer-to-member expression leads to undefined behavior in the following cases:</p>",
        "<p>1) The pointer to member is a null pointer.</p>",
        "<p>2) The dynamic type of the object does not contain the member to which the called pointer to member refers.</p>",
        "<p><b>Example</b></p>",
        "<pre>",
        "1  // $Id: A5-5-1.cpp 302200 2017-12-20 17:17:08Z michal.szczepankiewicz $",
        "2  ",
        "3  class A",
        "4  {",
        "5  public:",
        "6      virtual ~A() = default",
        "7  };",
        "8  ",
        "9  class AA : public A",
        "10 {",
        "11 public:",
        "12     virtual ~AA() = default;",
        "13     virtual void foo() { } ",
        "14  ",
        "15     using ptr = void (AA::*)();",
        "16 };",
        "17  ",
        "18 Class B",
        "19 {",
        "20 public:",
        "21     static AA::ptr foo_ptr2",
        "22 };",
        "23  ",
        "24 AA::ptr B::foo_ptr2;",
        "25  ",
        "26 int main(void)",
        "27 {",
        "28     A* a = new A();",
        "29     void (A::*foo_ptr1)() = static_cast<void(A::*)()>(&AA::foo);",
        "30     (a->*foo_ptr1)(); // non-compliant",
        "31     delete a;",
        "32  ",
        "33     AA* aa = new AA();",
        "34     (aa->*B::foo_ptr2)(); // non-compliant, not explicitly initialized",
        "35     delete aa;",
        "36  ",
        "37     return 0;",
        "38 }",
        "</pre>"
      ]
    }
  },

   "A7-6-1": {
    "tags": ["Language: C", "Language: C++", "Standard: AUTOSAR", "Category: Required", "Automation: Automated", "Functions"],
    "key": "invalid-noreturn",
    "name": "Published Standards/AUTOSAR/Functions declared with the [[noreturn]] attribute shall not return",
    "test": "CPP_F067",
    "desc": {
      "html": [
        "<p><b>Rationale</b></p>",
        "<p>The C++ standard specifies that functions with the [[noreturn]] attribute shall not return. Returning from such a function can be prohibited in the following way: </p>",
        "<p>throwing an exception, entering an infinite loop, or calling another function with the [[noreturn]] attribute. Returning from such a function leads to undefined behavior.</p>",
        "<p><b>Example</b></p>",
        "<pre>",
        "1 // $Id: A7-6-1.cpp 305629 2018-01-29 13:29:25Z piotr.serwa $",
        "2 #include <cstdint>",
        "3 #include <exception>",
        "4 class PositiveInputException : public std::exception {};",
        "5 ",
        "6 [[noreturn]] void f(int i)  //non-compliant",
        "7 {",
        "8   if (i > 0) {",
        "9     throw PositiveInputException();",
        "10   }",
        "11 //undefined behavior for non-positive i",
        "12 }",
        "13 [[noreturn]] void g(int i) //compliant",
        "14 {",
        "15   if (i > 0) {",
        "16     throw \"Received positive input\";",
        "17   }",
        "18   while(1) {",
        "19 //do processing",
        "20   }",
        "21 }",
        "22 ",
        "</pre>"
      ]
    }
  },

   "M15-3-3": {
    "tags": ["Language: C", "Language: C++", "Standard: AUTOSAR", "Category: Required", "Automation: Automated", "Exception Handling"],
    "key": "exceptions",
    "name": "Published Standards/AUTOSAR/Handlers of a function-try-block implementation of a class constructor or destructor shall not reference non-static members from this class or its bases",
    "desc": {
      "html": [
        "<p><b>Rationale</b></p>",
        "<p>The effect of accessing a non-static member of a class or a base class in the handler (i.e. the catch part) of a function-try-block of a class constructor/destructor is undefined.</p>",
        "<p>For example, if a memory allocation exception is thrown during creation of the object, the object will not exist when the handler attempts to access its members. Conversely, in the destructor, the object may have been successfully destroyed before the exception is handled, so again will not be available to the handler.</p>",
        "<p>By contrast, the lifetime of a static member is greater than that of the object itself, so the static member is guaranteed to exist when the handler accesses it.</p>",
        "<p><b>Example</b></p>",
        "<pre>",
        "1 #include <cstdint>",
        "2 class C",
        "3 {",
        "4 public:",
        "5   int32_t x;",
        "6   C ( )",
        "7   try",
        "8   {",
        "9     // Action that may raise an exception",
        "10  }",
        "11   catch ( ... )",
        "12   {",
        "13     if ( 0 == x ) // UNDCC_Violation - x may not exist at this point",
        "14     {",
        "15       // Action dependent on value of x",
        "16     }",
        "17   }",
        "18   ~C ( )",
        "19   try",
        "20   {",
        "21     // Action that may raise an exception",
        "22   }",
        "23   catch ( ... )",
        "24   {",
        "25     if ( 0 == x ) // UNDCC_Violation - x may not exist at this point",
        "26     {",
        "27       // Action dependent on value of x",
        "28     }",
        "29   }",
        "30 };",
        "</pre>"
      ]
    }
  },

   "M15-3-4": {
    "tags": ["Language: C", "Language: C++", "Standard: AUTOSAR", "Category: Required", "Automation: Automated", "Exception Handling"],
    "key": "exceptions",
    "name": "Published Standards/AUTOSAR/Each exception explicitly thrown in the code shall have a handler of a compatible type in all call paths that could lead to that point",
    "desc": {
      "html": [
        "<p><b>Rationale</b></p>",
        "<p>If a program throws an unhandled exception, it terminates in an implementation-defined manner. In particular, it is implementation-defined whether the call stack is unwound before termination, so the destructors of any automatic objects may or may not be invoked.</p>",
        "<p>If an exception is thrown as an object of a derived class, a “compatible type” may be either the derived class or any of its bases.</p>",
        "<p>The objective of this rule is that a program should catch all exceptions that it is expected to throw. The objective of Rule 15-3-2 is to ensure that exceptions that were not expected are also caught.</p>",
        "<p><b>Example</b></p>",
        "<pre>",
        "1 class A {};",
        "2 class B {};",
        "3 ",
        "4 void f ( int32_t i ) throw ()",
        "5 {",
        "6   try",
        "7   {",
        "8     if ( i > 10 )",
        "9     {",
        "10      throw A (); // UNDCC_Valid",
        "11    }",
        "12    else",
        "13    {",
        "14      throw B (); // UNCC_Violation",
        "15    }",
        "16    catch ( A const & )",
        "17    {",
        "18    }",
        "19 }",
        "</pre>"
      ]
    }
  },

   "M15-3-6": {
    "tags": ["Language: C", "Language: C++", "Standard: AUTOSAR", "Category: Required", "Automation: Automated", "Exception Handling"],
    "key": "exceptions",
    "name": "Published Standards/AUTOSAR/Order of Catch Blocks with Derived Classes",
    "desc": {
      "html": [
        "<p>Where multiple handlers are provided in a single <i>try-catch</i> statement or <i>function-try-block</i> for a derived class and some or all of its bases, the handlers shall be ordered most-derived to base class</p>",
        "<p><b>Rationale</b></p>",
        "<p>When testing to see if the type of an exception matches the type of a handler, a derived class exception will match with a handler for its base class. If the base class handler is found before the handler for the derived class, the base class handler will be used. The derived class handler is <i>unreachable code</i> and can never be executed.</p>",
        "<p><b>Example</b></p>",
        "<pre>",
        "1  // classes used for exception handling",
        "2  class B {};",
        "3  class D: public B {};",
        "4  try",
        "5  {",
        "6    //...",
        "7  }",
        "8  catch ( D &d ) // Compliant - Derived class caught before base class",
        "9  {",
        "10   //...",
        "11 }",
        "12 catch ( B &b ) // Compliant - Base class caught after derived class",
        "13 {",
        "14   //...",
        "15 }",
        "16 // Using the classes from above",
        "17 try",
        "18 {",
        "19   //...",
        "20 }",
        "21 catch ( B &b )",
        "22 {",
        "23   //...",
        "24 }",
        "25 catch ( D &d ) // Non-compliant - Derived class will be caught above",
        "26 {",
        "27   // Any code here will be unreachable,",
        "28   // breaking rule 0-1-1",
        "29 }",
        "</pre>"
      ]
    }
  },

   "A15-4-2": {
    "tags": ["Language: C", "Language: C++", "Standard: AUTOSAR", "Category: Required", "Automation: Automated", "Exception Handling"],
    "key": "exceptions",
    "name": "Published Standards/AUTOSAR/If a function is declared to be noexcept, noexcept(true) or noexcept(<truecondition>), then it shall not exit with an exception",
    "desc": {
      "html": [
        "<p><b>Rationale</b></p>",
        "<p>If a function declared to be noexcept, noexcept(true) or noexcept(true condition) throws an exception, then std::terminate() is called immediately. It is implementation-defined whether the call stack is unwound before std::terminate() is called.</p>",
        "<p>To ensure that the rule is not violated, if function's noexcept specification can not be determined, then always declare it to be noexcept(false).</p>",
        "<p><b>Example</b></p>",
        "<pre>",
        "1  //% $Id: A15-4-2.cpp 289436 2017-10-04 10:45:23Z michal.szczepankiewicz $",
        "2  #include <stdexcept>",
        "3  // library.h",
        "4  void LibraryFunc();",
        "5  // project.cpp",
        "6  void F1() noexcept",
        "7  {",
        "8    // ...",
        "9    throw std::runtime_error(\"Error\"); // violation - F1 declared to be",
        "10   // noexcept, but exits with exception",
        "11   // this leads to std::terminate() call",
        "12 }",
        "13 void F2() noexcept(true)",
        "14 {",
        "15   try",
        "16   {",
        "17     // ...",
        "18     throw std::runtime_error(",
        "19       \"Error\");  // valid - exception will not leave F2",
        "20   }",
        "21   catch (std::runtime_error& e",
        "22   {",
        "23     // Handle runtime error",
        "24   }",
        "25 }",
        "26 void F3() noexcept(false)",
        "27 {",
        "28   // ...",
        "29   throw std::runtime_error(\"Error\"); // valid",
        "30 }",
        "31 void F4() noexcept(",
        "32   false) // valid - no information whether library_func() throws or not",
        "33 {",
        "34   LibraryFunc();",
        "35 }",
        "</pre>"
      ]
    }
  },
   "M5-18-1": {
    "tags": ["Language: C", "Language: C++", "Standard: AUTOSAR", "Category: Required", "Automation: Automated", "Expressions"],
    "key": "comma",
    "name": "Published Standards/AUTOSAR/The comma operator shall not be used.",
    "desc": {
      "html": [
        "<p><b>Rationale</b></p>",
        "<p>The comma operator (represented by the token , ) is a binary operator that evaluates its first operand and discards the result, it then evaluates the second operand and returns this value (and type). The comma operator has the lowest precedence of any C operator, and acts as a sequence point.</p>",
        "<p>Use of the comma operator is generally detrimental to the readability of code, and the same effect can be achieved by other means.</p>",
        "<p><b>Example</b></p>",
        "<pre><code language=\"C++\">f ( ( 1, 2 ), 3 ); // Non-compliant – how many parameters?</code></pre>"
      ]
    }
  }
}
