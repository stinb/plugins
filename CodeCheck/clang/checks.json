{
  "CPP_D001": {
    "tags": ["Language: C++", "Destructors"],
    "key": "delete-non-abstract-non-virtual-dtor",
    "name": "All Checks/Language Specific/C and C++/Destructors/Do not delete a polymorphic object without a virtual destructor",
    "desc": {
      "html": [
        "<p><b>Title</b></p>",
        "<p>Do not delete a polymorphic object without a virtual destructor</p>",

        "<p><b>Risk Assessment</b></p>",
        "<p>Attempting to destruct a polymorphic object that does not have a <code>virtual</code> destructor declared results in undefined behavior. In practice, potential consequences include abnormal program termination and memory leaks.</p>",

        "<p><b>Full Standard</b></p>",
        "<p><a href='https://wiki.sei.cmu.edu/confluence/display/cplusplus/OOP52-CPP.+Do+not+delete+a+polymorphic+object+without+a+virtual+destructor'>https://wiki.sei.cmu.edu/confluence/display/cplusplus/OOP52-CPP.+Do+not+delete+a+polymorphic+object+without+a+virtual+destructor</a></p>",

        "<p><b>Exceptions</b></p>",
        "<p><b>OOP52-CPP:EX0:</b> Deleting a polymorphic object without a virtual destructor is permitted if the object is referenced by a pointer to its class, rather than via a pointer to a class it inherits from.</p>",
        "<p>Note that if <code>Derived</code> were not marked as <code>final</code>, then <code>delete this</code> could actually reference a subclass of <code>Derived</code>, violating this rule.</p>",
        "<p><b>OOP52-CPP:EX1:</b> Deleting a polymorphic object without a virtual destructor is permitted if its base class has a destroying <code>operator delete</code> that will figure out the correct derived class's destructor to call by other means.</p>",

        "<p><b>Noncompliant Code Example</b></p>",
        "<pre><code language=\"C++\">",
        "struct Base {",
        "  virtual void f();",
        "};",
        "",
        "struct Derived : Base {};",
        "",
        "void f() {",
        "  Base *b = new Derived();",
        "  // ...",
        "  delete b;",
        "}",
        "</code></pre>"
      ]
    }
  },

  "CPP_DD016": {
    "tags": ["Language: C", "Language: C++", "Declarations and Definitions"],
    "key": "vexing-parse",
    "name": "All Checks/Language Specific/C and C++/Declarations and Definitions/Do not write syntactically ambiguous declarations",
    "desc": {
      "html": [
        "<p><b>Title</b></p>",
        "<p>Do not write syntactically ambiguous declarations</p>",
        "<p><b>Risk Assessment</b></p>",
        "<p>Syntactically ambiguous declarations can lead to unexpected program execution. However, it is likely that rudimentary testing would uncover violations of this rule.</p>",
        "<p><b>Full Standard</b></p>",
        "<p><a href='https://wiki.sei.cmu.edu/confluence/display/cplusplus/DCL53-CPP.+Do+not+write+syntactically+ambiguous+declarations'>https://wiki.sei.cmu.edu/confluence/display/cplusplus/DCL53-CPP.+Do+not+write+syntactically+ambiguous+declarations</a></p>",
        "<p><b>Noncompliant Code Example</b></p>",
        "<pre><code language=\"C++\">",
        "#include &lt;mutex&gt;",
        "",
        "static std::mutex m;",
        "static int shared_resource;",
        "",
        "void increment_by_42() {",
        "  std::unique_lock&lt;std::mutex&gt;(m);",
        "  shared_resource += 42;",
        "}",
        "</code></pre>"
      ]
    }
  },

  "CPP_E016": {
    "tags": ["Language: C", "Language: C++", "Expressions"],
    "key": "sti.CharOperators",
    "name": "All Checks/Language Specific/C and C++/Expressions/Character Operators",
    "desc": {
      "text": "",
      "html": [
        "<p>Expressions with type (plain) <i>char</i> and <i>wchar_t</i> shall not be used as operands to built-in operators other than the assignment operator <i>=</i>, the equality operators <code>==</code> and <code>!=</code>, and the unary <code>&</code> operator.</p>",
        "<p><b>Rationale</b></p>",
        "<p>Manipulation of character data may generate results that are contrary to developer expectations. For example, ISO/IEC 14882:2003 [1] ยง2.2(3) only requires that the digits \"0\" to \"9\" have consecutive numerical values.</p>",
        "<p><b>Exception</b></p>",
        "<p>Exceptionally, the following operators may be used if the associated restriction is observed:</p>",
        "<ul>",
        "<li>",
        "The binary <code>+</code> operator may be used to add an integral value in the",
        "range 0 to 9 to '0';",
        "</li>",
        "<li>",
        "The binary <code>-</code> operator may be used to subtract character '0';",
        "</li>",
        "<li>",
        "The relational operators <code>&lt;</code>, <code>&lt;=</code>,",
        "<code>&gt;</code>, <code>&gt;=</code> may be used to determine if a character",
        "(or wide character) represents a digit.",
        "</li>",
        "</ul>",
        "<p><b>Example</b></p>",
        "<pre>",
        "char_t ch = 't';                      // Compliant",
        "uint8_t v;",
        "if ( ( ch &gt;= 'a' ) && ( ch &lt;= 'z' ) ) // Non-compliant",
        "{",
        "}",
        "if ( ( ch &gt;= '0' ) && ( ch &lt;= '9' ) ) // Compliant by exception",
        "{",
        "   v = ch - '0';                      // Compliant by exception",
        "   v = ch - '1';                      // Non-compliant",
        "}",
        "else",
        "{",
        "   // ...",
        "}",
        "ch = '0' + v;                         // Compliant by exception",
        "ch = 'A' + v;                         // Non-compliant",
        "</pre>",
        "<p><b>Developer's Note</b></p>",
        "<p>Other operators are allowed which are not generally thought of as operators. This includes but is not limited to</p>",
        "<ul>",
        "<li>Scope resolution <code>::</code></li>",
        "<li>C-style cast <code>(type)</code></li>",
        "<li>Size-of <code>sizeof</code></li>",
        "<li>Alignment requirement <code>_Alignof</code></li>",
        "<li>Ternary conditional <code>?:</code></li>",
        "</ul>"
      ]
    }
  },

  "CPP_E032": {
    "tags": ["Language: C", "Language: C++", "Expressions"],
    "keys": [
      "tautological-bitwise-compare",
      "tautological-compare",
      "tautological-constant-compare",
      "tautological-constant-in-range-compare",
      "tautological-constant-out-of-range-compare",
      "tautological-objc-bool-compare",
      "tautological-overlap-compare",
      "tautological-pointer-compare",
      "tautological-type-limit-compare",
      "tautological-undefined-compare",
      "tautological-unsigned-char-zero-compare",
      "tautological-unsigned-enum-zero-compare",
      "tautological-unsigned-zero-compare",
      "tautological-value-range-compare"
    ],
    "name": "All Checks/Language Specific/C and C++/Expressions/Infeasible Paths",
    "desc": {
      "html": [
        "<p>A <i>project</i> shall not contain <i>infeasible paths</i></p>",
        "<p><b>Rationale</b></p>",
        "<p><i>Infeasible paths</i> occur where there is a syntactic path but the semantics ensure that the control flow path cannot be executed by any input data. One of the major problems here is the explosion of <i>infeasible paths</i> caused by:</p>",
        "<ul>",
        "<li><i>if</i> ... <i>else</i> statement sequences;</li>",
        "<li>Sequences of poorly chosen loop constructs</li>",
        "</ul>",
        "<p>Errors in conditions and poorly designed logic contribute to this problem. It is always possible to rewrite the code to eliminate these constructs. This process may then reveal faults.</p>",
        "<p>There is the possibility that protective coding techniques generate infeasible code. This code is usually executable (and hence feasible) in a unit testing environment.</p>",
        "<p><b>Example</b></p>",
        "<pre>",
        "void infeas ( uint8_t para, uint8_t outp )",
        "{",
        "   // The condition below will always be true hence the path",
        "   // for the false condition is infeasible. Non-compliant.",
        "   if ( para &gt;= 0U )",
        "   {",
        "      outp = 1U;",
        "   }",
        "",
        "   // The following if statement combines with the if",
        "   // statement above to give four paths. One from",
        "   // the first condition is already infeasible and",
        "   // the condition below combined with assignment above",
        "   // makes the false branch infeasible. There is therefore",
        "   // only one feasible path through this code.",
        "   if ( outp == 1U )",
        "   {",
        "      outp = 0U;",
        "   }",
        "}",
        "",
        "enum ec { RED, BLUE, GREEN } col;",
        "",
        "if ( col &lt;= GREEN ) // Non-compliant - always true",
        "{",
        " // Will always get here",
        "}",
        "else",
        "{",
        " // Will never get here",
        "}",
        "",
        "// The following ifs exhibit similar behaviour.",
        "// Note that u16a is a 16-bit unsigned integer",
        "// and s8a is an 8-bit signed integer.",
        "",
        "if ( u16a &lt; 0U ) // Non-compliant - u16a is always &gt;= 0",
        "",
        "if ( u16a &lt;= 0xffffU ) // Non-compliant - always true",
        "",
        "if ( s8a &lt; 130 ) // Non-compliant - always true",
        "",
        "if ( ( s8a &lt; 10 ) && ( s8a &gt; 20 ) ) // Non-compliant - always false",
        "",
        "if ( ( s8a &lt; 10 ) || ( s8a &gt; 5 ) ) // Non-compliant - always true",
        "",
        "// Nested conditions can also cause problems",
        "if ( s8a &gt; 10 )",
        "{",
        "   if ( s8a &gt; 5 ) // Non-compliant, unless s8a volatile",
        "   {",
        "      // Will always get here.",
        "   }",
        "}",
        "</pre>",
        "<p><b>Developer's Note:</b></p>",
        "<p>This check does not find control-flow that is impossible to go to, such as sequences of poorly chosen loop constructs. It simply finds some expressions which are always true or always false.</p>",
        "<p>In the MISRA C++ 2008 example for rule 0-1-2, there are 2 non-compliant parts that this check misses. An enum can actually be outside of the enum range via casting, so this is not checked. The nested condition is also not checked.</p>"
      ]
    }
  },

  "CPP_E042": {
    "tags": ["Language: C", "Language: C++", "Expressions"],
    "key": "sti.OperandsOfLogicalBooleanOperators",
    "name": "All Checks/Language Specific/C and C++/Expressions/Operands of Logical Boolean Operators",
    "desc": {
      "html": [
        "<p><b>Title</b></p>",
        "<p>The operands of a logical <code>&&</code> or <code>||</code> shall be parenthesized if the operands contain binary operators.</p>",
        "",
        "<p><b>Rationale</b></p>",
        "<p>Parentheses are required to add clarity in logical expressions making code easier to review versus code based only C++ operator precedence rules.</p>",
        "",
        "<p><b>Example</b></p>",
        "<pre><code language=\"C++\">// $Id: A5-2-6.cpp$",
        "",
        "#include &lt;cstdint&gt;",
        "",
        "void Fn(std::int32_t value) noexcept",
        "{",
        "    if (value &gt; 0 && value &lt; 3) // Non-compliant",
        "    {",
        "        // do some work",
        "    }",
        "    else if ((value &gt; 1) && (value &lt; 2)) // Compliant",
        "    {",
        "        // do some work",
        "    }",
        "    else",
        "    {",
        "        // do some work",
        "    }",
        "    return;",
        "}</code></pre>",
        "",
        "<p><b>See also</b></p>",
        "<ul>",
        "<li>MISRA C++ 2008 [7]: M5-2-1: Each operand of a logical && or || shall be a postfix expression.</li>",
        "<li>JSF December 2005 [8]: AV Rule 158: The operands of a logical <code>&&</code> or <code>||</code> shall be parenthesized if the operands contain binary operators.</li>",
        "<li>C++ Core Guidelines [11]: ES.41: If in doubt about operator precedence, parenthesize</li>",
        "</ul>"
      ]
    },
    "options": [
      {
        "id": "sti.OperandsOfLogicalBooleanOperators:AllowChained",
        "text": "Allow chained operations with the same operator",
        "value": true
      }
    ]
  },

  "CPP_E072": {
    "tags": ["Language: C", "Language: C++", "Expressions"],
    "key": "sti.IntFloatCast",
    "name": "All Checks/Language Specific/C and C++/Expressions/Int to Float Conversion",
    "desc": {
      "text": "Check for implicit conversion from integer to floating-point types (C, C++, ObjC)",
      "html": [
        "<p><b>Int to Float Conversion (C, C++, ObjC)</b></p>",
        "<p>Check for implicit conversion from integer to floating-point types.</p>"
      ]
    }
  },

  "CPP_CF003": {
    "tags": ["Language: C", "Language: C++", "Control Flow"],
    "key": "sti.SwitchLabelUnstructured",
    "name": "All Checks/Language Specific/C and C++/Control Flow/Switch label unstructured",
    "desc": {
      "text": "A switch-label shall only be used when the most closely-enclosing compound statement is the body of a switch statement",
      "html": [
        "<p><b>Switch Label Unstructured (C, C++, ObjC)</b></p>",
        "<p>A switch-label can be placed anywhere within the statements that form the body of a switch",
        "statement, potentially leading to unstructured code. To prevent this from happening, the scope",
        "of a case-label or default-label shall be the compound statement forming the body of a switch",
        "statement. All case-clauses and the default-clause shall be at the same scope.</p>"
      ]
    }
  },

  "CPP_E065": {
    "tags": ["Language: C", "Language: C++", "Expressions"],
    "key": "sti.ConditionOfIfStatementShallBeBool",
    "name": "All Checks/Language Specific/C and C++/Expressions/Condition of if statement shall be bool",
    "desc": {
      "text": "Check for the condition of an if-statement or iteration statement not having type bool (C, C++, ObjC)",
      "html": [
        "<p><b>Condition Of If Statement Shall Be Bool (C, C++, ObjC)</b></p>",
        "<p>Check for the condition of an if-statement or iteration statement not having type bool.</p>"
      ]
    }
  },





  "CPP_E073": {
    "tags": ["Language: C", "Language: C++", "Expressions"],
    "key": "sti.IntImplicitConversionSignedness",
    "name": "All Checks/Language Specific/C and C++/Expressions/An implicit integral conversion shall not change the signedness of the underlying type",
    "desc": {
      "text": "Check for implicit integer conversions that change the signedness of the underlying type (C, C++, ObjC)",
      "html": [
        "<p><b>An implicit integral conversion shall not change the signedness of the underlying type. (C, C++, ObjC)</b></p>",
        "<p>Check for implicit conversion changing the signedness of the underlying type.</p>",
        "Note: Rules for implicit conversions are complicated; doing math on small integer types implicitly converts",
        " arguments to `int` or word size. This means instances of unsigned",
        " math on small integer types are flagged because they switch signedness."
      ]
    }
  },
  "CPP_E070": {
    "tags": ["Language: C", "Language: C++", "Expressions"],
    "key": "sti.BoolOperators",
    "name": "All Checks/Language Specific/C and C++/Expressions/Boolean operators",
    "desc": {
      "text": "Expressions of type bool shall only use logic, equality, reference, and the conditional operators",
      "html": [
        "<p><b>Expressions with type bool shall not be used as operands to built-in operators other than the assignment operator =, the logical operators &&, ||, !, the equality operators == and !=, the unary & operator, and the conditional operator. (C, C++, ObjC)</b></p><p>",
        "Rationale</p>",
        "<p>The use of bool operands with other operators is unlikely to be meaningful (or intended). This rule",
        "allows the detection of such uses, which often occur because the logical operators (&&, || and !)",
        "can be easily confused with the bitwise operators (&, | and ~).</p>"
      ]
    }
  },
  "CPP_E025": {
    "tags": ["Language: C", "Language: C++", "Expressions"],
    "keys": ["float-equal","sti.FloatingEqualityTest"],
    "name": "All Checks/Language Specific/C and C++/Expressions/Floating Equality Test",
    "desc": {
      "text": "Floating Equality Test",
      "html": [
        "<p>Floating-point expressions shall not be directly or indirectly tested for",
        "equality or inequality</p>",
        "<p><b>Rationale</b></p>",
        "<p>The inherent nature of floating-point types is such that comparisons of equality",
        "will often not evaluate to true, even when they are expected to. Also, the",
        "behaviour of such a comparison cannot be predicted before execution, and may",
        "well vary from one implementation to another.</p>",
        "<p>The recommended method for achieving deterministic floating-point comparisons",
        "is to write a library that implements the comparison operations. The library",
        "should take into account the floating-point granularity",
        "(<code>std::numeric_limits<float>::epsilon()</code>) and the magnitude of the",
        "numbers being compared.</p>",
        "<b>Example</b><pre>",
        "// The result of the test in the following code is unpredictable:",
        "float32_t x, y;",
        "if ( x == y )     // Non-compliant",
        "if ( x == 0.0f )  // Non-compliant",
        "// An indirect test is equally problematic and is also prohibited by this rule:",
        "if ( ( x &lt;= y ) && ( x &gt;= y ) )   // Non-compliant",
        "if ( ( x &lt; y ) || ( x &gt; y ) )     // Non-compliant",
        "// The following is better, but only if the magnitudes are appropriate:",
        "if ( fabs ( x - y ) &lt;= std::numeric_limits&lt;float&gt;::epsilon( ) ) //Compliant",
        "</pre>"
      ]
    }
  },


  "CPP_P014_A": {
    "tags": [ "Language: C", "Language: C++", "Pointers" ],
    "key": "sti.MultipleDereferences",
    "name": "All Checks/Language Specific/C and C++/Pointers/Restrict Pointer Usage - Multiple Dereferences",
    "desc": {
      "html": [
        "<p>The use of pointers must be restricted. Specifically, no more than one level of dereferencing should be used. Pointer dereference operations may not be hidden in macro definitions or inside <code>typedef</code> declarations. Function pointers are not permitted.</p>",
        "<p><b>Rationale</b></p>",
        "<p>Pointers are easily misused, even by experienced programmers. They can make it hard to follow or analyze the flow of data in a program, especially by tool-based analyzers. Similarly, function pointers should be used only if there is a very strong justification for doing so because they can seriously restrict the types of automated checks that code checkers can perform. For example, if function pointers are used, it can become impossible for a tool to prove the absence of recursion, requiring alternate guarantees to make up for this loss in checking power.</p>",
        "<p><b>Example</b></p>",
        "<pre>",
        "typedef struct {",
        "  int x;",
        "  int y;",
        "} point_t;",
        "",
        "// Multiple dereferences at once",
        "char hello[6] = \"Hello\";",
        "char **hello_ptr = (char **) &hello;",
        "void fn(void)",
        "{",
        "  char first_char = **hello_ptr;",
        "}",
        "",
        "// Pointer in type definition",
        "typedef point_t* point_ptr_t;",
        "",
        "// Dereference in macro definition",
        "#define RESET_POINT_PTR(point_ptr) { point_ptr-&gt;x = 0; point_ptr-&gt;y = 0; }",
        "",
        "// Function pointer",
        "void (*function_ptr) (void);",
        "</pre>",
        "<p><b>Developer's Notes</b></p>",
        "<p>\"No more than one level of dereferencing should be used\" can be enforced in 2 ways:</p>",
        "<ul>",
        "<li>Do not declare multi-pointer or multi-pointer/array types (Option in Part B)</li>",
        "<li>Do not perform multiple dereferences in one expression (Part A)</li>",
        "</ul>",
        "<p>In C++, dereferencing <code>this</code> for a member and then dereferencing that member is allowed. Thus, a member function is allowed to dereference a member.</p>"
      ]
    }
  },

  "CPP_P045": {
    "tags": ["Language: C", "Language: C++", "Pointers"],
    "key": "sti.ArrayIndexingOverPointerArithmetic",
    "name": "All Checks/Language Specific/C and C++/Pointers/Array indexing over pointer arithmetic",
    "desc": {
      "text": "Array indexing shall be the only form of pointer arithmetic",
      "html": [
        "<p><b>Array indexing over pointer arithmetic</b></p>",
        "<p>Array indexing is the only acceptable form of pointer arithmetic, because it is clearer and hence",
        "less error prone than pointer manipulation. This rule bans the explicit calculation of pointer values.",
        "Array indexing shall only be applied to objects defined as an array type.",
        "Any explicitly calculated pointer value has the potential to access unintended or invalid memory",
        "addresses. Pointers may go out of bounds of arrays or structures, or may even point to effectively",
        "arbitrary locations.</p>",
        "<b>Limitations</b></p><p>",
        "This doesn't check the if the array index is operating on a pointer or an array.",
        "Passing an array via a parameter doesn't actually pass an array, it passes a sugared pointer.",
        "Real arrays have different semantics (like their address can't be changed) that sugared pointers don't have.",
        "There is no way to know if a pointer points to an array in general.",
        "</p>"
      ]
    }
  },

  "CPP_P051": {
    "tags": ["Language: C", "Language: C++", "Pointers"],
    "key": "sti.PointerToIntCast",
    "name": "All Checks/Language Specific/C and C++/Pointers/Pointer to Integer Cast",
    "desc": {
      "html": [
        "<p><b>Rationale</b></p>",
        "<p>The size of integer that is required when a pointer is converted to an integer is <i>implementation-defined</i>. Casting between a pointer and an integer type should be avoided where possible, but may be unavoidable when addressing memory mapped registers or other hardware specific features.</p>",
        "<p>Note that C++ does not permit a pointer to be converted to any floating type.</p>",
        "",
        "<p><b>Example</b></p>",
        "<pre><code language=\"C++\">struct S",
        "{",
        "   int32_t i;",
        "   int32_t j;",
        "};",
        "void f ( S * s )",
        "{",
        "   int32_t p = reinterpret_cast&lt; int32_t &gt;( s );   // Non-compliant",
        "}",
        "</code></pre>"
      ]
    }
  },

  "CPP_F009": {
    "tags": ["Language: C", "Language: C++", "Functions"],
    "keys": ["strict-prototypes", "deprecated-non-prototype", "implicit-int", "sti.UnnamedParameters"],
    "name": "All Checks/Language Specific/C and C++/Functions/Use Named Parameters and Prototype Form",
    "desc": {
      "html": [
        "<p><b>Title</b></p>",
        "<p>Function types shall be in <i>prototype form</i> with named parameters.</p>",
        "<p><b>Rationale</b></p>",
        "<p>The early version of C, commonly referred to as K&R C [30], did not provide a mechanism for checking the number of arguments or their types against the corresponding parameters. The type of an object or function did not have to be declared in K&R C since the default type of an object and the default return type of a function was <i>int</i>.</p>",
        "<p>The C90 standard introduced function prototypes, a form of function declarator in which the parameter types were declared. This permitted argument types to be checked against parameter types. It also allowed the number of arguments to be checked except when a function prototype specified that a variable number of arguments was expected. The C90 standard did not <b>require</b> the use of function prototypes for reasons of backward compatibility with existing code. For the same reason, it continued to permit types to be omitted in which case the type would default to <i>int</i>.</p>",
        "<p>The C99 standard removed the default <i>int</i> type from the language but continued to allow K&R-style function types in which there was no means to supply parameter type information in a declaration and it was optional to supply parameter type information in a definition.</p>",
        "<p>The mismatch between the number of arguments and parameters, their types and the expected and actual return type of a function provides potential for undefined behaviour. The purpose of this rule is to avoid this undefined behaviour by requiring parameter types and function return types to be specified explicitly.</p>",
        "<p>This rule also requires that names be specified for all the parameters in a declaration. The parameter names can provide useful information regarding the function interface and a mismatch between a declaration and definition might be indicative of a programming error.</p>",
        "<p><i>Note</i>: An empty parameter list is <b>not</b> valid in a prototype. If a function type has no parameters its <i>prototype form</i> uses the keyword <i>void</i>.</p>",
        "<p><b>Example</b></p>",
        "<p>The first example shows declarations of some functions and the corresponding definitions for some of those functions.</p>",
        "<pre><code language=\"C++\">",
        "  /* Compliant                                                  */",
        "  extern int16_t func1 ( int16_t n );",
        "",
        "  /* Non-compliant - parameter name not specified               */",
        "  extern void func2 ( int16_t );",
        "",
        "  /* Non-compliant - not in prototype form                      */",
        "  static int16_t func3 ( );",
        "",
        "  /* Compliant - prototype specifies 0 parameters               */",
        "  static int16_t func4 ( void );",
        "",
        "  /* Compliant                                                  */",
        "  int16_t func1 ( int16_t n )",
        "  {",
        "    return n;",
        "  }",
        "",
        "  /* Non-compliant - old style identifier and declaration list  */",
        "  static int16_t func3 ( vec, n )",
        "  int16_t *vec;",
        "  int16_t n;",
        "  {",
        "    return vec[ n - 1 ];",
        "  }",
        "</code></pre>",
        "<p>This example section shows the application of the rule to function types other than in function declarations and definitions.</p>",
        "<pre><code language=\"C++\">",
        "  /* Non-compliant - no prototype                   */",
        "  int16_t ( *pf1 ) ( );",
        "",
        "  /* Compliant - prototype specifies 0 parameters   */",
        "  int16_t ( *pf1 ) ( void );",
        "",
        "  /* Non-compliant - parameter name not specified   */",
        "  typedef int16_t ( *pf2_t ) ( int16_t );",
        "",
        "  /* Compliant                                      */",
        "  typedef int16_t ( *pf3_t ) ( int16_t n );",
        "</code></pre>"
      ]
    }
  },

  "CPP_F033": {
    "tags": ["Language: C", "Language: C++", "Functions"],
    "key": "return-type",
    "name": "All Checks/Language Specific/C and C++/Functions/Always return a value in non-void functions",
    "desc": {
      "html": [
        "<p>Always return a value in non-void functions.</p>",
        "<p><b>Rationale</b></p>",
        "<p>This expression gives the value that the function returns. The absence of a <i>return</i> with an expression leads to <i>undefined behaviour</i> (and the compiler may not give an error).</p>",
        "<p><b>Exception</b></p>",
        "<p>This rule does not apply if a function exit is due to exception handling (i.e. a <i>throw</i> statement).</p>",
        "<p><b>Example</b></p>",
        "<pre>",
        "int32_t fn1 ( void )",
        "{",
        "} // Non-compliant",
        "int32_t fn3 ( int32_t x )",
        "{",
        "    if ( x &gt; 100 )",
        "    {",
        "        throw 42; // Compliant by exception",
        "    }",
        "    return ( x ); // Compliant",
        "}",
        "</pre>"
      ]
    }
  },

  "CPP_F036": {
    "tags": ["Language: C++", "Functions"],
    "key": "modernize-use-override",
    "name": "All Checks/Language Specific/C and C++/Functions/Use Override",
    "desc": {
      "html": [
        "<p><b>Title</b></p>",
        "<p>Each overriding virtual function shall be declared with the override or final",
        "specifier.</p>",

        "<p><b>Rationale</b></p>",
        "<p>Explicit use of the override or final specifier enables the compiler to catch mismatch of types and names between base and derived classes virtual functions.</p>",
        "<p>Note that this rule applies to virtual destructor overriders, too.</p>",
        "<p>Also, note that this rule applies to a pure virtual function which overrides another pure virtual function.</p>",

        "<p><b>Example</b></p>",
        "<pre><code language=\"C++\">// $Id: A10-3-2.cpp 289436 2017-10-04 10:45:23Z michal.szczepankiewicz $",
        "class A",
        "{",
        "  public:",
        "    virtual ~A() {}",
        "    virtual void F() noexcept = 0;",
        "    virtual void G() noexcept {}",
        "    virtual void Z() noexcept {}",
        "    virtual A& operator+=(A const& oth) = 0;",
        "};",
        "class B : public A",
        "{",
        "  public:",
        "    ~B() override {}   // Compliant",
        "    void F() noexcept  // Non-compliant",
        "    {",
        "    }",
        "    virtual void G() noexcept  // Non-compliant",
        "    {",
        "    }",
        "    void Z() noexcept override  // Compliant",
        "    {",
        "    }",
        "    B& operator+=(A const& oth) override  // Compliant",
        "    {",
        "        return *this;",
        "    }",
        "};",
        "class C : public A",
        "{",
        "  public:",
        "    ~C() {}                     // Non-compliant",
        "    void F() noexcept override  // Compliant",
        "    {",
        "    }",
        "    void G() noexcept override  // Compliant",
        "    {",
        "    }",
        "    void Z() noexcept override  // Compliant",
        "    {",
        "    }",
        "    C& operator+=(A const& oth)  // Non-compliant",
        "    {",
        "        return *this;",
        "    }",
        "};</code></pre>",

        "<p><b>See also</b></p>",
        "<ul>",
        "<li>HIC++ v4.0 [9]: 10.2.1 Use the override special identifier when overriding a virtual function</li>",
        "<li>C++ Core Guidelines [11]: C.128: Virtual functions should specify exactly one of virtual, override, or final.</li>",
        "</ul>"
      ]
    }
  },

  "CPP_F024": {
    "tags": [ "Language: C", "Functions" ],
    "key": "sti.IgnoredReturnValues",
    "name": "All Checks/Language Specific/C and C++/Functions/The value returned by a function shall be used",
    "desc": {
      "html": [
        "<p>The value returned by a function having a non-void return type that is not an overloaded operator shall be used.</p>",
        "<p><b>Rationale</b></p>",
        "<p>A called function may provide essential information about its process status and result through return statement. Calling a function without using the return value should be a warning that incorrect assumptions about the process were made.</p>",
        "<p>Overloaded operators are excluded, as they should behave in the same way as built-in operators.</p>",
        "<p><b>Exception</b></p>",
        "<p>The return value of a function call may be discarded by use of a static_cast&lt;void&gt; cast, so intentions of a programmer are explicitly stated.</p>",
        "<p><b>Example</b></p>",
        "<pre>// $Id: A0-1-2.cpp 289436 2017-10-04 10:45:23Z michal.szczepankiewicz $",
        "#include &lt;algorithm&gt;",
        "#include &lt;cstdint&gt;",
        "#include &lt;vector&gt;",
        "std::uint8_t Fn1() noexcept",
        "{",
        "  return 0U;",
        "}",
        "void Fn2() noexcept",
        "{",
        "  std::uint8_t x = Fn1(); // Compliant",
        "  Fn1(); // Non-compliant",
        "  static_cast&lt;void&gt;(Fn1()); // Compliant by exception",
        "}",
        "void Fn3()",
        "{",
        "  std::vector&lt;std::int8_t&gt; v{0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5};",
        "  std::unique(v.begin(), v.end()); // Non-compliant",
        "  v.erase(std::unique(v.begin(), v.end()), v.end()); // Compliant",
        "}",
        "</pre>"
      ]
    }
  },

  "CPP_F038_A": {
    "tags": [ "Language: C", "Language: C++", "Functions" ],
    "key": "sti.IgnoredReturnValues",
    "name": "All Checks/Language Specific/C and C++/Functions/Check Parameters and Return Values - Ignored Return Values",
    "desc": {
      "html": [
        "<p>Each calling function must check the return value of non-void functions, and each called function must check the validity of all parameters provided by the caller.</p>",
        "<p><b>Rationale</b></p>",
        "<p>This is possibly the most frequently violated rule, and therefore it is somewhat more suspect for inclusion as a general rule. In its strictest form, this rule means that even the return value of <code>printf</code> statements and file <code>close</code> statements must be checked. Yet, if the response to an error would be no different than the response to success, there is little point in explicitly checking a return value. This is often the case with calls to <code>printf</code> and <code>close</code>. In cases like these, explicitly casting the function return value to <code>(void)</code> can be acceptable, thereby indicating that the programmer explicitly and not accidentally decided to ignore a return value.</p>",
        "<p>In more dubious cases, a comment should be offered to explain why a return value can be considered irrelevant. In most cases, though, a function's return value should not be ignored, especially if the function should propagate an error return value up the function call chain.</p>",
        "<p><b>Example</b></p>",
        "<pre>",
        "static void nothing(void) {",
        "",
        "}",
        "",
        "static int two(void) {",
        "  return 2;",
        "}",
        "",
        "static void ignored_call_expressions(void) {",
        "  int six;",
        "",
        "  two(); // Violation",
        "  (void) two();",
        "  two() + 4;",
        "  six = two() * 3;",
        "}",
        "</pre>",
        "<p><b>Developer's Notes</b></p>",
        "<p>In C++, non-void operators are allowed. This is to allow for many common operators, such as an assignment operator. Also, a <code>new</code> expression that is ignored is counted as a violation.</p>"
      ]
    }
  },

  "CPP_F067": {
    "tags": ["Language: C", "Language: C++", "Functions"],
    "key": "invalid-noreturn",
    "name": "All Checks/Language Specific/C and C++/Functions/Functions declared with the [[noreturn]] attribute shall not return",
    "desc": {
      "html": [
        "<p><b>Rationale</b></p>",
        "<p>The C++ standard specifies that functions with the [[noreturn]] attribute shall not return. Returning from such a function can be prohibited in the following way: </p>",
        "<p>throwing an exception, entering an infinite loop, or calling another function with the [[noreturn]] attribute. Returning from such a function leads to undefined behavior.</p>",
        "<p><b>Example</b></p>",
        "<pre>",
        "1 // $Id: A7-6-1.cpp 305629 2018-01-29 13:29:25Z piotr.serwa $",
        "2 #include <cstdint>",
        "3 #include <exception>",
        "4 class PositiveInputException : public std::exception {};",
        "5 ",
        "6 [[noreturn]] void f(int i)  //non-compliant",
        "7 {",
        "8   if (i > 0) {",
        "9     throw PositiveInputException();",
        "10   }",
        "11 //undefined behaviour for non-positive i",
        "12 }",
        "13 [[noreturn]] void g(int i) //compliant",
        "14 {",
        "15   if (i > 0) {",
        "16     throw \"Received positive input\";",
        "17   }",
        "18   while(1) {",
        "19 //do processing",
        "20   }",
        "21 }",
        "22 ",
        "</pre>"
      ]
    }
  },

  "CPP_F069": {
    "tags": ["Language: C", "Language: C++", "Functions"],
    "key": "bugprone-signal-handler",
    "name": "All Checks/Language Specific/C and C++/Functions/A signal handler must be a plain old function",
    "desc": {
      "html": [
        "<p><b>Title</b></p>",
        "<p>A signal handler must be a plain old function</p>",
        "",
        "<p><b>Risk Assessment</b></p>",
        "<p>Failing to use a plain old function as a signal handler can result in",
        "implementation-defined behavior as well as undefined behavior. Given the number",
        "of features that exist in C++ that do not also exist in C, the consequences that",
        "arise from failure to comply with this rule can range from benign (harmless)",
        "behavior to abnormal program termination, or even arbitrary code execution.</p>",
        "",
        "<p><b>Noncompliant Code Example</b></p>",
        "<pre><code language=\"C++\">#include &lt;csignal&gt;",
        "",
        "static void sig_handler(int sig) {",
        "  // Implementation details elided.",
        "}",
        "",
        "void install_signal_handler() {",
        "  if (SIG_ERR == std::signal(SIGTERM, sig_handler)) {",
        "    // Handle error",
        "  }",
        "}",
        "</code></pre>"
      ]
    }
  },

  "CPP_EH007": {
    "tags": ["Language: C", "Language: C++", "Exception Handling"],
    "key": "exceptions",
    "name": "All Checks/Language Specific/C and C++/Exception Handling/Each exception explicitly thrown in the code shall have a handler of a compatible type in all call paths that could lead to that point",
    "desc": {
      "html": [
        "<p><b>Rationale</b></p>",
        "<p>If a program throws an unhandled exception, it terminates in an implementation-defined manner. In particular, it is implementation-defined whether the call stack is unwound before termination, so the destructors of any automatic objects may or may not be invoked.</p>",
        "<p>If an exception is thrown as an object of a derived class, a โcompatible typeโ may be either the derived class or any of its bases.</p>",
        "<p>The objective of this rule is that a program should catch all exceptions that it is expected to throw. The objective of Rule 15-3-2 is to ensure that exceptions that were not expected are also caught.</p>",
        "<p><b>Example</b></p>",
        "<pre>",
        "1 class A {};",
        "2 class B {};",
        "3 ",
        "4 void f ( int32_t i ) throw ()",
        "5 {",
        "6   try",
        "7   {",
        "8     if ( i > 10 )",
        "9     {",
        "10      throw A (); // UNDCC_Valid",
        "11    }",
        "12    else",
        "13    {",
        "14      throw B (); // UNCC_Violation",
        "15    }",
        "16    catch ( A const & )",
        "17    {",
        "18    }",
        "19 }",
        "</pre>"
        ]
      }
    },

    "CPP_E006": {
    "tags": ["Language: C", "Language: C++", "Exception Handling"],
    "key": "exceptions",
    "name": "All Checks/Language Specific/C and C++/Exception Handling/Order of Catch Blocks with Derived Classes",
    "desc": {
      "html": [
        "<p>Where multiple handlers are provided in a single <i>try-catch</i> statement or <i>function-try-block</i> for a derived class and some or all of its bases, the handlers shall be ordered most-derived to base class</p>",
        "<p><b>Rationale</b></p>",
        "<p>When testing to see if the type of an exception matches the type of a handler, a derived class exception will match with a handler for its base class. If the base class handler is found before the handler for the derived class, the base class handler will be used. The derived class handler is <i>unreachable code</i> and can never be executed.</p>",
        "<p><b>Example</b></p>",
        "<pre>",
        "1  // classes used for exception handling",
        "2  class B {};",
        "3  class D: public B {};",
        "4  try",
        "5  {",
        "6    //...",
        "7  }",
        "8  catch ( D &d ) // Compliant - Derived class caught before base class",
        "9  {",
        "10   //...",
        "11 }",
        "12 catch ( B &b ) // Compliant - Base class caught after derived class",
        "13 {",
        "14   //...",
        "15 }",
        "16 // Using the classes from above",
        "17 try",
        "18 {",
        "19   //...",
        "20 }",
        "21 catch ( B &b )",
        "22 {",
        "23   //...",
        "24 }",
        "25 catch ( D &d ) // Non-compliant - Derived class will be caught above",
        "26 {",
        "27   // Any code here will be unreachable,",
        "28   // breaking rule 0-1-1",
        "29 }",
        "</pre>"
      ]
    }
  },

  "CPP_E069": {
    "tags": ["Language: C", "Language: C++", "Expressions"],
    "key": "sti.AssignmentSubExpressions",
    "name": "All Checks/Language Specific/C and C++/Expressions/Assignment in SubExpressions",
    "desc": {
      "text": "Assignment operators shall not be used in subexpressions.",
      "html": [
        "<p><b>Assignment operators shall not be used in subexpressions</b></p><p>",
        "Assignments used in a sub-expression add an additional side effect to that of the full expression,",
        "potentially resulting in a value inconsistent with developer expectations. In addition, this helps to",
        "avoid getting = and == confused.</p>"
      ]
    }
  },
  "CPP_F050": {
    "tags": ["Language: C", "Language: C++", "Functions"],
    "keys": ["microsoft-exception-spec"],
    "name": "All Checks/Language Specific/C and C++/Functions/The noexcept specification of a function shall either be identical across all translation units, or identical or more restrictive between a virtual member function and an overrider",
    "desc": {
      "html": [
        "<p><b>Rationale</b></p>",
        "<p>Declarations of the same function, even in different translation units, have to specify the same noexcept specification. Overriding functions have to specify the same or a stricter noexcept specification than the base class function which they override.</p>",
        "<p>Note that in many cases, a violation of this rule will lead to a compilation error. This is not guaranteed, however, in particular when function declarations appear in separate translation units.</p>",
        "<p><b>Example</b></p>",
        "<pre><code language=\"C++\">1 //% $Id: A15-4-3.cpp 317753 2018-04-27 07:44:02Z jan.babst $",
        "// f1.hpp",
        "void Fn() noexcept;",
        "",
        "// f1.cpp",
        "// #include &lt;f1.hpp&gt;",
        "void Fn() noexcept // Compliant",
        "{",
        "// Implementation",
        "}",
        "",
        "// f2.cpp",
        "// #include &lt;f1.hpp&gt;",
        "void Fn() noexcept(false) // Non-compliant - different exception specifier",
        "{",
        "// Implementation",
        "}",
        "",
        "class A",
        "{",
        "public:",
        "void F() noexcept;",
        "void G() noexcept(false);",
        "virtual void V1() noexcept = 0;",
        "virtual void V2() noexcept(false) = 0;",
        "};",
        "void A::F() noexcept // Compliant",
        "// void A::F() noexcept(false) // Non-compliant - different exception specifier",
        "// than in declaration",
        "{",
        "// Implementation",
        "}",
        "void A::G() noexcept(false) // Compliant",
        "// void A::G() noexcept // Non-compliant - different exception specifier than",
        "// in declaration",
        "{",
        "// Implementation",
        "}",
        "class B : public A",
        "{",
        "public:",
        "void V1() noexcept override // Compliant",
        "// void V1() noexcept(false) override // Non-compliant - less restrictive",
        "// exception specifier in derived method, non-compilable",
        "{",
        "// Implementation",
        "}",
        "void V2() noexcept override // Compliant - stricter noexcept specification",
        "{",
        "// Implementation",
        "}",
        "};",
        "</code></pre>",
        "<p><b>See also</b></p>",
        "<p>MISRA C++ 2008 [7]: 15-4-1: If a function is declared with an exceptionspecification, then all declarations of the same function (in other translation units) shall be declared with the same set of type-ids.</p>"
      ]
    }
  },

  "CPP_AO000": {
    "tags": ["Language: C", "Language: C++", "Assignment Operators"],
    "key": "sti.AssignmentSubExpressions",
    "name": "All Checks/Language Specific/C and C++/Assignment Operators/Assignment operators shall not be used in sub-expressions",
    "desc": {
      "text": "Assignment operators shall not be used in subexpressions.",
      "html": [
        "<p><b>Assignment operators shall not be used in subexpressions</b></p><p>",
        "Assignments used in a sub-expression add an additional side effect to that of the full expression,",
        "potentially resulting in a value inconsistent with developer expectations. In addition, this helps to",
        "avoid getting = and == confused.</p>"
      ]
    }
  },

  "CPP_C045": {
    "tags": ["Language: C++", "Constructors"],
    "key": "reorder-ctor",
    "name": "All Checks/Language Specific/C and C++/Constructors/Write constructor member initializers in the canonical order",
    "desc": {
      "html": [
        "<p><b>Title</b></p>",
        "<p>Write constructor member initializers in the canonical order</p>",

        "<p><b>Full Standard</b></p>",
        "<p><a href='https://wiki.sei.cmu.edu/confluence/display/cplusplus/OOP53-CPP.+Write+constructor+member+initializers+in+the+canonical+order'>https://wiki.sei.cmu.edu/confluence/display/cplusplus/OOP53-CPP.+Write+constructor+member+initializers+in+the+canonical+order</a></p>",

        "<p><b>Exceptions</b></p>",
        "<p><b>OOP53-CPP-EX0</b>: Constructors that do not use member initializers do not violate this rule.</p>",

        "<p><b>Noncompliant Code Example</b></p>",
        "<pre><code language=\"C++\">",
        "class C {",
        "  int dependsOnSomeVal;",
        "  int someVal;",
        "",
        "public:",
        "  C(int val) : someVal(val), dependsOnSomeVal(someVal + 1) {}",
        "};",
        "</code></pre>"
      ]
    }
  },

  "CPP_V007": {
    "tags": ["Language: C", "Language: C++", "Variables"],
    "keys": ["unused-variable","unused-const-variable"],
    "name": "All Checks/Language Specific/C and C++/Variables/Unused Local Variables",
    "desc": {
      "text": "Check for variables that are unused (C, C++, ObjC)",
      "html": [
        "<p><b>Unused Variables (C, C++, ObjC)</b></p><p>",
        "Local variables that are defined but not used can lead to memory management",
        "issues as well as making code more difficult to follow. They can also be",
        "indicitive of an error where a programmer meant to use one variable and",
        "accidently used another. This check ignores references inside inactive code",
        "(ie #if 0...#endif).</p>"
      ]
    }
  },

  "CPP_V016": {
    "tags": [
      "Constructors",
      "Destructors",
      "Virtual Functions",
      "Language: C++"
    ],
    "keys": ["cplusplus.PureVirtualCall", "optin.cplusplus.VirtualCall"],
    "name": "All Checks/Language Specific/C and C++/Virtual Functions/Virtual Call in Constructor&#47;Destructor",
    "desc": {
      "html": [
        "<p><b>Title</b></p>",
        "<p>Never call virtual functions during construction or destruction.</p>",
        "",
        "<p><b>Developer's Notes</b></p>",
        "<p>Calling a virtual function of another object that is not `this` is allowed.</p>",
        "<p>Calling a virtual function without bypassing virtual dispatch is allowed. This occurs when the current class doesn't implement the virtual function.</p>"
      ]
    }
  },

  "CPP_L033": {
    "tags": ["Language: C", "Language: C++", "Libraries"],
    "key": "builtin-macro-redefined",
    "name": "All Checks/Language Specific/C and C++/Libraries/Reserved Builtin Macros",
    "desc": {
      "text": "Reserved identifiers, macros and functions in the C++ standard library shall not be defined, redefined or undefined (C, C++, ObjC)",
      "html": [
        "<p><b>Reserved Builtin Macros (C, C++, ObjC)</b></p><p>",
        "Reserved identifiers, macros and functions in the C++ standard library shall not be defined, redefined or undefined.</p>"
      ]
    }
  },

  "CPP_P044": {
    "tags": ["Language: C", "Language: C++", "Pointers"],
    "key": "delete-incomplete",
    "name": "All Checks/Language Specific/C and C++/Pointers/Deleting Pointers to Incomplete Class Types",
    "desc": {
      "text": "Pointers to incomplete class types shall not be deleted (C, C++, ObjC)",
      "html": [
        "<p><b>Deleting Pointers to Incomplete Class Types (C, C++, ObjC)</b></p><p>",
        "Incomplete class types are forward declared class types, for which the compiler has not yet seen a definition. It is undefined behavior",
        "if a pointer to an incomplete class type is deleted, and the class has a non-trivial destructor or a deallocation function. This rule ",
        "prohibits deletion of such a pointer even in the harmless case of a trivially destructible class type without a deallocation function, ",
        "since a non-trivial destructor or a deallocation function may be added later as the code evolves.</p>"
      ]
    }
  },
  "CPP_P061": {
    "tags": ["Language: C", "Language: C++", "Pointers"],
    "key": "sti.SharedPointerCapture",
    "name": "All Checks/Language Specific/C and C++/Pointers/Shared Pointer Capture",
    "desc": {
      "html": [
        "<p>Do not capture a shared pointer with Qt signals. Capturing a shared pointer is similar to a reference cycle, resulting in a shared pointer that will not be destructed.</p>"
      ]
    },
    "options": [
      {
        "id": "sti.SharedPointerCapture:QTOnly",
        "text": "Only find shared pointer captures in the QT function \"Connect\"",
        "value": true
      }
    ]
  },

  "CPP_EH001": {
    "tags": ["Language: C", "Language: C++", "Exception Handling"],
    "key": "sti.NoImplicitTerminate",
    "name": "All Checks/Language Specific/C and C++/Exception Handling/The std::terminate() function shall not be called implicitly",
    "desc": {
      "text": "Check for implicit conversion from integer to floating-point types (C, C++, ObjC)",
      "html": [
        "<p><b>Int to Float Conversion (C, C++, ObjC)</b></p>",
        "<p>Check for implicit conversion from integer to floating-point types.</p>"
      ]
    }
  },

  "CPP_EH000": {
    "tags": ["Language: C", "Language: C++", "Exception Handling"],
    "keys": ["sti.AbruptlyTerminate","exceptions"],
    "name": "All Checks/Language Specific/C and C++/Exception Handling/Program shall not be abruptly terminated",
    "desc": {
      "text": "Abrupt",
      "html": [
        "<p>Program shall not be abruptly terminated. In particular, an implicit or explicit invocation of std::abort(), std::quick_exit(), std::_Exit(),std::terminate() shall not be done.</p>",
        "<p><b>Rationale</b></p>",
        "<p>Functions that are used to terminate the program in an immediate fashion, i.e. std::abort(), std::quick_exit(), std::_Exit(), do so without calling exit handlers or calling destructors of automatic, thread or static storage duration objects. It is implementationdefined whether opened streams are flushed and closed, and temporary files are removed.</p>",
        "<p>The std::terminate() function calls std::abort() implicitly in its terminate handler, and it is implementation-defined whether or not stack unwinding will occur.</p>",
        "<p>Note: std::terminate_handler shall not be used.</p>",
        "<p><b>Example</b></p>",
        "<pre>",
        "1  //% $Id: A15-5-2.cpp 289436 2017-10-04 10:45:23Z michal.szczepankiewicz $",
        "2  #include <cstdlib>",
        "3  #include <exception>",
        "4  void F1() noexcept(false);",
        "5  void F2() // Non-compliant",
        "6  {",
        "7    F1(); // A call to throwing f1() may result in an implicit call to",
        "8    // std::terminate()",
        "9  }",
        "10 void F3() // Compliant",
        "11 {",
        "12   try",
        "13   {",
        "14     F1(); // Handles all exceptions from f1() and does not re-throw",
        "15   }",
        "16   catch (...)",
        "17   {",
        "18     // Handle an exception",
        "19   }",
        "20 }",
        "21 void F4(const char* log)",
        "22 {",
        "23   // Report a log error",
        "24   // ...",
        "25   std::exit(0); // Call std::exit() function which safely cleans up resources",
        "26 }",
        "27 void F5() // Compliant by exception",
        "28 {",
        "29   try",
        "30   {",
        "31     F1();",
        "32   }",
        "33   catch (...)",
        "34   {",
        "35     F4(\"f1() function failed\");",
        "36   }",
        "37 }",
        "38 int main(int, char**)",
        "39 {",
        "40   if (std::atexit(&F2) != 0)",
        "41   {",
        "42     // Handle an error",
        "43   }",
        "44",
        "45   if (std::atexit(&F3) != 0)",
        "46   {",
        "47     // Handle an error",
        "48   }",
        "49",
        "50   // ...",
        "51   return 0;",
        "52 }",
        "</pre>"
      ]
    }
  },

  "CPP_CF000": {
    "tags": ["Language: C", "Language: C++", "Control Flow"],
    "key": "switch-bool",
    "name": "All Checks/Language Specific/C and C++/Control Flow/The condition of a switch statement shall not have bool type",
    "desc": {
      "html": [
        "<p><b>Rationale</b></p>",
        "<p>An <i>if</i> statement gives a clearer representation for a Boolean choice.</p>",
        "<p><b>Example</b></p>",
        "<pre>",
        "switch ( x == 0)   // Non-compliant",
        "{",
        "   ...",
        "}",
        "</pre>"
      ]
    }
  },

  "CPP_E050B": {
    "tags": ["Language: C", "Language: C++", "Expressions"],
    "key": "division-by-zero",
    "name": "All Checks/Language Specific/C and C++/Expressions/The right hand operand of the integer division or remainder operators shall not be equal to zero",
    "desc": {
      "html": [
        "<p><b>Rationale</b></p>",
        "<p>The result is undefined if the right hand operand of the integer division or",
        "the remainder operator is zero.</p>",
        "<p><b>Example</b></p>",
        "<pre>",
        "1  // $Id: A5-6-1.cpp 305629 2018-01-29 13:29:25Z piotr.serwa $",
        "2  #include <cstdint>",
        "3  #include <stdexcept>",
        "4  std::int32_t Division1(std::int32_t a, std::int32_t b) noexcept",
        "5  {",
        "6    return (a / b); // Non-compliant - value of b could be zero",
        "7  }",
        "8  std::int32_t Division2(std::int32_t a, std::int32_t b)",
        "9  {",
        "10   if (b == 0)",
        "11   {",
        "12     throw std::runtime_error(\"Division by zero error\");",
        "13   }",
        "14   return (a / b); // Compliant - value of b checked before division",
        "15 }",
        "16 double Fn()",
        "17 {",
        "18   std::int32_t x = 20 / 0; // Non-compliant - undefined behavior",
        "19   x = Division1(20, 0); // Undefined behavior",
        "20   x = Division2(20,",
        "21   0); // Preconditions check will throw a runtime_error from",
        "22   // division2() function",
        "23   std::int32_t remainder = 20 % 0; // Non-compliant - undefined behavior",
        "24 }",
        "</pre>",
        "<p><b>Developer's Note</b></p>",
        "<p>Part A of this check will check for simple violations that regard variables",
        "that could possibly equal zero. Also this check only checks for if it is used",
        "in an if statment. It does not check the actual logic of the if statement.</p>",
        "<p>Part B of this check uses utilize clang warnings that catch violations",
        "regarding literal digits and their expressions</p>"
      ]
    }
  },

  "CPP_T050": {
    "tags": ["Language: C", "Language: C++", "Types"],
    "key": "implicit-int",
    "name": "All Checks/Language Specific/C and C++/Types/Types shall be explicitly specified",
    "desc": {
      "html": [
        "<p>Types shall be explicitly specified</p>",
        "<p><b>Rationale</b></p>",
        "The C90 standard permits types to be omitted in some circumstances, in which case the <i>int</i> type is implicitly specified. Examples of the circumstances in which an implicit <i>int</i> might be used are:",
        "<ul>",
        "<li>Object declarations;</li>",
        "<li>Parameter declarations;</li>",
        "<li>Member declarations;</li>",
        "<li><i>typedef</i> declarations;</li>",
        "<li>Function return types.</li>",
        "</ul>",
        "<p>The omission of an explicit type might lead to confusion. For example, in the declaration:</p>",
        "<pre>",
        "extern void g ( char c, const k );",
        "</pre>",
        "the type of <code>k</code> is <i>const int</i> whereas <i>const char</i> might have been expected.",
        "<p><b>Example</b></p>",
        "<p>The following examples show compliant and non-compliant object declarations:</p>",
        "<pre>",
        "extern         x; /* Non-compliant - implicit int type */",
        "extern int16_t x; /* Compliant - explicit type */",
        "const          y; /* Non-compliant - implicit int type */",
        "const int16_t  y; /* Compliant - explicit type */",
        "</pre>",
        "<p>The following examples show compliant and non-compliant function type declarations:</p>",
        "<pre>",
        "extern f ( void );                         /* Non-compliant - implicit",
        "                                            * int return type */",
        "extern int16_t f ( void );                 /* Compliant */",
        "",
        "extern void g ( char c, const k );         /* Non-compliant - implicit",
        "                                            * int for parameter k */",
        "extern void g ( char c, const int16_t k ); /* Compliant */",
        "</pre>",
        "<p>The following examples show compliant and non-compliant type definitions:</p>",
        "<pre>",
        "typedef ( *pfi ) ( void );           /* Non-compliant - implicit int",
        "                                      * return type */",
        "typedef int16_t ( *pfi ) ( void );   /* Compliant */",
        "typedef void ( *pfv ) ( const x );   /* Non-compliant - implicit int",
        "                                      * for parameter x */",
        "typedef void ( *pfv ) ( int16_t x ); /* Compliant */",
        "</pre>",
        "<p>The following examples show compliant and non-compliant member declarations:</p>",
        "<pre>",
        "struct str",
        "{",
        "  int16_t x; /* Compliant */",
        "  const   y; /* Non-compliant - implicit int for member y */",
        "} s;",
        "</pre>",
        "<p><b>See also</b></p>",
        "<p>Rule 8.2</p>"
      ]
    }
  },

  "CPP_T054B": {
    "tags": ["Language: C", "Language: C++", "Types"],
    "key": "array-bounds",
    "name": "All Checks/Language Specific/C and C++/Types/An array or container shall not be accessed beyond its range Part B",
    "desc": {
      "html": [
        "<p><b>Rationale</b></p>",
        "<p>To avoid undefined behavior, range checks should be coded to ensure that container access via iterator arithmetic or subscript operator is within defined bounds. This could also be achieved by accessing an array via a subscript operator with constant indices only.</p>",
        "<p>When copying data via standard library algorithms (such as std::copy or std::transform), the target destination must be guaranteed to be large enough to hold the data.</p>",
        "<p>Note: This rule applies to C-style arrays and all other containers (including std::basic_string) that access their elements via iterators or via an index. The term iterator includes pointers.</p>",
        "<p>Note: Calculating an iterator one past the last element of the array is well defined, but dereferencing such an iterator is not.</p>",
        "<p><b>Example</b></p>",
        "<pre>",
        "1  // $Id: A5-2-5.cpp 289436 2017-10-04 10:45:23Z michal.szczepankiewicz $",
        "2  #include <array>",
        "3  #include <cstdint>",
        "4  #include <iostream>",
        "5  void Fn1() noexcept",
        "6  {",
        "7    constexpr std::int32_t arraySize = 16;",
        "8    std::int32_t array[arraySize]{0};",
        "9",
        "10   std::int32_t elem1 =",
        "11   array[0]; // Compliant - access with constant literal that",
        "12   // is less than ArraySize",
        "13   std::int32_t elem2 =",
        "14   array[12]; // Compliant - access with constant literal that",
        "15   // is less than ArraySize",
        "16   for (std::int32_t idx = 0; idx < 20; ++idx)",
        "17   {",
        "18     std::int32_t elem3 =",
        "19     array[idx]; // Non-compliant - access beyond ArraySize",
        "20     // bounds, which has 16 elements",
        "21   }",
        "22",
        "23   std::int32_t shift = 25;",
        "24   std::int32_t elem4 =",
        "25   *(array + shift); // Non-compliant - access beyond ArraySize bounds",
        "26",
        "27   std::int32_t index = 0;",
        "28   std::cin >> index;",
        "29   std::int32_t elem5 =",
        "30   array[index]; // Non-compliant - index may exceed the ArraySize bounds",
        "31   if (index < arraySize)",
        "32   {",
        "33     std::int32_t elem6 = array[index]; // Compliant - range check coded",
        "34   }",
        "35 }",
        "36 void Fn2() noexcept",
        "37 {",
        "38   constexpr std::int32_t arraySize = 32;",
        "39   std::array<std::int32_t, arraySize> array;",
        "40   array.fill(0);",
        "41",
        "42   std::int32_t elem1 =",
        "43   array[10]; // Compliant - access with constant literal that",
        "44   // is less than ArraySize",
        "45   std::int32_t index = 40;",
        "46   std::int32_t elem2 =",
        "47   array[index]; // Non-compliant - access beyond ArraySize bounds",
        "48   try",
        "49   {",
        "50     std::int32_t elem3 =",
        "51     array.at(50); // Compliant - at() method provides a",
        "52     // range check, throwing an exception if",
        "53     // input exceeds the bounds",
        "54   }",
        "55   catch (std::out_of_range&)",
        "56   {",
        "57     // Handle an error",
        "58   }",
        "59",
        "60   for (auto&& e : array) // The std::array provides a possibility to iterate",
        "61   // over its elements with range-based loop",
        "62   {",
        "63     // Iterate over all elements",
        "64   }",
        "65 }",
        "</pre>"
      ]
    }
  },

  "CPP_T060": {
    "tags": ["Language: C", "Language: C++", "Types"],
    "keys": ["int-conversion", "int-to-pointer-cast", "pointer-to-int-cast"],
    "name": "All Checks/Language Specific/C and C++/Types/Converting a pointer to integer or integer to pointer",
    "desc": {
      "html": [
        "<p><b>Title</b></p>",
        "<p>Converting a pointer to integer or integer to pointer</p>",

        "<p><b>Risk Assessment</b></p>",
        "<p>Converting from pointer to integer or vice versa results in code that is not portable and may create unexpected pointers to invalid memory locations.</p>",

        "<p><b>Full Standard</b></p>",
        "<p><a href='https://wiki.sei.cmu.edu/confluence/display/c/INT36-C.+Converting+a+pointer+to+integer+or+integer+to+pointer'>https://wiki.sei.cmu.edu/confluence/display/c/INT36-C.+Converting+a+pointer+to+integer+or+integer+to+pointer</a></p>",

        "<p><b>Exceptions</b></p>",
        "<p><b>INT36-C-EX1</b>: The integer value 0 can be converted to a pointer; it becomes the null pointer.</p>",
        "<p><b>INT36-C-EX2</b>: Any valid pointer to <code>void</code> can be converted to <code>intptr_t</code> or <code>uintptr_t</code> or their underlying types and back again with no change in value. Use of underlying types instead of <code>intptr_t</code> or <code>uintptr_t</code> is discouraged, however, because it limits portability.</p>",

        "<p><b>Noncompliant Code Example</b></p>",
        "<pre><code language=\"C++\">",
        "void f(void) {",
        "  char *ptr;",
        "  /* ... */",
        "  unsigned int number = (unsigned int)ptr;",
        "  /* ... */",
        "}",
        "</code></pre>"
      ]
    }
  },

  "CPP_P053": {
    "tags": ["Language: C", "Language: C++", "Pointers"],
    "key": "sti.PointerToNonExistentClassMembers",
    "name": "All Checks/Language Specific/C and C++/Pointers/A pointer to member shall not access non-existent class members",
    "desc": {
      "html": [
        "<p><b>Rationale</b></p>",
        "<p>Usage of a pointer-to-member expression leads to undefined behavior in the following cases:</p>",
        "<p>1) The pointer to member is a null pointer.</p>",
        "<p>2) The dynamic type of the object does not contain the member to which the called pointer to member refers.</p>",
        "<p><b>Example</b></p>",
        "<pre>",
        "1  // $Id: A5-5-1.cpp 302200 2017-12-20 17:17:08Z michal.szczepankiewicz $",
        "2  ",
        "3  class A",
        "4  {",
        "5  public:",
        "6      virtual ~A() = default",
        "7  };",
        "8  ",
        "9  class AA : public A",
        "10 {",
        "11 public:",
        "12     virtual ~AA() = default;",
        "13     virtual void foo() { } ",
        "14  ",
        "15     using ptr = void (AA::*)();",
        "16 };",
        "17  ",
        "18 Class B",
        "19 {",
        "20 public:",
        "21     static AA::ptr foo_ptr2",
        "22 };",
        "23  ",
        "24 AA::ptr B::foo_ptr2;",
        "25  ",
        "26 int main(void)",
        "27 {",
        "28     A* a = new A();",
        "29     void (A::*foo_ptr1)() = static_cast<void(A::*)()>(&AA::foo);",
        "30     (a->*foo_ptr1)(); // non-compliant",
        "31     delete a;",
        "32  ",
        "33     AA* aa = new AA();",
        "34     (aa->*B::foo_ptr2)(); // non-compliant, not explicitly initialized",
        "35     delete aa;",
        "36  ",
        "37     return 0;",
        "38 }",
        "</pre>"
      ]
    }
  },

  "CPP_EH006": {
    "tags": ["Language: C", "Language: C++", "Exception Handling"],
    "key": "exceptions",
    "name": "All Checks/Language Specific/C and C++/Exception Handling/If a function is declared to be noexcept, noexcept(true) or noexcept(<truecondition>), then it shall not exit with an exception",
    "desc": {
      "html": [
        "<p><b>Rationale</b></p>",
        "<p>If a function declared to be noexcept, noexcept(true) or noexcept(true condition) throws an exception, then std::terminate() is called immediately. It is implementation-defined whether the call stack is unwound before std::terminate() is called.</p>",
        "<p>To ensure that the rule is not violated, if functionโs noexcept specification can not be determined, then always declare it to be noexcept(false).</p>",
        "<p><b>Example</b></p>",
        "<pre>",
        "1  //% $Id: A15-4-2.cpp 289436 2017-10-04 10:45:23Z michal.szczepankiewicz $",
        "2  #include <stdexcept>",
        "3  // library.h",
        "4  void LibraryFunc();",
        "5  // project.cpp",
        "6  void F1() noexcept",
        "7  {",
        "8    // ...",
        "9    throw std::runtime_error(\"Error\"); // violation - F1 declared to be",
        "10   // noexcept, but exits with exception",
        "11   // this leads to std::terminate() call",
        "12 }",
        "13 void F2() noexcept(true)",
        "14 {",
        "15   try",
        "16   {",
        "17     // ...",
        "18     throw std::runtime_error(",
        "19       \"Error\");  // valid - exception will not leave F2",
        "20   }",
        "21   catch (std::runetime_error& e",
        "22   {",
        "23     // Handle runtime error",
        "24   }",
        "25 }",
        "26 void F3() noexcept(false)",
        "27 {",
        "28   // ...",
        "29   throw std::runtime_error(\"Error\"); // valid",
        "30 }",
        "31 void F4() noexcept(",
        "32   false) // valid - no information whether library_func() throws or not",
        "33 {",
        "34   LibraryFunc();",
        "35 }",
        "</pre>"
      ]
    }
  },

  "CPP_EH011": {
    "tags": [
      "Exception Handling",
      "Language: C",
      "Language: C++"
    ],
    "key": "cert-err61-cpp",
    "name": "All Checks/Language Specific/C and C++/Exception Handling/Catch exceptions by lvalue reference",
    "desc": {
      "html": [
        "<p><b>Title</b></p>",
        "<p>Catch exceptions by lvalue reference</p>",
        "<p><b>Risk Assessment</b></p>",
        "<p>Object slicing can result in abnormal program execution. This generally is not a problem for exceptions, but it can lead to unexpected behavior depending on the assumptions made by the exception handler.</p>",
        "<p><b>Full Standard</b></p>",
        "<p><a href='https://wiki.sei.cmu.edu/confluence/display/cplusplus/ERR61-CPP.+Catch+exceptions+by+lvalue+reference'>https://wiki.sei.cmu.edu/confluence/display/cplusplus/ERR61-CPP.+Catch+exceptions+by+lvalue+reference</a></p>",
        "<p><b>Noncompliant Code Example</b></p>",
        "<pre><code language=\"C++\">#include &lt;exception&gt;",
        "#include &lt;iostream&gt;",
        "",
        "struct S : std::exception {",
        "  const char *what() const noexcept override {",
        "    return \"My custom exception\";",
        "  }",
        "};",
        "",
        "void f() {",
        "  try {",
        "    throw S();",
        "  } catch (std::exception e) {",
        "    std::cout &lt;&lt; e.what() &lt;&lt; std::endl;",
        "  }",
        "}",
        "</code></pre>"
      ]
    }
  },

  "CPP_CF004": {
    "tags": ["Language: C", "Language: C++", "Control Flow"],
    "key": "sti.NoImplicitTerminate",
    "name": "All Checks/Language Specific/C and C++/Control Flow/The std::terminate() function shall not be called implicitly",
    "desc": {
      "text": "Check for implicit conversion from integer to floating-point types (C, C++, ObjC)",
      "html": [
        "<p><b>Int to Float Conversion (C, C++, ObjC)</b></p>",
        "<p>Check for implicit conversion from integer to floating-point types.</p>"
      ]
    }
  },

  "CPP_CF005": {
    "tags": ["Language: C", "Language: C++", "Control Flow"],
    "keys": ["sti.AbruptlyTerminate","exceptions"],
    "name": "All Checks/Language Specific/C and C++/Control Flow/Program shall not be abruptly terminated",
    "desc": {
      "text": "Abrupt",
      "html": [
        "<p>Program shall not be abruptly terminated. In particular, an implicit or explicit invocation of std::abort(), std::quick_exit(), std::_Exit(),std::terminate() shall not be done.</p>",
        "<p><b>Rationale</b></p>",
        "<p>Functions that are used to terminate the program in an immediate fashion, i.e. std::abort(), std::quick_exit(), std::_Exit(), do so without calling exit handlers or calling destructors of automatic, thread or static storage duration objects. It is implementationdefined whether opened streams are flushed and closed, and temporary files are removed.</p>",
        "<p>The std::terminate() function calls std::abort() implicitly in its terminate handler, and it is implementation-defined whether or not stack unwinding will occur.</p>",
        "<p>Note: std::terminate_handler shall not be used.</p>",
        "<p><b>Example</b></p>",
        "<pre>",
        "1  //% $Id: A15-5-2.cpp 289436 2017-10-04 10:45:23Z michal.szczepankiewicz $",
        "2  #include <cstdlib>",
        "3  #include <exception>",
        "4  void F1() noexcept(false);",
        "5  void F2() // Non-compliant",
        "6  {",
        "7    F1(); // A call to throwing f1() may result in an implicit call to",
        "8    // std::terminate()",
        "9  }",
        "10 void F3() // Compliant",
        "11 {",
        "12   try",
        "13   {",
        "14     F1(); // Handles all exceptions from f1() and does not re-throw",
        "15   }",
        "16   catch (...)",
        "17   {",
        "18     // Handle an exception",
        "19   }",
        "20 }",
        "21 void F4(const char* log)",
        "22 {",
        "23   // Report a log error",
        "24   // ...",
        "25   std::exit(0); // Call std::exit() function which safely cleans up resources",
        "26 }",
        "27 void F5() // Compliant by exception",
        "28 {",
        "29   try",
        "30   {",
        "31     F1();",
        "32   }",
        "33   catch (...)",
        "34   {",
        "35     F4(\"f1() function failed\");",
        "36   }",
        "37 }",
        "38 int main(int, char**)",
        "39 {",
        "40   if (std::atexit(&F2) != 0)",
        "41   {",
        "42     // Handle an error",
        "43   }",
        "44",
        "45   if (std::atexit(&F3) != 0)",
        "46   {",
        "47     // Handle an error",
        "48   }",
        "49",
        "50   // ...",
        "51   return 0;",
        "52 }",
        "</pre>"
      ]
    }
  },

  "CPP_U007": {
    "tags": ["Language: C", "Language: C++", "Unnecessary Constructs"],
    "key": "unused-label",
    "name": "All Checks/Language Specific/C and C++/Unnecessary Constructs/Unused Labels",
    "desc": {
      "html": [
        "<p>A function should not contain unused label declarations</p>",
        "<p><b>Rationale</b></p>",
        "<p>If a label is declared but not used, then it is unclear to a reviewer if the label is redundant or it has been left unused by mistake.</p>",
        "<p><b>Example</b></p>",
        "<pre>",
        "void unused_label ( void )",
        "{",
        "  int16_t x = 6;",
        "label1:              /* Non-compliant */",
        "  use_int16 ( x );",
        "}",
        "</pre>"
      ]
    }
  },

  "CPP_SA_DEAD_STORES": {
    "tags": ["Language: C", "Language: C++", "Dead Code"],
    "key": "deadcode.DeadStores",
    "name": "All Checks/Language Specific/C and C++/Dead Code/Dead Stores",
    "desc": {
      "text": "Check for values stored to variables that are never read afterwards (C, C++, ObjC)",
      "html": [
        "<p><b>Dead Stores (C, C++, ObjC)</b></p>",
        "<p>Check for values stored to variables that are never read afterwards.</p>",
        "<p>Examples:",
        "<pre><div class='highlight'><pre><span></span><span class='kt'>void</span> <span class='nf'>test</span><span class='p'>()</span> <span class='p'>{</span>",
        "  <span class='kt'>int</span> <span class='n'>x</span><span class='p'>;</span>",
        "  <span class='n'>x</span> <span class='o'>=</span> <span class='mi'>1</span><span class='p'>;</span> <span class='c1'>// warn</span>",
        "<span class='p'>}</span>",
        "</pre></div></pre></p>"
      ]
    },
    "options": [
      {
        "id": "deadcode.DeadStores:WarnForDeadNestedAssignments",
        "text": "Warn for dead nested assignments",
        "value": true
      }
    ]
  },
  "CPP_VF002": {
    "tags": [
      "Constructors",
      "Destructors",
      "Virtual Functions",
      "Language: C++"
    ],
    "keys": ["cplusplus.PureVirtualCall", "optin.cplusplus.VirtualCall"],
    "name": "All Checks/Language Specific/C and C++/Virtual Functions/Virtual Call in Constructor&#47;Destructor",
    "desc": {
      "html": [
        "<p><b>Title</b></p>",
        "<p>Never call virtual functions during construction or destruction.</p>",
        "",
        "<p><b>Developer's Notes</b></p>",
        "<p>Calling a virtual function of another object that is not `this` is allowed.</p>",
        "<p>Calling a virtual function without bypassing virtual dispatch is allowed. This occurs when the current class doesn't implement the virtual function.</p>"
      ]
    }
  }
}
