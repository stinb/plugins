# This script is designed to run with Understand - CodeCheck
# Written by Jason Quinn
# 5-17-2021
import re
import Modules

ERR1 = 'Const should be placed on the left-hand side of the comparison'

def id():
    return 'CPP_E066'

def name():
    return """\
All Checks/Language Specific/C and C++/Expressions/Const Should be placed on the \
left-hand side of the comparison"""


def tags(id):
    return {
        'CPP_E066': [
            'Language: C',
            'Language: C++',
            'Expressions',
        ],

    }.get(id)

def detailed_description():
    return """\
<p>When coding a conditional statement where a comparision is made to a
constant, it is recommended that the constant be placed on the left-hand side
of the comparison in order to cause the compiler to generate an error in cases
where a typo is made when inserting the conditional operator.</p>
<p>For example:</p>
<pre><code language="C++">const int max     = 10;
      int current = 5;
if (current = max) { // Error, operator should be one of &gt;=, &lt;=, !=, or ==
    ...
}</code></pre>
<p>In the case above an error has been inserted and will only be caught by a
review of the code. Using the recommended method of programming conditionals as
follows the error will be caught by the compiler:</p>
<pre><code language="C++">const int max     = 10;
      int current = 5;

if (max = current) { // Error, but an error message will be generated by the
    ...              // compiler due to an assignment to a constant.
}</code></pre>"""

def test_entity(file):
    return file.kind().check('code file, header file')

def test_language(language):
    return language == 'C++'

def check(check, file):
    lexer = None
    # Gather refs
    consts = file.filerefs('Assign Value ~Return, Use ~Return', 'Object')

    for const in consts:
        # Check if const
        if re.search(r'const', str(const.ent().type())):
            # Create lexer
            if not lexer:
                lexer = file.lexer()

            lexeme = lexer.lexeme(const.line(), const.column())
            prevLex = lexeme

            prevLex = prevLex.previous(ignore_whitespace=True, ignore_comments=True)
            # Check for the following comparative operators
            if re.match(r'==|!=|<=|>=|=', prevLex.text()):
                prevLex = prevLex.previous(ignore_whitespace=True, ignore_comments=True)
                if prevLex.ent() and re.search(r'const', prevLex.ent().type()):
                    continue
            else:
                continue

            # Look for if statements or while loops
            while prevLex and not re.match(r'if|while|;|}|{', prevLex.text()):
                if prevLex.text() == ')':
                    prevLex = Modules.findOpen(prevLex)
                elif prevLex.text() == '(':
                    prevLex = prevLex.previous(ignore_comments=True, ignore_whitespace=True)
                    if prevLex and not re.match(r'if|while|;|}|{', prevLex.text()):
                        break
                    continue
                    


                prevLex = prevLex.previous(ignore_comments=True, ignore_whitespace=True)
                if prevLex and (prevLex.ent() and re.search(r'const', str(prevLex.ent().type()))) or prevLex.text() == 'return':
                    break


            lexeme = lexeme.next(ignore_whitespace=True, ignore_comments=True)
            nextLex = lexeme.next(ignore_whitespace=True, ignore_comments=True)


            # Throw violation
            if prevLex and re.match(r'if|while', prevLex.text()) or lexeme.text() == '?' or (lexeme.text() == ')' and nextLex and nextLex.text() == '?'):
                ok = False
                if lexeme.text() == '?':
                    ok = checkConditionalOperator(lexeme)
                elif nextLex and nextLex.text() == '?':
                    ok = checkConditionalOperator(nextLex)

                        

                if not ok:
                    check.violation(const.ent(), file, lexeme.line_begin(), lexeme.column_begin(), ERR1)

    

# Returns true if a possible comparison is not found
def checkConditionalOperator(lexeme):
    count = 0
    while lexeme and not re.search(';|{|}', lexeme.text()):
        if re.search('=', lexeme.text()):
            count += 1
        lexeme = lexeme.previous(True, True)

    if count > 1:
        return False
    return True

