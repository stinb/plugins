# This script is designed to run with Understand - CodeCheck
# Written by Robby Bennett
# 2026-01-21


import re


ERR1 = 'Union declared'
ERR2 = 'Declaration with union type'


def ids():
    return ('MISRA04_18.4', 'MISRA08_9-5-1', 'CPP_S000')


def name(id):
    return {
        'MISRA04_18.4': '''Published Standards/MISRA-C 2004/\
18.4 Unions''',
        'MISRA08_9-5-1': '''Published Standards/MISRA-C++ 2008/\
9-5-1 Unions''',
       'CPP_S000': '''All Checks/Language Specific/C and C++/Structures and Unions/\
Unions''',
    }.get(id)


def tags(id):
    return {
        'MISRA04_18.4': [
            'Structures and Unions',
            'Language: C',
            'Language: C++',
            'Standard: MISRA C 2004',
            'Category: Required',
        ],
        'MISRA08_9-5-1': [
            'Structures and Unions',
            'Language: C',
            'Language: C++',
            'Standard: MISRA C++ 2008',
            'Category: Required',
        ],
        'CPP_S000': [
            'Structures and Unions',
            'Language: C',
            'Language: C++',
        ],
    }.get(id)


def detailed_description(id):
    return {
        'MISRA04_18.4': '''\
<p><b>Title</b></p>

<p>Unions shall not be used.</p>

<p><b>Description</b></p>

<p>Rule 18.3 prohibits the reuse of memory areas for unrelated purposes. However, even when memory is being reused for related purposes, there is still a risk that the data may be misinterpreted. Therefore, this rule prohibits the use of unions for any purpose.</p>
''',
        'MISRA08_9-5-1': '''\
<p><b>Title</b></p>

<p>Unions shall not be used.</p>

<p><b>Rationale</b></p>

<p>The use of unions to access an object in different ways may result in the data being misinterpreted.
Therefore, this rule prohibits the use of unions for any purpose.</p>

<p>It is recognized nonetheless that there are situations in which the careful use of unions is desirable
in constructing an efficient implementation. In such situations, deviations to this rule are considered
acceptable provided that all relevant implementation-defined behaviour is documented. This might
be achieved in practice by referencing the implementation section of the compiler manuals from
the design documentation.</p>

<p><b>Example</b></p>

<pre><code language="C++">\
namespace NS1
{
                 // Compliant - no union
}

namespace NS2
{
   union U1     // Non-compliant - union
   {
      int32_t   i;
      float32_t j;
   };
}\
</code></pre>
''',
        'CPP_S000': '''\
<p><b>Title</b></p>

<p>Unions shall not be used.</p>

<p><b>Description</b></p>

<p>When memory is being reused for related purposes, there is still a risk that the data may be misinterpreted.  Therefore, this rule prohibits the use of unions for any purpose.</p>
''',
    }.get(id)


def test_entity(file):
    return True


def test_global():
    return False


def test_language(language):
    return language == 'C++'


def check(check, file):
    for ref in file.filerefs('Declare, Define', 'Union'):
        check.violation(ref.ent(), file, ref.line(), ref.column(), ERR1)

    for ref in file.filerefs('Declare, Define', 'Type Alias, Typedef, Object, Parameter'):
        ent = ref.ent()

        if not is_union(ent):
            continue

        check.violation(ent, file, ref.line(), ref.column(), ERR2)


# Whether an entity or its underlying type is a union
def is_union(ent) -> bool:
    if ent.kind().check('Union') or re.search(r'\bunion\b', str(ent.type())):
        return True

    types = ent.ents('Typed')

    while True:
        if len(types) != 1:
            return False
        ent = types[0]

        kind = ent.kind()
        if kind.check('Union') or re.search(r'\bunion\b', str(ent.type())):
            return True
        elif kind.check('Type Alias, Typedef'):
            types = ent.ents('Typed')
            continue
        else:
            return False
