# This script is designed to run with Understand - CodeCheck
# Rewritten by Robby Bennett
# 2026-01-20


import re

from understand import Ref


ERR1 = 'Indistinct parameter %1'
ERR2 = 'Indistinct macro identifier conflicts with macro on line %1'


def ids():
    return ('MISRA12_5.4', 'MISRA23_5.4', 'CPP_I009')


def name(id):
    return {
        'MISRA12_5.4': '''Published Standards/MISRA C 2012/\
5.4 Indistinct Macro Identifiers''',
        'MISRA23_5.4': '''Published Standards/MISRA C 2023/\
5.4 Indistinct Macro Identifiers''',
        'CPP_I009': '''All Checks/Language Specific/C and C++/Identifiers/\
Indistinct Macro Identifiers''',
    }.get(id)


def tags(id):
    return {
        'MISRA12_5.4': [
            'CATEGORY',
            'Language: C',
            'Language: C++',
            'Standard: MISRA C 2012',
            'Category: TODO',
        ],
        'MISRA23_5.4': [
            'CATEGORY',
            'Language: C',
            'Language: C++',
            'Standard: MISRA C 2023',
            'Category: TODO',
        ],
        'CPP_I009': [
            'CATEGORY',
            'Language: C',
            'Language: C++',
        ],
    }.get(id)


def detailed_description(id):
    match id:
        case 'MISRA12_5.4' | 'MISRA23_5.4': return '''\
<p><b>Title</b></p>

<p>
<i>Macro identifiers</i> shall be distinct.
</p>

<p><b>Amplification</b></p>

<p>
This rule requires that, when a macro is being defined, its name be distinct from:
</p>

<ul>
<li>
the names of the other macros that are currently defined; and
</li>
<li>
the names of their parameters.
</li>
</ul>

<p>
It also requires that the names of the parameters of a given macro be distinct from each other but
does not require that macro parameters names be distinct across two different macros.
</p>

<p>
The definition of distinct depends on the implementation and on the version of the C language that
is being used:
</p>

<ul>
<li>
In C90 the <b>minimum</b> requirement is that the first 31 characters of <i>macro identifiers</i> are
significant;
</li>
<li>
In C99 the <b>minimum</b> requirement is that the first 63 characters of <i>macro identifiers</i> are
significant.
</li>
</ul>

<p>
In practice, implementations may provide greater limits. This rule requires that <i>macro identifiers</i> be
distinct within the limits imposed by the implementation.
</p>

<p><b>Rationale</b></p>

<p>
If two <i>macro identifiers</i> differ only in non-significant characters, the behaviour is undefined. Since macro
parameters are active only during the expansion of their macro, there is no issue with parameters in
one macro being confused with parameters in another macro.
</p>

<p>
If portability is a concern, it would be prudent to apply this rule using the minimum limits specified in
The Standard.
</p>

<p>
Long <i>macro identifiers</i> may impair the readability of code. While many automatic code generation
systems produce long <i>macro identifiers</i>, there is a good argument for keeping <i>macro identifier</i> lengths
well below this limit.
</p>

<p>
<i>Note</i>: In C99, if an extended source character appears in a macro name and that character does not
have a corresponding universal character, The Standard does not specify how many characters it
occupies.
</p>

<p><b>Example</b></p>

<p>
In the following example, the implementation in question supports 31 significant case-sensitive
characters in <i>macro identifiers</i>.
</p>

<pre><code language="C++">\
/*      1234567890123456789012345678901*********         Characters    */
#define engine_exhaust_gas_temperature_raw    egt_r
#define engine_exhaust_gas_temperature_scaled egt_s   /* Non-compliant */

/*      1234567890123456789012345678901*********         Characters    */
#define engine_exhaust_gas_temp_raw egt_r
#define engine_exhaust_gas_temp_scaled egt_s          /* Compliant     */\
</code></pre>

<p><b>See also</b></p>

<p>
Rule 5.1 , Rule 5.2, Rule 5.5
</p>
'''
        case 'CPP_I009': return '''\
<p><b>Title</b></p>

<p>
<i>Macro identifiers</i> shall be distinct.
</p>

<p><b>Amplification</b></p>

<p>
This rule requires that, when a macro is being defined, its name be distinct from:
</p>

<ul>
<li>
the names of the other macros that are currently defined; and
</li>
<li>
the names of their parameters.
</li>
</ul>

<p>
It also requires that the names of the parameters of a given macro be distinct from each other but
does not require that macro parameters names be distinct across two different macros.
</p>

<p>
The definition of distinct depends on the implementation and on the version of the C language that
is being used:
</p>

<ul>
<li>
In C90 the <b>minimum</b> requirement is that the first 31 characters of <i>macro identifiers</i> are
significant;
</li>
<li>
In C99 the <b>minimum</b> requirement is that the first 63 characters of <i>macro identifiers</i> are
significant.
</li>
</ul>

<p>
In practice, implementations may provide greater limits. This rule requires that <i>macro identifiers</i> be
distinct within the limits imposed by the implementation.
</p>

<p><b>Rationale</b></p>

<p>
If two <i>macro identifiers</i> differ only in non-significant characters, the behaviour is undefined. Since macro
parameters are active only during the expansion of their macro, there is no issue with parameters in
one macro being confused with parameters in another macro.
</p>

<p>
If portability is a concern, it would be prudent to apply this rule using the minimum limits specified in
The Standard.
</p>

<p>
Long <i>macro identifiers</i> may impair the readability of code. While many automatic code generation
systems produce long <i>macro identifiers</i>, there is a good argument for keeping <i>macro identifier</i> lengths
well below this limit.
</p>

<p>
<i>Note</i>: In C99, if an extended source character appears in a macro name and that character does not
have a corresponding universal character, The Standard does not specify how many characters it
occupies.
</p>

<p><b>Example</b></p>

<p>
In the following example, the implementation in question supports 31 significant case-sensitive
characters in <i>macro identifiers</i>.
</p>

<pre><code language="C++">\
/*      1234567890123456789012345678901*********             Characters */
#define engine_exhaust_gas_temperature_raw     egt_r
#define engine_exhaust_gas_temperature_scaled  egt_s   /* Non-compliant */

/*      1234567890123456789012345678901*********             Characters */
#define engine_exhaust_gas_temp_raw            egt_r
#define engine_exhaust_gas_temp_scaled         egt_s   /* Compliant     */\
</code></pre>
'''


def test_entity(file):
    return True


def test_global():
    return False


def test_language(language):
    return language == 'C++'


def define_options(check):
    check.options().checkbox('C99', 'Use C99 standard? (C90 default)', False)


def check(check, file):
    patterns_seen: dict[str, Ref] = dict()

    length = 63 if check.options().lookup('C99') else 31

    for ref in file.filerefs('Define, Declare', '~Inactive Macro'):
        ent = ref.ent()

        name = ent.name()
        substring = name[:length]

        # Check macro parameters if it has any
        parameters = ent.parameters()
        if parameters:
            parameters_seen: set[str] = set()

            for parameter in parameters.split(','):
                parameter_substring = parameter[:length]
                if parameter_substring not in parameters_seen:
                    parameters_seen.add(parameter_substring)
                    continue
                check.violation(ent, file, ref.line(), ref.column(), ERR2, parameter)

        # Test if we have seen this macro before

        # Skip if it's the first time
        seen_ref = patterns_seen.get(substring)
        if not seen_ref:
            patterns_seen[substring] = ref
            continue

        # Skip redefined macros
        if name == seen_ref.ent().name():
            continue

        check.violation(ent, file, ref.line(), ref.column(), ERR2, seen_ref.line())
