# This script is designed to run with Understand - CodeCheck
# Written by Robby Bennett
# 2026-01-16


import re


ERR1 = 'More than %1 characters are significant'


def ids():
    return ('MISRA04_5.1', 'CPP_I011')


def name(id):
    return {
        'MISRA04_5.1': '''Published Standards/MISRA-C 2004/\
5.1 Long Identifier Name Significance''',
        'CPP_I011': '''All Checks/Language Specific/C and C++/Identifiers/\
Long Identifier Name Significance''',
    }.get(id)


def tags(id):
    return {
        'MISRA04_5.1': [
            'Identifiers',
            'Language: C',
            'Standard: MISRA C 2004',
            'Category: Required',
        ],
        'CPP_I011': [
            'Identifiers',
            'Language: C',
        ],
    }.get(id)


def detailed_description(id):
    return '''\
<p><b>Title</b></p>

<p>Identifiers (internal and external) shall not rely on the significance of more than 31 characters.</p>

<p><b>Description</b></p>

<p>The ISO standard requires internal identifiers to be distinct in the first 31 characters to guarantee
code portability. This limitation shall not be exceeded, even if the compiler supports it. This rule
shall apply across all name spaces. Macro names are also included and the 31 character limit
applies before and after substitution.</p>

<p>The ISO standard requires external identifiers to be distinct in the first 6 characters, regardless
of case, to guarantee optimal portability. However this limitation is particularly severe and is
considered unnecessary. The intent of this rule is to sanction a relaxation of the ISO requirement
to a degree commensurate with modern environments and it shall be confirmed that 31 character/
case significance is supported by the implementation.</p>

<p>Note that there is a related issue with using identifier names that differ by only one or a few
characters, especially if the identifier names are long. The problem is heightened if the differences
are in easily mis-read characters like 1 (one) and l (lower case L), 0 and O, 2 and Z, 5 and S, or n
and h. It is recommended to ensure that identifier names are always easily visually distinguishable.
Specific guidelines on this issue could be placed in the style guidelines (see section 4.2.2).</p>
'''


def test_entity(file):
    return file.file_type() == 'C'


def test_global():
    return True


def test_language(language):
    return language == 'C++'


def define_options(check):
    check.options().integer('significantChars', 'Signficant characters', 31)


def check(check):
    significant_chars = check.options().lookup('significantChars')

    file_ids: set[int] = set()
    for file in check.files():
        file_ids.add(file.id())

    # Remember the count for each per significant part of long names
    long_name_ents: list[Ent] = []
    significant_name_to_count: dict[str, int] = dict()
    for ent in check.db().ents('C ~File'):
        name = ent.name()
        if len(name) <= significant_chars:
            continue

        long_name_ents.append(ent)

        sig = name[:significant_chars]
        count = significant_name_to_count.get(sig, 0)
        significant_name_to_count[sig] = count + 1

    # Now that duplicates of the significant parts of names are known, flag them
    for ent in long_name_ents:
        sig = ent.name()[:significant_chars]
        if significant_name_to_count.get(sig, 0) < 2:
            continue

        if ent.kind().check('Inactive'):
            continue

        ref = ent.ref('Definein, Declarein')
        if not ref:
            ref = ent.ref()
            if not ref:
                continue

        file = ref.file()
        if file.id() not in file_ids:
            continue

        check.violation(ent, file, ref.line(), ref.column(), ERR1, significant_chars)
