# This script is designed to run with Understand - CodeCheck
# Rewritten by Robby Bennett
# 2025-10-17


import re

from understand import Check, Ent, Lexeme, Ref


ERR1 = 'Non-distinct identifier conflicts with entity on line %1'


def ids():
    return ('MISRA12_5.2', 'MISRA23_5.2', 'CPP_I007')


def name(id):
    return {
        'MISRA12_5.2': '''Published Standards/MISRA C 2012/\
5.2 Identifiers declared in the same scope and name space shall be distinct''',
        'MISRA23_5.2': '''Published Standards/MISRA C 2023/\
5.2 Identifiers declared in the same scope and name space shall be distinct''',
        'CPP_I007': '''All Checks/Language Specific/C and C++/CATEGORY/\
Identifiers declared in the same scope and name space shall be distinct''',
    }[id]


def tags(id):
    return {
        'MISRA12_5.2': [
            'Identifiers',
            'Language: C',
            'Language: C++',
            'Standard: MISRA C 2012',
            'Category: Required',
        ],
        'MISRA23_5.2': [
            'Identifiers',
            'Language: C',
            'Language: C++',
            'Standard: MISRA C 2023',
            'Category: Required',
        ],
        'CPP_I007': [
            'Identifiers',
            'Language: C',
            'Language: C++',
        ],
    }.get(id)


def detailed_description(id):
    match id:
        case 'MISRA12_5.2': return '''\
<p><b>Title</b></p>

<p>Identifiers declared in the same <i>scope</i> and name space shall be
distinct.</p>

<p><b>Amplification</b></p>

<p>This rule does not apply if both identifiers are <i>external identifiers</i>
because this case is covered by Rule 5.1.</p>

<p>This rule does not apply if either identifier is a <i>macro identifier</i>
because this case is covered by Rule 5.4 and Rule 5.5.</p>

<p>The definition of distinct depends on the implementation and on the version
of the C language that is being used:</p>

<ul>

<li>In C90 the <b>minimum</b> requirement is that the first 31 characters are
significant;</li>

<li>In C99 the <b>minimum</b> requirement is that the first 63 characters are
significant, with each universal character or extended source character counting
as a single character.</li>

</ul>

<p><b>Rationale</b></p>

<p>If two identifiers differ only in non-significant characters, the behaviour
is undefined.</p>

<p>If portability is a concern, it would be prudent to apply this rule using the
minimum limits specified in The Standard.
</p>

<p>Long identifiers may impair the readability of code. While many automatic
code generation systems produce long identifiers, there is a good argument for
keeping identifier lengths well below this limit.</p>

<p><b>Example</b></p>

<p>In the following example, the implementation in question supports 31
significant case-sensitive characters inidentifi ers that do not have external
linkage.</p>

<p>The identifier <code>engine_exhaust_gas_temperature_local</code> is compliant
with this rule. Although it is not distinct from the identifier
<code>engine_exhaust_gas_temperature_raw</code>, it is in a different scope.
However, it is not compliant with Rule 5.3.</p>

<pre><code language="C++">\
/*             1234567890123456789012345678901*********      Characters */
extern int32_t engine_exhaust_gas_temperature_raw;
static int32_t engine_exhaust_gas_temperature_scaled;  /* Non-compliant */

void f ( void )
{
  /*      1234567890123456789012345678901*********           Characters */
  int32_t engine_exhaust_gas_temperature_local;        /* Compliant     */
}

/*             1234567890123456789012345678901*********      Characters */
static int32_t engine_exhaust_gas_temp_raw;
static int32_t engine_exhaust_gas_temp_scaled;         /* Compliant     */\
</code></pre>

<p><b>See also</b></p>

<p>Dir 1.1, Rule 5.1, Rule 5.3, Rule 5.4, Rule 5.5</p>
'''
        case 'MISRA23_5.2' | 'CPP_I007': return '''\
<p><b>Title</b></p>

<p>Identifiers declared in the same <i>scope</i> and name space shall be
distinct.</p>

<p><b>Amplification</b></p>

<p>This rule does not apply if:</p>

<ul>

<li>both identifiers are <i>external identifiers</i>, because this case is
covered by Rule 5.1, or</li>

<li>either identifier is a <i>macro identifier</i>, because this case is
covered by Rule 5.4 and Rule 5.5.</li>

</ul>

<p>The definition of distinct depends on the implementation and on the edition
of the C Standard that is being used:</p>

<ul>

<li>In C90 the <b>minimum</b> requirement is that the first 31 characters are
significant;</li>

<li>In C99 and later the <b>minimum</b> requirement is that the first 63
characters are significant, with each universal character or extended source
character counting as a single character.</li>

</ul>

<p><b>Rationale</b></p>

<p>If two identifiers differ only in non-significant characters, the behaviour
is undefined.</p>

<p>If portability is a concern, it would be prudent to apply this rule using the
minimum limits specified in the C Standard.</p>

<p>Long identifiers may impair the readability of code. While many automatic
code generation systems produce long identifiers, there is a good argument for
keeping identifier lengths well below this limit.</p>

<p><b>Rationale</b></p>

<p>In the following example, the implementation in question supports 31
significant case-sensitive characters in identifiers that do not have external
linkage.</p>

<p>The identifier <code>engine_exhaust_gas_temperature_local</code> is compliant
with this rule. Although it is not distinct from the identifier
<code>engine_exhaust_gas_temperature_raw</code>, it is in a different scope.
However, it is not compliant with Rule 5.3.</p>

<pre><code language="C++">\
/*             1234567890123456789012345678901*********      Characters */
extern int32_t engine_exhaust_gas_temperature_raw;
static int32_t engine_exhaust_gas_temperature_scaled;  /* Non-compliant */

void f ( void )
{
  /*      1234567890123456789012345678901*********           Characters */
  int32_t engine_exhaust_gas_temperature_local;        /* Compliant     */
}

/*             1234567890123456789012345678901*********      Characters */
static int32_t engine_exhaust_gas_temp_raw;
static int32_t engine_exhaust_gas_temp_scaled;         /* Compliant     */\
</code></pre>

<p><b>See also</b></p>

<p>Dir 1.1, Rule 5.1, Rule 5.3, Rule 5.4, Rule 5.5</p>
'''


def test_entity(file):
    return True


def test_global():
    return False


def test_language(language):
    return language == 'C++'


def define_options(check):
    check.options().checkbox('C99', 'Use C99 standard? (C90 default)', False)


def check(check, file):
    length = 63 if check.options().lookup('C99') else 31
    patternsSeen: dict[str, Ref] = dict()
    lex = file.lexer(show_inactive=False).first()
    checkScope(check, file, lex, 0, patternsSeen, length)


def checkScope(check: Check, file: Ent, lex: Lexeme, level: int, patternsSeen: dict[str, Ref], length: int) -> Lexeme | None:
    parametersSeen: dict[str, Ref] = dict()

    while lex:
        token = lex.token()
        text = lex.text()
        ref = lex.ref()

        # Check if we need to go up a level
        if token == 'Punctuation' and text == '}':
            return lex

        # Check if we need to go down a level
        elif token == 'Punctuation' and text == '{':
            lex = checkScope(check, file, lex.next(True, True), level + 1, parametersSeen, length)
            parametersSeen = dict()

        # If we see an identifier, check it add it to our hash
        elif token == 'Identifier' and ref:
            subString = lex.text()[:length]

            # Unless we are looking at a define reference, we don't care
            if not ref.kind().check('Definein, Declarein, Setby Init') or ref.scope().kind().check('Macro'):
                lex = lex.next(True, True)
                continue

            # We've seen this entity before; see if we should flag
            seenRef = patternsSeen.get(subString)
            if seenRef and not ref.scope().kind().check('Parameter'):
                allowed = False

                # Special case for constructors and destructors
                typeEnt = None
                if seenRef.ent().kind().check('Type'):
                    typeEnt = seenRef.ent()
                if seenRef.scope().kind().check('Type'):
                    typeEnt = seenRef.scope()
                    parent = ref.scope().parent()
                    if parent and typeEnt.longname() == parent.longname():
                        allowed = True

                if not allowed:
                    # Special case for overloaded functions
                    if seenRef.scope().name() == ref.scope().name():
                        allowed = True

                    # Special case to ignore violations at the global scope,
                    # another check tests the global scope
                    elif level == 0:
                        if not ref.scope().kind().check('Static') and not seenRef.scope().kind().check('Static'):
                            allowed = True

                if not allowed:
                    check.violation(ref.scope(), ref.file(), ref.line(), ref.column(), ERR1, seenRef.line())

            else:

                # If this is a parameter, we need to put it into a different
                # hash to pass into the next recursion, otherwise we store it in
                # this iteration
                if ref.scope().kind().check('Parameter'):
                    parametersSeen[subString] = ref
                else:
                    patternsSeen[subString] = ref

        if not lex:
            return None
        lex = lex.next(True, True)
