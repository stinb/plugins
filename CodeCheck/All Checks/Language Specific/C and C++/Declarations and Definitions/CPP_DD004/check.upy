# This script is designed to run with Understand - CodeCheck
# Written by Jordan Colbeth
# 12-8-2020

import re

def ids():
    return ('CPP_DD004')

def name(id):
    return {
        'CPP_DD004': '''All Checks/Language Specific/C and C++/Declarations and Definitions/\
Prototypes for static functions shall include the static storage class'''
    }[id]


def tags(id):
    return {
        'CPP_DD004': [
            'Language: C',
            'Language: C++',
            'Declarations and Definitions',
        ],

    }.get(id)

def detailed_description(id):
    return {
        'CPP_DD004': '''\
<p><b>Rationale</b></p>
<p>Prototypes for static functions shall include the static storage class. This is a convention that improves the readability
and maintainability of the code.</p>
<p><i>Developer's Note:</i> This CodeCheck does flag the function if a macro or externally defined keyword is used
instead of the static storage class. This was done intentionally, as it leads to potential false positives, whereas
if ignored, we would potentially get false negatives. False positives are preferred as they will provide more information
than necessary as opposed to missing things that should be caught.</p>
<p><b>Examples</b></p>
<pre><code language="C++">// flag violation, function prototype does not explicitly include static keyword
int addNumbers(int a, int b);

int main() {

   int sum;
   sum = addNumbers(4, 2);

   return 0;
}

static int addNumbers(int a, int b) {

   return a + b;

}
</code></pre>
</p>
'''
    }[id]

def test_entity(file):
	return file.kind().check('code file, header file')


def define_options(check):
	pass

def test_language(language):
    return language == 'C++'

def check(check, file):

	# Pull all unique static function definitions and c unresolved functions
	functions_defined = file.filerefs( 'Define', 'C Function Static ~Member ~Lambda', True)
	functions_declared = file.filerefs( 'Declare', 'C Unresolved Function', True)

	# initialize static function array
	static_funcs = []

	# Loop through all the static function definitions and grab names
	for func_def in functions_defined:

		# go to next iteration of for loop if name starts with two underscores
		if re.search(r"^__", func_def.ent().name()):
			continue

		elif re.match(r"main", func_def.ent().name()):
			continue

		# otherwise add name to an array
		else:
			static_funcs.append(func_def.ent().name())

	# Loop through all the unresolved function declarations and see if they match a static definition
	for func_dec in functions_declared:
		name = func_dec.ent().name()

		# unresolved func name matches a static func definition
		if func_dec.ent().name() in static_funcs:

			violation = check.violation(func_dec.ent(), file, func_dec.line(), func_dec.column(), "Prototype for static function '%1' does not include the static storage class", func_dec.ent())

			# copy entire line of violation for fix-it functionality
			line = ""
			lexer = file.lexer()
			lexeme = lexer.lexeme(func_dec.line(), 0)

			#print(lexeme.text())
			while lexeme.token() != "Newline":
				line = line + lexeme.text()
				#print("Line: " + line)
				lexeme = lexeme.next()

			new_line = "static " + line

			violation.add_fixit_hint(func_dec.line(), 1, func_dec.line(), len(line) + 1, new_line)
