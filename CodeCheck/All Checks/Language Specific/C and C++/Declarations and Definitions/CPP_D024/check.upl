# This script is designed to run with Understand - CodeCheck
# Written by Kyle Jackson
# 1-23-15


# Boiler Plate code
use base ( 'Understand::Codecheck' );
use strict;


# This is the error that will be returned when a violation is found
use constant ERR1 => 'Restrict type qualifier used';


# This registers ERR1 with Understand
sub register_tr_text {

  my $check = shift;
  $check->add_tr_text(ERR1);

}


# This is the short error the Understand will use

sub checkID { return "CPP_D024";}

sub name { return "All Checks\\Language Specific\\C and C++\\Declarations and Definitions\\The restrict type qualifier shall not be used";}


sub tags {
  return (
    'Language: C',
    'Language: C++',
    'Declarations and Definitions',
  );
}

# This is the full description of the rule being tested
sub description {
  return '( Required ) The restrict type qualifier shall not be used.';
}


# This section returns the rational and examples to be given to the user through Understand
sub detailed_description {
  return  <<"END_DESC"

<p><b>Developer's Note</b></p>
This check only works when the Strict parser is set to C99 or later.
</p>

<p><b>Rationale</b></p>
When used with care the restrict type qualifier may improve the efficiency of code generated by a
compiler. It may also allow improved static analysis. However, to use the restrict type qualifier the
programmer must be sure that the memory areas operated on by two or more pointers do not
overlap.
</p>

<p>
There is a significant risk that a compiler will generate code that does not behave as expected if restrict
is used incorrectly.
</p>

<p><b>Example</b></p>
The following example is compliant because the MISRA C Guidelines do not apply to The Standard
Library functions. The programmer must ensure that the areas defined by p, q and n do not overlap.
</p>

<pre><code language="C++">  void f ( void )
  {
    /* memcpy has restrict-qualified parameters */
    memcpy ( p, q, n );
  }

</code></pre>

<p>
The following example is non-compliant because a function has been defined using restrict.
</p>

<pre><code language="C++">  void user_copy ( void * restrict p, void * restrict q, size_t n )
  {
  }

</code></pre>

END_DESC
}


# This section defines the programming language this script is testing
sub test_language {
  my $language = shift;
  return $language eq "C++";
}


# This determines if this script is run per file
sub test_entity {
  return 1;
}


# This determines if this script is run on the whole project
sub test_global {
  return 0;
}


# Any defined options go here
sub define_options {
}


# This is the actual test being performed on the user's code
sub check {

  # Pull the name of the check and the name of the file from the incoming script request
  my $check = shift; 
  my $file = shift;
  return unless $file->kind->check( 'C File' );

  # Pull text of the file
  my $text = $file->contents;
  # Remove any // style comments
  $text =~ s/\/\/.*?\n/\n/g;
  # Remove any /* */ style comments
  $text =~ s/\/\*.*?\*\//\n/gs;

  # Skip this file unless the word restrict exists
  return unless $text =~ /\brestrict|restrict\b/;

  # Find the restrict usage and throw an error
  my $lexer = $file->lexer( 0 );
  my @lexemes = $lexer->lexemes if $lexer;
  
  foreach my $lexeme ( @lexemes ){
    $check->violation( $file, $file, $lexeme->line_begin, $lexeme->column_begin, ERR1 ) if (($lexeme->token eq 'Keyword' or $lexeme->token eq 'Identifier') and $lexeme->text eq 'restrict');
  }  
}
