# This script is designed to run with Understand - CodeCheck
# Rewritten by Robby Bennett
# 2026-01-20


import re


ERR1 = 'Dynamic memory statement'


def ids():
    return ('MISRA04_20.4', 'MISRA08_18-4-1', 'MISRA12_4.12', 'MISRA23_DIR_4.12', 'CPP_M000')


def name(id):
    return {
        'MISRA04_20.4': '''Published Standards/MISRA-C 2004/\
20.4 Dynamic Memory Allocation''',
        'MISRA08_18-4-1': '''Published Standards/MISRA-C++ 2008/\
18-4-1 Dynamic Memory Allocation''',
        'MISRA12_4.12': '''Published Standards/MISRA C 2012/\
4.12 Dynamic Memory Allocation''',
        'MISRA23_DIR_4.12': '''Published Standards/MISRA C 2023/\
4.12 Dynamic Memory Allocation''',
        'CPP_M000': '''All Checks/Language Specific/C and C++/Memory Allocation/\
Dynamic Memory Allocation''',
    }.get(id)


def tags(id):
    return {
        'MISRA04_20.4': [
            'Memory Allocation',
            'Language: C',
            'Language: C++',
            'Standard: MISRA C 2004',
            'Category: Required',
        ],
        'MISRA08_18-4-1': [
            'Memory Allocation',
            'Language: C',
            'Language: C++',
            'Standard: MISRA C++ 2008',
            'Category: Required',
        ],
        'MISRA12_4.12': [
            'Memory Allocation',
            'Language: C',
            'Language: C++',
            'Standard: MISRA C 2012',
            'Category: Required',
        ],
        'MISRA23_DIR_4.12': [
            'Memory Allocation',
            'Language: C',
            'Language: C++',
            'Standard: MISRA C 2023',
            'Category: Required',
        ],
        'CPP_M000': [
            'Memory Allocation',
            'Language: C',
            'Language: C++',
        ],
    }.get(id)


def detailed_description(id):
    match id:
        case 'MISRA04_20.4': return '''\
<p><b>Title</b></p>

<p>Dynamic heap memory allocation shall not be used.</p>

<p><b>Description</b></p>

<p>This precludes the use of the functions <i>calloc</i>, <i>malloc</i>, <i>realloc</i> and <i>free</i>.</p>

<p>There is a whole range of unspecifed, undefned and implementation-defned behaviour associated
with dynamic memory allocation, as well as a number of other potential pitfalls. Dynamic heap
memory allocation may lead to memory leaks, data inconsistency, memory exhaustion, non-
deterministic behaviour.</p>

<p>Note that some implementations may use dynamic heap memory allocation to implement other
functions (for example functions in the library string.h). If this is the case then these functions
shall also be avoided.</p>
'''
        case 'MISRA08_18-4-1': return '''\
<p><b>Title</b></p>

<p>Dynamic heap memory allocation shall not be used.</p>

<p><b>Rationale</b></p>

<p>The use of dynamic memory can lead to out-of-storage run-time failures, which are undesirable.</p>

<p>The built-in <i>new</i> and <i>delete</i> operators, other than the placement versions, use dynamic heap
memory. The functions <i>calloc</i>, <i>malloc</i>, <i>realloc</i> and <i>free</i> also use dynamic heap memory.</p>

<p>There is a range of <i>unspecified</i>, <i>undefined</i> and <i>implementation-defined behaviour</i> associated with
dynamic memory allocation, as well as a number of other potential pitfalls. Dynamic heap memory
allocation may lead to memory leaks, data inconsistency, memory exhaustion, non-deterministic
behaviour, etc.</p>

<p>Note that some implementations may use dynamic heap memory allocation to implement other
functions (for example, functions in the library <i>cstring</i>). If this is the case, then these functions
shall also be avoided.</p>

<p><b>Example</b></p>

<pre><code language="C++">\
void f1 ( )
{
   int32_t * i = new int32_t;       // Non-compliant
   delete i;
}\
</code></pre>
'''
        case 'MISRA12_4.12' | 'MISRA23_DIR_4.12' | 'CPP_M000': return '''\
<p><b>Title</b></p>

<p>
Dynamic memory allocation shall not be used.
</p>

<p><b>Amplification</b></p>

<p>
This rule applies to all dynamic memory allocation packages including:
</p>

<ul>
<li>
Those provided by The Standard Library;
</li>
<li>
Third-party packages.
</li>
</ul>

<p><b>Rationale</b></p>

<p>
The Standard Library’s dynamic memory allocation and deallocation routines can lead to undefined
behaviour as described in Rule 21.3. Any other dynamic memory allocation system is likely to exhibit
undefined behaviours that are similar to those of The Standard Library.
</p>

<p>
The specification of third-party routines shall be checked to ensure that dynamic memory allocation
is not being used inadvertently.
</p>

<p>
If a decision is made to use dynamic memory, care shall be taken to ensure that the software behaves
in a predictable manner. For example, there is a risk that:
</p>

<ul>
<li>
Insufficient memory may be available to satisfy a request — care must be taken to ensure
that there is a safe and appropriate response to an allocation failure;
</li>
<li>
There is a high variance in the execution time required to perform allocation or deallocation
depending on the pattern of usage and resulting degree of fragmentation.
</li>
</ul>

<p><b>Example</b></p>

<p>
For convenience, these examples are based around use of The Standard Library’s dynamic memory
functions as their interfaces are well-known.
</p>

<p>
In this example, the behaviour is undefined following the first call to <i>free</i> because the value of the
pointer <code>p</code> becomes indeterminate. Although the value stored in the pointer is unchanged following
the call to <i>free</i>, it is possible, on some targets, that the memory to which it points no longer exists and
the act of copying that pointer could cause a memory exception.
</p>

<pre><code language="C++">\
#include &lt;stdlib.h&gt;

void f ( void )
{
   char     *p = ( char * ) malloc ( 10 );
   char     *q;

   free ( p );
   q = p;         /* Undefined behaviour - value of p is indeterminate    */

   p = ( char * ) malloc ( 20 );
   free ( p );
   p = NULL;      /* Assigning NULL to freed pointer makes it determinate */
}\
</code></pre>

<p><b>See also</b></p>

<p>
Dir 4.1, Rule 18.7, Rule 21.3, Rule 22.1, Rule 22.2
</p>
'''


def test_entity(file):
    return True


def test_global():
    return False


def test_language(language):
    return language == 'C++'


def define_options(check):
    check.options().checkbox('ignoreUnique', 'Ignore unique_ptr', False)


def check(check, file):
    ignore_unique = check.options().lookup('ignoreUnique')

    # Look for dynamic allocation functions
    for ref in file.filerefs('Call', 'Function'):
        ent = ref.ent()
        if ent.longname() not in {'calloc', 'free', 'malloc', 'realloc'}:
            continue
        check.violation(ent, file, ref.line(), ref.column(), ERR1)

    # Look for new and delete
    for lex in file.lexer(False).lexemes():
        if lex.token() != 'Keyword':
            continue

        text = lex.text()
        if text == 'new':
            pass
        elif text == 'delete':
            # Special case for `= delete` because of C++ 11
            prev = lex.previous(True, True)
            if prev and prev.text() == '=':
                continue
        else:
            continue

        if ignore_unique:
            # Test to see if it is wrapped in a smart pointer
            in_smart_pointer = False
            temp_lex = lex
            while temp_lex:
                text = temp_lex.text()
                if text == 'unique_ptr':
                    in_smart_pointer = True
                    break
                elif text == ';':
                    break
                temp_lex = temp_lex.previous(True, True)
            if in_smart_pointer:
                continue

        check.violation(None, file, lex.line_begin(), lex.column_begin(), ERR1)
