# This script is designed to run with Understand - CodeCheck
# Rewritten by Robby Bennett
# 2025-09-30


import re


ERR1 = 'Class type exception not caught by reference'


def ids():
    return ('MISRA08_15-3-5', 'CPP_E000')


def name(id):
    return {
        'MISRA08_15-3-5': '''Published Standards/MISRA-C++ 2008/\
15-3-5 Exception by Value''',
        'CPP_E000': '''All Checks/Language Specific/C and C++/Exception Handling/\
Exception by Value''',
    }[id]


def tags(id):
    return {
        'MISRA08_15-3-5': [
            'Exception Handling',
            'Standard: MISRA C++ 2008',
            'Category: Required',
        ],
        'CPP_E000': [
            'Exception Handling',
            'Language: C++',
        ],
    }.get(id)


def detailed_description(id):
    return '''\
<p><b>Title</b></p>

<p>A class type exception shall always be caught by reference.</p>

<p><b>Rationale</b></p>

<p>If a class type exception object is caught by value, slicing occurs. That is,
if the exception object is of a derived class and is caught as the base, only
the base class's functions (including virtual functions) can be called. Also,
any additional member data in the derived class cannot be accessed.</p>

<p>If the exception is caught by reference, slicing does not occur.</p>

<p><b>Example</b></p>
<pre><code language="C++">\
// base class for exceptions
class ExpBase
{
public:
   virtual const char_t *who ( )
   {
      return "base";
   };
};

class ExpD1: public ExpBase
{
public:
   virtual const char_t *who ( )
   {
      return "type 1 exception";
   };
};

class ExpD2: public ExpBase
{
public:
   virtual const char_t *who ( )
   {
      return "type 2 exception";
   };
};

try
{
   // ...
   throw ExpD1 ( );
   // ...
   throw ExpBase ( );
}
catch ( ExpBase &b ) // Compliant â€“ exceptions caught by reference
{
   // ...
   b.who(); // "base", "type 1 exception" or "type 2 exception"
            // depending upon the type of the thrown object
}
// Using the definitions above ...
catch ( ExpBase b ) // Non-compliant - derived type objects will be
                    // caught as the base type
{
   b.who();         // Will always be "base"
   throw b;         // The exception re-thrown is of the base class,
                    // not the original exception type
}\
</code></pre>
'''


def test_entity(file):
    return True


def test_global():
    return False


def test_language(language):
    return language == 'C++'


def check(check, file):
    lexer = file.lexer(False)

    # Class name in the catch statement
    for ref in file.filerefs('Catch', 'Class'):
        # Skip if caught by reference
        lex = lexer.lexeme(ref.line(), ref.column())
        if lex:
            lex = lex.next(True, True)
            if lex and lex.text() == '&':
                continue

        check.violation(ref.ent(), file, ref.line(), ref.column(), ERR1)
