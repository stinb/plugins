# This script is designed to run with Understand - CodeCheck
# Written by Robby Bennett
# 2025-10-20


import re

from understand import Ent, Ref


ERR1 = 'Bounds-checking function used'
ERR2 = 'Bounds-checking macro used'
ERR3 = 'Bounds-checking typedef used'

FUNCTIONS = {'abort_handler_s', 'asctime_s', 'bsearch_s', 'ctime_s', 'fopen_s', 'fprintf_s', 'freopen_s', 'fscanf_s', 'fwprintf_s', 'fwscanf_s', 'getenv_s', 'gets_s', 'gmtime_s', 'ignore_handler_s', 'localtime_s', 'mbsrtowcs_s', 'mbstowcs_s', 'memcpy_s', 'memmove_s', 'memset_s', 'printf_s', 'qsort_s', 'scanf_s', 'set_constraint_handler_s', 'snprintf_s', 'snwprintf_s', 'sprintf_s', 'sscanf_s', 'strcat_s', 'strcpy_s', 'strerror_s', 'strerrorlen_s', 'strncat_s', 'strncpy_s', 'strnlen_s', 'strtok_s', 'swprintf_s', 'swscanf_s', 'tmpfile_s', 'tmpnam_s', 'vfprintf_s', 'vfscanf_s', 'vfwprintf_s', 'vfwscanf_s', 'vprintf_s', 'vscanf_s', 'vsnprintf_s', 'vsnwprintf_s', 'vsprintf_s', 'vsscanf_s', 'vswprintf_s', 'vswscanf_s', 'vwprintf_s', 'vwscanf_s', 'wcrtomb_s', 'wcscat_s', 'wcscpy_s', 'wcsncat_s', 'wcsncpy_s', 'wcsnlen_s', 'wcsrtombs_s', 'wcstok_s', 'wcstombs_s', 'wctomb_s', 'wmemcpy_s', 'wmemmove_s', 'wprintf_s', 'wscanf_s'}

MACROS = {'errno_t', 'L_tmpnam_s', 'RSIZE_MAX', 'TMP_MAX_S'}

TYPEDEFS = {'errno_t', 'rsize_t'}


def ids():
    return ('MISRA23_1.4', 'CPP_L032')


def name(id):
    return {
        'MISRA23_1.4': '''Published Standards/MISRA C 2023/\
1.4 Bounds-checking Interfaces''',
        'CPP_L032': '''All Checks/Language Specific/C and C++/Libraries/\
Bounds-checking Interfaces''',
    }[id]


def tags(id):
    return {
        'MISRA23_1.4': [
            'Libraries',
            'Language: C',
            'Language: C++',
            'Standard: MISRA C 2023',
            'Category: Required',
        ],
        'CPP_L032': [
            'Libraries',
            'Language: C',
            'Language: C++',
        ],
    }.get(id)


def detailed_description(id):
    return '''\
<p><b>Title</b></p>

<p>Emergent language features shall not be used.</p>

<p><b>Amplification</b></p>

<p>Updates to the C Standard have introduced new language features. The following shall not be used:</p>

<ul>

<li>Other than defining <code>__STDC_WANT_LIB_EXT1__</code> to 0, the facilities of Annex K (Boundschecking interfaces) shall not be used.</li>

</ul>

<p><b>Rationale</b></p>

<p>Use of the language features restricted by this rule may have instances of undefined, unspecified or
implementation-defined behaviour associated with them. In addition, features may also exhibit well
defined behaviour that does not meet developer expectations.</p>

<p>Any instances of undefined, unspecified or implementation-defined behaviour are diagnosed by:</p>

<ul>

<li>Dir 1.1, which requires that the use of implementation-defined behaviour be documented
and taken into consideration; and</li>

<li>Rule 1.3, which prohibits the presence of undefined and critical unspecified behaviours.</li>

</ul>

<p>However, detection of these behaviours alone does not mitigate against well-defined behaviour that
does not meet developer expectations. Additional static analysis checks are needed to check for
these behaviours, but there is no requirement for a static analysis tool to implement these checks as
they are not specified within The Guidelines.</p>

<p>This Rule requires that any use of an emergent language feature be supported by a deviation to
ensure that all undesirable behaviours are identified and measures put in place to ensure that they
do not compromise safety or security</p>

<p><b>See also</b></p>

<p>Dir 1.1, Rule 1.3</p>
'''


def test_entity(file):
    return True


def test_global():
    return False


def test_language(language):
    return language == 'C++'


def check(check, file):
    for ref in file.filerefs('', 'Function'):
        ent = ref.ent()
        if ent.longname() not in FUNCTIONS:
            continue
        check.violation(ent, file, ref.line(), ref.column(), ERR1)

    for ref in file.filerefs('', 'Macro'):
        ent = ref.ent()
        if ent.longname() not in MACROS:
            continue
        check.violation(ent, file, ref.line(), ref.column(), ERR2)

    for ref in file.filerefs('', 'Typedef'):
        ent = ref.ent()
        if ent.longname() not in TYPEDEFS:
            continue
        check.violation(ent, file, ref.line(), ref.column(), ERR3)
