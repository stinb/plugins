# This script is designed to run with Understand - CodeCheck
# Rewritten by Robby Bennett
# 2026-02-18


import re

from understand import Check, Ent, Lexeme


ERR1 = 'Line-splicing used in // comment'


def ids():
    return ('MISRA12_3.2', 'MISRA23_3.2', 'MISRA23_5.7.3', 'CPP_C001')


def name(id):
    return {
        'MISRA12_3.2': '''Published Standards/MISRA C 2012/\
3.2 Line-Splicing in &#47;&#47; Comments''',
        'MISRA23_3.2': '''Published Standards/MISRA C 2023/\
3.2 Line-Splicing in &#47;&#47; Comments''',
        'MISRA23_5.7.3': '''Published Standards/MISRA C++ 2023/\
5.7.3 Line-Splicing in &#47;&#47; Comments''',
        'CPP_C001': '''All Checks/Language Specific/C and C++/Comments/\
Line-Splicing in &#47;&#47; Comments''',
    }.get(id)


def tags(id):
    return {
        'MISRA12_3.2': [
            'Comments',
            'Language: C',
            'Language: C++',
            'Standard: MISRA C 2012',
            'Category: Required',
        ],
        'MISRA23_3.2': [
            'Comments',
            'Language: C',
            'Language: C++',
            'Standard: MISRA C 2023',
            'Category: Required',
        ],
        'MISRA23_5.7.3': [
            'Comments',
            'Language: C',
            'Language: C++',
            'Standard: MISRA C++ 2023',
            'Category: Required',
        ],
        'CPP_C001': [
            'Comments',
            'Language: C',
            'Language: C++',
        ],
    }.get(id)


def detailed_description(id):
    match id:
        case 'MISRA12_3.2': return '''\
<p><b>Title</b></p>

<p>Line-splicing shall not be used in <code>//</code> comments.</p>

<p><b>Amplification</b></p>

<p>
Line-splicing occurs when the <code>\\</code> character is immediately followed by a new-line character. If the
source file contains multibyte characters, they are converted to the source character set before any
splicing occurs.
</p>

<p><b>Rationale</b></p>

<p>
If the source line containing a <code>//</code> comment ends with a <code>\\</code> character in the source character set, the
next line becomes part of the comment. This may result in unintentional removal of code.
</p>

<p>
<i>Note</i>: line-splicing is described in Section 5.1.1.2(2) of both C90 and C99.
</p>

<p><b>Example</b></p>

<p>
In the following non-compliant example, the physical line containing the <i>if</i> keyword is logically part of
the previous line and is therefore a comment.
</p>

<pre><code language="C++">\
extern bool_t b;

void f ( void )
{
  uint16_t x = 0;   // comment \\
  if ( b )
  {
    ++x;            /* This is always executed */
  }
}\
</code></pre>

<p><b>See also</b></p>

<p>
Dir 4.4
</p>
'''
        case 'MISRA23_3.2': return '''\
<p><b>Title</b></p>

<p>Line-splicing shall not be used in <code>//</code> comments.</p>

<p><b>Amplification</b></p>

<p>
Line-splicing occurs when the <code>\\</code> character is immediately followed by a new-line character. If the
source file contains multibyte characters, they are converted to the source character set before any
splicing occurs.
</p>

<p><b>Rationale</b></p>

<p>
If the source line containing a <code>//</code> comment ends with a <code>\\</code> character in the source character set, the
next line becomes part of the comment. This may result in unintentional removal of code.
</p>

<p><b>Example</b></p>

<p>
In the following non-compliant example, the physical line containing the <i>if</i> keyword is logically part of
the previous line and is therefore a comment.
</p>

<pre><code language="C++">\
extern bool_t b;

void f ( void )
{
  uint16_t x = 0;   // comment \\
  if ( b )
  {
    ++x;            /* This is always executed */
  }
}\
</code></pre>

<p><b>See also</b></p>

<p>
Dir 4.4
</p>
'''
        case 'MISRA23_5.7.3': return '''\
<p><b>Title</b></p>

<p>Line-splicing shall not be used in <code>//</code> comments.</p>

<p><b>Amplification</b></p>

</p>This rule is applied in translation phase 2, after multibyte characters have been mapped to the basic
source character set during translation phase 1 (see [lex.phases]).</p>

<p><b>Rationale</b></p>

<p>Line-splicing occurs when the <code>\\</code> character is immediately followed by a new-line character. If a source
line containing a <code>//</code> comment ends with a <code>\\</code> character in the basic source character set, the next line
becomes part of the comment. This may result in the unintentional removal of code.</p>

<p><b>Example</b></p>
In the following non-compliant example, the physical line containing the <code>if</code> keyword is logically part of
the previous line and is therefore a comment.
</p>

<pre><code language="C++">\
void f( bool b )
{
  uint16_t x = 0U;   // comment \
  if ( b )
  {
    ++x;             // This is always executed
  }
}\
</code></pre>
'''
        case 'CPP_C001': return '''\
<p><b>Title</b></p>

<p>Line-splicing shall not be used in <code>//</code> comments.</p>

<p><b>Amplification</b></p>

<p>
Line-splicing occurs when the <code>\\</code> character is immediately followed by a new-line character. If the
source file contains multibyte characters, they are converted to the source character set before any
splicing occurs.
</p>

<p><b>Rationale</b></p>

<p>
If the source line containing a <code>//</code> comment ends with a <code>\\</code> character in the source character set, the
next line becomes part of the comment. This may result in unintentional removal of code.
</p>

<p><b>Example</b></p>

<p>
In the following non-compliant example, the physical line containing the <i>if</i> keyword is logically part of
the previous line and is therefore a comment.
</p>

<pre><code language="C++">\
extern bool_t b;

void f ( void )
{
  uint16_t x = 0;   // comment \\
  if ( b )
  {
    ++x;            /* This is always executed */
  }
}\
</code></pre>
'''


def test_entity(file: Ent) -> bool:
    return True


def test_global() -> bool:
    return False


def test_language(language: str) -> bool:
    return language == 'C++'


def check(check: Check, file: Ent):
    lex: Lexeme | None = file.lexer(False).first()

    while lex:
        if lex.token() == 'Comment' and re.search(r'^//.*\\[\n\r]', lex.text()):
            check.violation(None, file, lex.line_begin(), lex.column_begin(), ERR1)

        lex = lex.next(ignore_whitespace=True)
