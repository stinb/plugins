# This script is designed to run with Understand - CodeCheck
# Written by Robby Bennett
# 2026-02-02


import re

from understand import Check, Ent, Lexeme


ERR1 = '#undef used'


def ids():
    return ('MISRA04_19.6', 'MISRA08_16-0-3', 'MISRA12_20.5', 'MISRA23_20.5', 'CPP_P026')


def name(id):
    return {
        'MISRA04_19.6': '''Published Standards/MISRA-C 2004/\
19.6 Preprocessor #undef''',
        'MISRA08_16-0-3': '''Published Standards/MISRA-C++ 2008/\
16-0-3 Preprocessor #undef''',
        'MISRA12_20.5': '''Published Standards/MISRA C 2012/\
20.5 Preprocessor #undef''',
        'MISRA23_20.5': '''Published Standards/MISRA C 2023/\
20.5 Preprocessor #undef''',
        'CPP_P026': '''All Checks/Language Specific/C and C++/Preprocessor/\
Preprocessor #undef''',
    }.get(id)


def tags(id):
    return {
        'MISRA04_19.6': [
            'Preprocessor',
            'Language: C',
            'Language: C++',
            'Standard: MISRA C 2004',
            'Category: Required',
        ],
        'MISRA08_16-0-3': [
            'Preprocessor',
            'Language: C',
            'Language: C++',
            'Standard: MISRA C++ 2008',
            'Category: Required',
        ],
        'MISRA12_20.5': [
            'Preprocessor',
            'Language: C',
            'Language: C++',
            'Standard: MISRA C 2012',
            'Category: Advisory',
        ],
        'MISRA23_20.5': [
            'Preprocessor',
            'Language: C',
            'Language: C++',
            'Standard: MISRA C 2023',
            'Category: Advisory',
        ],
        'CPP_P026': [
            'Preprocessor',
            'Language: C',
            'Language: C++',
        ],
    }.get(id)


def detailed_description(id):
    match id:
        case 'MISRA04_19.6': return '''\
<p><b>Title</b></p>

<p><i>#undef</i> shall not be used.</p>

<p><b>Description</b></p>

<p><i>#undef</i> should not normally be needed. Its use can lead to confusion with respect to the existence
or meaning of a macro when it is used in the code.</p>
'''
        case 'MISRA08_16-0-3': return '''\
<p><b>Title</b></p>

<p><i>#undef</i> shall not be used.</p>

<p><b>Rationale</b></p>

<p><i>#undef</i> should not normally be needed. Its use can lead to confusion with respect to the existence
or meaning of a macro when it is used in the code.</p>

<p><b>Example</b></p>

<pre><code language="C++">\
#ifndef MY_HDR
#define MY_HDR

#undef MY_HDR        // Non-compliant

#endif\
</code></pre>
'''
        case 'MISRA12_20.5' | 'MISRA23_20.5' | 'CPP_P026': return '''\
<p><b>Title</b></p>

<p><i>#undef</i> should not be used.</p>

<p><b>Rationale</b></p>

<p>The use of <i>#undef</i> can make it unclear which macros exist at a particular point within a translation
unit.</p>

<p><b>Example</b></p>

<pre><code language="C++">\
#define QUALIFIER volatile

#undef QUALIFIER             /* Non-compliant */

void f ( QUALIFIER int32_t p )
{
  while ( p != 0 )
  {
    ;                        /* Wait... */
  }
}\
</code></pre>
'''


def test_entity(file: Ent) -> bool:
    return True


def test_global() -> bool:
    return False


def test_language(language: str) -> bool:
    return language == 'C++'


def define_options(check: Check):
    check.options().checkbox('OnlyActive', "Don't show violations in inactive code", False)
    check.options().checkbox('GetEntities', 'Get macro entities', False)


def check(check: Check, file: Ent):
    only_active = bool(check.options().lookup('OnlyActive'))
    get_entities = bool(check.options().lookup('GetEntities'))

    lex: Lexeme | None = file.lexer(get_entities).first()

    while lex:
        if only_active and lex.inactive():
            lex = lex.next(True, True)
            continue

        if lex.text() != 'undef' or lex.token() != 'Preprocessor':
            lex = lex.next(True, True)
            continue

        ent: None | Ent = None
        if get_entities:
            next_lex = lex.next(True, True)
            if next_lex:
                ent = next_lex.ent()

        check.violation(ent, file, lex.line_begin(), lex.column_begin(), ERR1)
        lex = lex.next(True, True)
