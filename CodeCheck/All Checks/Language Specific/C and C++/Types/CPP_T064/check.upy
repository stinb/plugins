# This script is designed to run with Understand - CodeCheck
# Written by Robby Bennett
# 2025-10-23


import re


ERR1 = 'Pointer to variable-length array'


def ids():
    return ('MISRA23_18.10', 'CPP_T064')


def name(id):
    return {
        'MISRA23_18.10': '''Published Standards/MISRA C 2023/\
18.10 Pointer to Variable-length Array''',
        'CPP_T064': '''All Checks/Language Specific/C and C++/Types/\
Pointer to Variable-length Array''',
    }[id]


def tags(id):
    return {
        'MISRA23_18.10': [
            'Types',
            'Language: C',
            'Language: C++',
            'Standard: MISRA C 2023',
            'Category: Mandatory',
        ],
        'CPP_T064': [
            'Types',
            'Language: C',
            'Language: C++',
        ],
    }.get(id)


def detailed_description(id):
    return '''\
<p><b>Title</b></p>

<p>Pointers to variably-modified array types shall not be used.</p>

<p><b>Amplification</b></p>

<p>A pointer to a variably-modified array type shall not be used in the declaration of any object or
parameter.</p>

<p>A parameter declared to have an array type is not a pointer-to-array type (unless it is an array of
arrays), because it is rewritten to a pointer to the element type.</p>

<p><b>Rationale</b></p>

<p>Compatibility between array types requires the size specifiers for the pointed-to arrays to have equal
values. However, for variably-modified array types this cannot be determined at compile-time.</p>

<p>If two pointers to array types are used in any way that requires them to be compatible (such as
assignment), and the size specifiers for the pointed-to array are not the same, the behaviour is
undefined. This is undecidable in general, effectively leaving all such operations untyped.</p>

<p><b>Example</b></p>

<pre><code language="C++">\
/* Non-compliant */
void f1 (uint16_t n, uint16_t (* a) [n])
{
  uint16_t ( *p )[ 20 ];
  p = a; /* undefined unless n == 20, but types always assumed compatible */
}

/* Compliant */
void f2 (uint16_t n, uint16_t a[n])
{
  uint16_t * p;
  p = a; /* pointed-to type is not variably-modified, always well-defined */
}\
</code></pre>

<p><b>See also</b></p>

<p>Rule 18.8</p>
'''


def test_entity(file):
    return True


def test_global():
    return False


def test_language(language):
    return language == 'C++'


def check(check, file):
    for ref in file.filerefs('Declare, Define', 'Object, Parameter, Typedef, Type Alias'):
        ent = ref.ent()

        # Skip unless it's a pointer to a variable-length array
        if not re.search(r'\*\)\[[^\d]', ent.freetext('UnderlyingType')):
            continue

        check.violation(ent, file, ref.line(), ref.column(), ERR1)
