# This script is designed to run with Understand - CodeCheck
# Converted to python by Jason Quinn
# 01-25-23

import re
import Modules

ERR1 = """\
The value returned by a function having non-void return type was not used\
"""

DEF_NAME = """\
The value returned by a function having non-void return type shall be used"""

# The ID for the check
def ids():
    return ('MISRA12_17.7', 'A0-1-2', 'CPP_F024', 'MISRA08_0-1-7', 'MISRA23_17.7', 'MISRA23_0.1.2')

# Required - Return the short name of the check
def name(id):
    return {
            'MISRA12_17.7': "Published Standards/MISRA C 2012/17.7" + DEF_NAME,
            'MISRA08_0-1-7': """\
Published Standards/MISRA-C++ 2008/0-1-7 The value returned by a function having \
a non-void return type that is not an overloaded operator shall always be used \
            """,
            'A0-1-2': 'Published Standards/AUTOSAR/The value returned by a function shall be used',
            'CPP_F024': 'All Checks/Language Specific/C and C++/Functions/The value returned by a function shall be used',
            'MISRA23_17.7': "Published Standards/MISRA C 2023/" + DEF_NAME,
            'MISRA23_0.1.2': "Published Standards/MISRA C++ 2023/0.1.2 The value returned by a function shall be used",
            }[id]



def tags(id):
    return {
        'MISRA08_0-1-7': [
            'Language: C',
            'Language: C++',
            'Standard: MISRA C++ 2008',
            'Category: Required',
            'Functions',
        ],
        'MISRA12_17.7': [
            'Language: C',
            'Standard: MISRA C 2012',
            'Category: Required',
            'Functions',
        ],
        'A0-1-2': [
            'Language: C',
            'Language: C++',
            'Standard: AUTOSAR',
            'Category: Required',
            'Automation: Automated',
            'Functions'
        ],
        'CPP_F024': [
            'Language: C',
            'Functions',
        ],
        'MISRA23_17.7': [
            'Language: C',
            'Standard: MISRA C 2023',
            'Category: Required',
            'Functions',
        ],
        'MISRA23_0.1.2': [
            'Language: C',
            'Language: C++',
            'Standard: MISRA C++ 2023',
            'Category: Required',
            'Functions',
        ],
    }.get(id)

    # The description of the check
def detailed_description(id):
    return {
        'MISRA12_17.7': """\
<p><b>Rationale</b></p>
<p>It is possible to call a function without using the return value, which may
be an error. If the return value of a function is intended not to be used
explicitly, it should be cast to the void type. This has the effect of using the
value without violating Rule 2.2.</p>

<p><b>Example</b></p>

<pre><code language="C++">  uint16_t func ( uin t16_t para1 )
  {
    return para1;
  }

  uint16_t x;
  void discarded ( uint16_t para2 )
  {
    func ( para2 ); /* Non-compliant - value discarded */
    ( void ) func ( para2 ); /* Compliant */
    x = func ( para2 ); /* Compliant */
  }

</code></pre>

<p><b>See also</b></p>
<p>Dir 4.7, Rule 2.2</p>
""",
        'MISRA08_0-1-7': """\

<p><b>Rationale</b></p>
<p>In C++ it is possible to call a function without using the return value,
which may be an error. The return value of a function shall always be used.
Overloaded operators are excluded, as they should behave in the same way as
built-in operators.</p>
<p><b>Exception</b></p>
<p>The return value of a function may be discarded by use of a (void) cast.
</p>
<p><b>Example</b></p><pre><code language="C++">  uint16_t func ( uint16_t para1 )
  {
     return para1;
  }
  void discarded ( uint16_t para2 )
  {
     func ( para2 );         // value discarded Â– Non-compliant
     (void)func ( para2 );   // Compliant
  }</code></pre>""",
        'A0-1-2': """\
<p>The value returned by a function having a non-void return type that is not an
overloaded operator shall be used.</p>
<p><b>Rationale</b></p>
<p>A called function may provide essential information about its process status
and result through return statement. Calling a function without using the return
value should be a warning that incorrect assumptions about the process were
made.</p>
<p>Overloaded operators are excluded, as they should behave in the same way as built-in
operators.</p>
<p><b>Exception</b></p>
<p>The return value of a function call may be discarded by use of a
static_cast&lt;void&gt; cast, so intentions of a programmer are explicitly stated.</p>
<p><b>Example</b></p>
<pre><code language="C++">// $Id: A0-1-2.cpp 289436 2017-10-04 10:45:23Z michal.szczepankiewicz $
#include &lt;algorithm&gt;
#include &lt;cstdint&gt;
#include &lt;vector&gt;
std::uint8_t Fn1() noexcept
{
  return 0U;
}
void Fn2() noexcept
{
  std::uint8_t x = Fn1(); // Compliant
  Fn1(); // Non-compliant
  static_cast&lt;void&gt;(Fn1()); // Compliant by exception
}
void Fn3()
{
  std::vector&lt;std::int8_t&gt; v{0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5};
  std::unique(v.begin(), v.end()); // Non-compliant
  v.erase(std::unique(v.begin(), v.end()), v.end()); // Compliant
}
</code></pre>""",
        'CPP_F024': """\
<p>The value returned by a function having a non-void return type that is not an
overloaded operator shall be used.</p>
<p><b>Rationale</b></p>
<p>A called function may provide essential information about its process status
and result through return statement. Calling a function without using the return
value should be a warning that incorrect assumptions about the process were
made.</p>
<p>Overloaded operators are excluded, as they should behave in the same way as built-in
operators.</p>
<p><b>Exception</b></p>
<p>The return value of a function call may be discarded by use of a
static_cast&lt;void&gt; cast, so intentions of a programmer are explicitly stated.</p>
<p><b>Example</b></p>
<pre><code language="C++">// $Id: A0-1-2.cpp 289436 2017-10-04 10:45:23Z michal.szczepankiewicz $
#include &lt;algorithm&gt;
#include &lt;cstdint&gt;
#include &lt;vector&gt;
std::uint8_t Fn1() noexcept
{
  return 0U;
}
void Fn2() noexcept
{
  std::uint8_t x = Fn1(); // Compliant
  Fn1(); // Non-compliant
  static_cast&lt;void&gt;(Fn1()); // Compliant by exception
}
void Fn3()
{
  std::vector&lt;std::int8_t&gt; v{0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5};
  std::unique(v.begin(), v.end()); // Non-compliant
  v.erase(std::unique(v.begin(), v.end()), v.end()); // Compliant
}
</code></pre>""",
        'MISRA23_17.7': """\
<p><b>Rationale</b></p>
<p>It is possible to call a function without using the return value, which may
be an error. If the return value of a function is intended not to be used
explicitly, it should be cast to the void type. This has the effect of using the
value without violating Rule 2.2.</p>

<p><b>Example</b></p>

<pre><code language="C++">  uint16_t func ( uin t16_t para1 )
  {
    return para1;
  }

  uint16_t x;
  void discarded ( uint16_t para2 )
  {
    func ( para2 ); /* Non-compliant - value discarded */
    ( void ) func ( para2 ); /* Compliant */
    x = func ( para2 ); /* Compliant */
  }

</code></pre>

<p><b>See also</b></p>
<p>Dir 4.7, Rule 2.2</p>
""",
        'MISRA23_0.1.2': """\
<p><b>Amplification</b></p>
<p>This rule only applies when the function is called explicitly using function call syntax.</p>

<p><b>Rationale</b></p>
<p>It is possible to call a function without using the return value, which may be an error. If the return value
of a function is intended to be explicitly discarded, it should be cast to void to ensure that it is used.</p>
<p>Overloaded operators are excluded from this requirement, as they should behave in the same way as
built-in operators.</p>
<p>Note: this rule effectively requires all non-void functions to be treated as if they were declared
[[nodiscard]].</p>

<p><b>Example</b></p>
<pre><code language="C++">uint16_t func();
void discarded()
{
 func(); // Non-compliant - implicitly discarded
 ( void )func(); // Compliant - void cast is a use
 auto b = func(); // Compliant - used as initializer
}

void f1( std::string q )
{
 std::string s { q } ; // Rule does not apply - not function call syntax
 s = q; // Rule does not apply - not function call syntax
 s.operator=( q ); // Non-compliant
}

void f2( std::function< int() > & f )
{
 f(); // Non-compliant - using function call syntax
 auto a = []() { return 10; };
 a(); // Non-compliant - using function call syntax
}
</code></pre>

<p><b>See also</b></p>
<p>Rule 28.6.4</p>""",
}[id]

def test_entity(file):
    return True

def test_global():
    return False

def test_language(language):
    return language == 'C++'

def define_options(check):
    include_all_funcs = True if check.id() == 'MISRA23_0.1.2' else False
    include_lambdas = True if check.id() == 'MISRA23_0.1.2' else False

    check.option().checkbox('unresolved', 'Include functions not defined in project (unresolved)', True)
    check.option().checkbox('include_all_funcs', 'Include member and library functions', include_all_funcs)
    check.option().checkbox('include_lambdas', 'Include lambda functions', include_lambdas)


def check(check, file):
    lexer = None
    refs = []

    # Gather refs depending on option
    unresolved = check.option().lookup('unresolved')
    include_all_funcs = check.option().lookup('include_all_funcs')
    include_lambdas = check.option().lookup('include_lambdas')

    if include_all_funcs:
        refs = file.filerefs('Call ~inactive ~implicit', 'Function')
    elif unresolved:
        refs = file.filerefs('Call ~inactive ~implicit', 'Function ~member')
    else:
        refs = file.filerefs('Call ~inactive ~implicit', 'Function ~unresolved ~unknown ~member')

    # Get lambda functions assigned to objects
    if include_lambdas:
        for obj_ref in file.filerefs('Call', 'Object'):
            utype = obj_ref.ent().freetext("UnderlyingType")

            if utype and not (utype == "(lambda)"):
                continue

            ass_val = obj_ref.ent().ref("Assign Value")

            if ass_val and ass_val.ent().contents() and "return" in ass_val.ent().contents():
                refs.append(obj_ref)

    for ref in refs:

        # Skip if it returns nothing
        t = ref.ent().type()
        if not t or t == 'void':
            continue

        def_ref = ref.ent().ref("Definein")
        dec_ref = ref.ent().ref("Declarein")
        nodiscard = False

        if def_ref and def_ref.scope() and def_ref.scope().contents() and "[[nodiscard]]" in def_ref.scope().contents():
            continue
        elif dec_ref:
            lex = dec_ref.file().lexer().lexeme(dec_ref.line(), dec_ref.column())

            while lex.line_begin() == dec_ref.line():
                if (lex.text() == "nodiscard") and (lex.token() == "Identifier"):
                    nodiscard = True
                    break

                lex = lex.previous(True, True)

        if nodiscard:
            continue

        if not lexer:
            if not file.lexer(lookup_ents=False):
                return
            lexer = file.lexer(lookup_ents=True)
        lexeme = lexer.lexeme(ref.line(), ref.column())
        if not lexeme:
            continue

        if lexeme.ent() and lexeme.ent().kind().check("Macro"):
            continue

        ok = False
        prevLex = lexeme.previous(True, True)
        nextLex = lexeme.next(True, True)
        if 'operator' in ref.ent().name() and not ref.ent().name() == 'operator()' and lexeme.text() != 'operator':
            ok = True
        if prevLex and re.search(r'\+|\-|\*|\/|\%|\[', prevLex.text()):
            ok = True
        if nextLex and re.search(r'\+|\-|\*|\/|\%|\]', nextLex.text()):
            ok = True
        while not ok and prevLex and not re.search(r';|{|}', prevLex.text()):
            if prevLex.text() == ')':
                prevLex = Modules.findOpen(prevLex)
            elif prevLex.text() == '(':
                prevLex = prevLex.previous(True, True)
                if prevLex and prevLex.ent() and re.search(r'function', prevLex.ent().kind().longname()):
                    ok = True
                    break
                else:
                    continue

            prevLex = prevLex.previous(True, True)
        # Look for any for, while, if, switch statements
        while not ok and lexeme and not re.search(r';|{|}', lexeme.text()):
            if lexeme.text() == ')':
                tempLex = Modules.findOpen(lexeme)
                if tempLex:
                    tempLex = tempLex.previous(True, True)
                    if tempLex and re.match(r'for|while|if|switch', tempLex.text()):
                        ok = True
                        break
            # Look for any for, while, if, switch statements or casts to void
            elif re.match(r'(void|for|while|if|switch|return)$', lexeme.text()) or re.search(r'=', lexeme.text()) or lexeme.token() == 'Preprocessor':
                ok = True
                break


            if lexeme:
                lexeme = lexeme.previous(True, True)

        if lexeme and not ok:
            check.violation(ref.ent(), file, ref.line(), ref.column(), ERR1)
