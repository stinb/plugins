# This script is designed to run with Understand - CodeCheck
# Written by Kyle Jackson
# 10-15-14


# Boiler Plate code
use base ("Understand::Codecheck");
use strict;


# This is the error that will be returned when a violation is found
use constant ERR1 => "Non unique internal identifier %1 conflicts with entity %2 in file %3 on line %4";


# This registers ERR1 with Understand
sub register_tr_text {
  my $check = shift;
  $check->add_tr_text(ERR1);
}

sub checkID { return "MISRA12_5.9";}


# This is the short error the Understand will use
sub name { return "Published Standards\\MISRA C 2012\\5.9 Identifiers that define objects or functions with internal linkage should be unique";}


sub tags {
  return (
    'Language: C',
    'Category: Advisory',
    'Standard: MISRA C 2012',
    'Identifiers',
  );
}

# This is the full description of the rule being tested
sub description {
  return "5.9 (Global)( Advisory ) Identifiers that define objects or functions with internal linkage should be unique.";
}


# This section returns the rational and examples to be given to the user through Understand
sub detailed_description {
  return  <<"END_DESC"

<p><b>Amplification</b></p>
The identifier name should be unique across all name spaces and translation units. Any identifier
used in this way should not have the same name as any other identifier, even if that other identifier
denotes an object with no linkage.
</p>

<p><b>Rationale</b></p>
Enforcing uniqueness of identifier names in this manner helps avoid confusion.
</p>

<p><b>Exception</b></p>
An inline function with internal linkage may be defined in more than one translation unit provided that
all such definitions are made in the same header file that is included in each translation unit.
</p>

<p><b>Example</b></p>
In the following example, file1.c and file2.c are both part of the same project.
</p>

<pre><code language="C++">  /* file1.c */

  static int32_t count;         /* "count" has internal linkage */

  static void foo ( void )      /* "foo" has internal linkage */
  {
    int16_t count;              /* Non-compliant - "count" has no linkage
                                 * but clashes with an identifier with
                                 * internal linkage */
    int16_t index;              /* "index" has no linkage */
  }

  void bar1 ( void )
  {
    static int16_t count;       /* Non-compliant - "count" has no linkage
                                 * but clashes with an identifier with
                                 * internal linkage */
    int16_t index;              /* Compliant - "index" is not unique but
                                 * has no linkage */
    foo ( );
  }

  /* End of file1.c */

---------------------------------------------------------------------

/* file2.c */

  static int8_t count;          /* Non-compliant - "count" has internal
                                 * linkage but clashes with other
                                 * identifiers of the same name */
  static void foo ( void )      /* Non-compliant - "foo" has internal
                                 * linkage but clashes with a function of
                                 * the same name */
  {
    int32_t index;              /* Compliant - both "index" and "nbytes" */
    int16_t nbytes;             /* are not unique but have no linkage */
  }

  void bar2 ( void )
  {
    static uint8_t nbytes;      /* Compliant - "nbytes" is not unique but
                                 * has no linkage and the storage class is
                                 * irrelevant */
  }

/* End of file2.c */

</code></pre>

<p><b>See also</b><br>
Rule 8.10
</p>

END_DESC
}


# This section defines the programming language this script is testing
sub test_language {
  my $language = shift;
  return $language eq "C++";
}


# This determines if this script is per file
sub test_entity {
  return 0;
}


# This determines if this script is per project or per file
sub test_global {
  return 1;
}


# Any defined options go here
sub define_options{
}


# This is the actual test being performed on the user's code
sub check {

  # Pull the check from understand, retrieve our global entities from the database and check our options
  my $check = shift;
  my @internalsDefined = $check->db->ents( 'Object Global, Function Static' );
  return unless @internalsDefined;

  # Start my hash for tracking patterns
  my %patternsSeen = ();

  foreach my $internal ( @internalsDefined ) {

    # If we are looking at an object, make sure it has internal linkage
    if ( $internal->kindname =~ /\bObject\b/ ) {
      next unless $internal->kindname =~ /\bStatic\b/ or $internal->type =~ /\bconst\b/;
    }

    # Pull a define reference
    my $define = $internal->ref ( 'Definein, Declarein' );
    next unless $define;

    $patternsSeen{ $define->scope->name } = $define;

  }

  my @everythingElse = $check->db->ents;
  return unless @everythingElse;

  foreach my $else ( @everythingElse ) {

    # Pull references
    my @defineRefs = $else->refs ( 'Definein, Declarein' );
    next unless @defineRefs;

    # We need a define or a declare reference, don't care which one so we just take the first one
    my $define = @defineRefs[0];
    next unless $define;

    if ( exists $patternsSeen{ $define->scope->name } ) {

      my $seenName = $patternsSeen{ $define->scope->name };

      # Check to make sure we are not looking at the same entity
      next if $define->scope->uniquename eq $seenName->scope->uniquename;
      next if $else->freetext("DefinedInMacro");

      # We've seen this name before, throw error
      $check->violation( $else, $define->file, $define->line, $define->column,
                         ERR1, $else->name, $seenName->scope->name, $seenName->file->name, $seenName->line );

    }

  }


}
