# This script is designed to run with Understand - CodeCheck
# Written by Jason Quinn
# 09-03-2025

import re
import Modules

ERR1 = "For loop is not well-formed"

# The ID for the check
def ids():
    return ('MISRA23_14.2', 'MISRA12_14.2', 'CPP_CF008')

# The short name of the check
def name(id):
    return {
        'MISRA23_14.2': 'Published Standards/MISRA C 2023/' + """\
14.2 A for loop shall be well-formed""",
        'MISRA12_14.2': 'Published Standards/MISRA C 2012/' + """\
14.2 A for loop shall be well-formed""",
        'CPP_CF008': 'All Checks/Language Specific/C and C++/Control Flow/' + """\
A for loop shall be well-formed""",
    }[id]




def tags(id):
    return {
        'MISRA23_14.2': [
            'Language: C',
            'Language: C++',
            'Standard: MISRA C 2023',
            'Category: Required',
            'Control Flow',
        ],
        'MISRA12_14.2': [
            'Language: C',
            'Language: C++',
            'Standard: MISRA C 2012',
            'Category: Required',
            'Control Flow',
        ],
        'CPP_CF008': [
            'Language: C',
            'Language: C++',
            'Control Flow',
        ],
    }.get(id)

# The long description of the check
def detailed_description(id):
    desc = """\
<p><b>Amplification</b></p>
<p>The three clauses of a for statement are the:</p>
<p>First clause which</p>
<ul>
<li>Shall be empty, or</li>
<li>Shall be an expression whose only persistent side effect is to set the value
of the loop counter, or</li>
<li>Shall define and initialize the loop counter (C99 and later).</li>
</ul>
<p>Second clause which</p>
<li>Shall be an expression that has no persistent side effects, and</li>
<li>Shall use the loop counter and optionally loop control flags, and</li>
<li>Shall not use any other object that is modified in the for loop body.</li>
</ul>
<p>Third clause which</p>
<li>Shall be an expression whose only persistent side effect is to modify the
value of the loop counter, and</li>
<li>Shall not use objects that are modified in the for loop body.</li>
</ul>
<p>There shall only be one loop counter in a for loop, which shall not be
modified in the for loop body.</p>
<p>A loop control flag is defined as a single identifier denoting an object with
essentially Boolean type that is used in the second clause.</p>
<p>The behaviour of a for loop body includes the behaviour of any functions
called within that statement.</p>
<p><b>Rationale</b></p>
<p>The for statement provides a general-purpose looping facility. Using a
restricted form of loop makes code easier to review and to analyse.</p>
<p><b>Exception</b></p>
<p>All three clauses may be empty, for example for ( ; ; ), so as to allow for
infinite loops.</p>
<p><b>Example</b></p>
<p>In the following example, i is the loop counter and flag is a loop control
flag</p>
<pre><code language="C++">bool_t flag = false;
for ( int16_t i = 0; ( i < 5 ) && !flag; i++ )
{
if ( C )
{
flag = true; /* Compliant - allows early termination
* of loop */
}
i = i + 3; /* Non-compliant - altering the loop
* counter */
}</code></pre>
<p><b>See Also</b></p>
<p>Rule 14.1, Rule 14.3, Rule 14.4</p>
"""
    return {
        'MISRA23_14.2': desc,
        'MISRA12_14.2': desc,
        'CPP_CF008': desc,

    }[id]

def test_entity(file):
    return file.kind().check('code file, header file')

def test_language(language):
    return language == 'C++'


def check(check, file):
    if not file.lexer():
        return

    lexer = file.lexer()

    lexeme = lexer.first()
    while lexeme:
        # Find 'for' loops
        if lexeme.text() == 'for':
            vLex = lexeme
            lexeme = lexeme.next(True, True)
            openBrace = None
            closeBrace = None
            # Find the three clauses of for loop
            if lexeme and lexeme.text() == '(':
                # Skip for exception
                tempLex = lexeme.next(True, True)
                if tempLex and tempLex.text() == ';':
                    tempLex = tempLex.next(True, True)
                    if tempLex and tempLex.text() == ';':
                        tempLex = tempLex.next(True, True)
                        if tempLex and tempLex.text() == ')':
                            lexeme = tempLex
                            continue
                close = Modules.findClose(lexeme)
                if close:
                    # Find the opening and closing curly braces
                    openBrace = close.next(True, True)
                    if openBrace and openBrace.text() == '{':
                        closeBrace = Modules.findClose(openBrace)
                count = 0
                ok = True
                equals = False
                loopCounter = None
                loopCounterFound = False
                # Go through clauses
                while ok and lexeme and close and checkBounds(lexeme.line_begin(), lexeme.column_begin(), close):
                    # Check if loopCounter in 2nd and 3rd clause
                    if loopCounter and count > 0 and lexeme.ent():
                        if lexeme.ent().id() == loopCounter.id():
                            loopCounterFound = True
                    if lexeme.text() == ',':
                        ok = False
                    # Check side effects
                    elif lexeme.ent() and lexeme.ent().kind().check("Function"):
                        ok = False
                    # Keep track of which clause
                    elif lexeme.text() == ';':
                        # Checks for violations where the loop counter wasn't found in the 2nd or 3rd clause
                        if count > 0 and loopCounter and not loopCounterFound:
                            ok = False
                        count += 1
                        loopCounterFound = False
                        lexeme = lexeme.next(True, True)
                        if lexeme and (lexeme.text() == ';') or (count == 2 and not checkBounds(lexeme.line_begin(), lexeme.column_begin(), close)):
                            ok = False
                        continue
                    # Check for violations in the 2nd and 3rd clauses
                    elif count > 0 and loopCounter and lexeme.ent() and lexeme.ent().name() != loopCounter.name():
                        if openBrace and closeBrace:
                            refs = lexeme.ent().refs('Modifyby, Assignby, Setby')
                            for ref in refs:
                                if ref.file().longname() == file.longname() and checkBounds(ref.line(), ref.column(), closeBrace, vLex):
                                    ok = False
                    
                    # Check for set violations in the first 2 clauses
                    elif lexeme.text() == '=' and count < 2:
                        if equals:
                            ok = False
                        equals = True
                    elif lexeme.ref() and count < 2:
                        refs = lexeme.ent().refs('Modifyby, Assignby, Setby')
                        for ref in refs:
                            if ref.line() == lexeme.line_begin() and ref.column() == lexeme.column_begin():
                                ok = False
                    # Check for violations in first clause
                    if count == 0:
                        if lexeme.ent() and not loopCounter:
                            # Skip type names, look for the actual variable
                            if not lexeme.ent().kind().check("Type"):
                                loopCounter = lexeme.ent()
                                if openBrace and closeBrace:
                                    refs = lexeme.ent().refs('Modifyby, Assignby, Setby')
                                    for ref in refs:
                                        if ref.file().longname() == file.longname() and checkBounds(ref.line(), ref.column(), closeBrace, vLex):
                                            if checkBounds(ref.line(), ref.column(), openBrace):
                                                tempLex = lexer.lexeme(ref.line(), ref.column())
                                                clauseCount = 0
                                                while tempLex and checkBounds(vLex.line_begin(), vLex.column_begin(), tempLex):
                                                    if tempLex.text() == ';':
                                                        clauseCount += 1
                                                    elif tempLex.text() == ')':
                                                        tempLex = Modules.findOpen(tempLex)
                                                        continue
                                                    tempLex = tempLex.previous(True, True)

                                                if (clauseCount > 1 and str(ref.kind()) == 'Modify') or (clauseCount < 1 and str(ref.kind()) == 'Set'):
                                                    ok = True
                                                    continue

                                            ok = False
                            


                    lexeme = lexeme.next(True, True)




                if not ok:
                    check.violation(file, file, vLex.line_begin(), vLex.column_begin(), ERR1)
        else:
            lexeme = lexeme.next(True, True)



# Returns true if still before the given closing parenthesis
# and after the begin if given
def checkBounds(line, column, close, begin=None):
    if not close:
        return False
    if line > close.line_begin():
        return False
    if line == close.line_begin() and column >= close.column_begin():
        return False
    if begin:
        if line < begin.line_begin():
            return False
        if line == begin.line_begin() and column < begin.column_begin():
            return False
    return True

