ERR1 = "'errno' shall only be tested after an errno-setting-function"
ERRNO_SETT_FUNCS = ["ftell", "fgetpos", "fsetpos", "fgetwc", "fputwc",
                    "strtoimax", "strtoumax", "strtol", "strtoul",
                    "strtoll", "strtoull", "strtof", "strtod", "strtold",
                    "wcstoimax", "wcstoumax", "wcstol", "wcstoul",
                    "wcstoll", "wcstoull", "wcstof", "wcstod", "wcstold",
                    "wcrtomb", "wcsrtombs", "mbrtowc"]


# The ID for the check
def ids():
    return ('MISRA23_22.10')


# The short name of the check
def name(id):
    return {
        'MISRA23_22.10': "Published Standards/MISRA C 2023/22.10 \
The value of errno shall only be tested when the last function to be called was an errno-setting-function"
    }[id]


# The short description of the check
def tags(id):
    return {
        'MISRA23_22.10': [
            'Language: C',
            'Language: C++',
            'Standard: MISRA C 2023',
            'Category: Required',
            'Libraries',
        ],
    }.get(id)


# The long description of the check
def detailed_description(id):
    return {
        'MISRA23_22.10': """
<p><b>Amplification</b></p>
<p>An errno-setting-function is one of those described in Rule 22.8.</p>

<p><b>Rationale</b></p>
<p>The errno-setting-functions are the only functions which are required to set errno when an error is
detected. Other functions, including those defined in the Standard Library that are not errno-setting-
functions, may or may not set errno to indicate that an error has occurred. The use of errno to
detect errors within these functions will fail for an implementation that does not set errno as it will
be left unmodified.</p>
<p>Given that a zero value for errno does not therefore guarantee the absence of an error within a
function that is not an errno-setting-function, its value shall not be tested as the outcome must be
considered unreliable.</p>

<p><b>Example</b></p>
<pre><code language="C++">void f ( void )
{
    float64_t f64;
    errno = 0;
    f64 = atof ( "A.12" );
    if ( 0 == errno ) /* Non-compliant */
    {
        /* f64 may not have a valid value in here. */
    }
    errno = 0;
    f64 = strtod ( "A.12", NULL );
    if ( 0 == errno ) /* Compliant */
    {
        /* f64 will have a valid value in here. */
    }
}</code></pre>

<p><b>See also</b></p>
<p>Rule 22.8, Rule 22.9</p>

<p><b>Developer's Note:</b></p>
<p>This check only considers the functions listed in Rule 22.8 as errno-setting-functions.</p>
""",
    }[id]


# Tests the type of file
def test_entity(file):
    return file.kind().check('code file, header file')


def test_global():
    return False


def test_language(language):
    return language == 'C++'


def check(check, file):
    lexer = file.lexer(lookup_ents=False)

    for func_ref in file.filerefs("Define", "Function"):
        errno_set = False

        for ref in sorted(func_ref.ent().refs("Use, Call", "Macro, Function"), key=lambda r: r.line()):
            if ref.ent().name() in ERRNO_SETT_FUNCS:
                errno_set = True
            elif ref.ent().name() == "errno":
                lex = lexer.lexeme(ref.line(), ref.column())

                if lex and ((lex.text() != "errno")
                            or ((lex.next(True, True).text() != "==")
                            and (lex.previous(True, True).text() != "=="))):
                    continue

                if not errno_set:
                    check.violation(ref.ent(), file, ref.line(),
                                    ref.column(), ERR1)

                errno_set = False
