ERR1 = "An object with temporary lifetime shall not undergo array-to-pointer conversion"


# The ID for the check
def ids():
    return ('MISRA23_18.9')


# The short name of the check
def name(id):
    return {
        'MISRA23_18.9': "Published Standards/MISRA C 2023/18.9 An object with temporary lifetime shall not undergo array-to-pointer conversion"
    }[id]


# The short description of the check
def tags(id):
    return {
        'MISRA23_18.9': [
            'Language: C',
            'Language: C++',
            'Standard: MISRA C 2023',
            'Category: Required',
            'Pointers',
        ],
    }.get(id)


# The long description of the check
def detailed_description(id):
    return {
        'MISRA23_18.9': """
<p><b>Amplification</b></p>
<p>Temporary lifetime is a storage duration which describes the lifetime of the elements of non-lvalue
arrays.</p>
<p>An array which is a member of a non-lvalue expression with structure or union type shall not be used
as a value, other than as the immediate postfix-expression operand to a subscript operator.</p>
<p>The subscript operator shall not be used to produce a modifiable lvalue.</p>

<p><b>Rationale</b></p>
<p>An array object can be a member of a structure or union, and therefore form part of the result value
of any value expression. Because arrays used in an expression are always value-converted to a
pointer to their elements, it is possible to form a pointer to such array sub-objects even when they
are not part of a declared object with normal lifetime.</p>
<p>Modifying elements of such an array implicitly results in undefined behaviour in C90, and explicitly
results in undefined behaviour in C99 and later. Accessing the elements of such an array after the
end of its lifetime results in undefined behaviour, which is implicitly limited to the next sequence
point in C90 and C99 (meaning the pointer cannot be stored or passed to any function), and to the
duration of the complete containing expression in C11 and later.</p>
<p>The pointer will not be to const-qualified elements unless the array element type is const-qualified;
therefore the array's type may appear to allow modification, and the generation of apparently
modifiable element lvalues, even though the array itself has temporary lifetime.</p>
<p>Since the containing object can always be assigned to a named intermediate object by value, there is
little reason to ever attempt to take the address of the value with temporary lifetime.</p>

<p><b>Example</b></p>
<pre><code language="C++">/* Value object containing an array as an element */

struct S1 {
int32_t array[10];
};

struct S1 s1;
struct S1 getS1 (void);

void foo(int32_t const * p);

/* Compliant - not temporary storage duration */

int32_t * p = s1.array;
s1.array[0] = 1;
foo( s1.array );

/* Non-compliant - temporary storage duration */

p = getS1().array; /* also creates dangling pointer */
foo( getS1().array );
foo( (s1 = s1).array ); /* other forms of non-lvalue expression */

/* Compliant - immediate element access is always safe */

int32_t j = getS1().array[3]; /* element copied: const access */
j = (s1 = s1).array[3];

/* Non-compliant - element used as a modifiable lvalue */

getS1().array[3] = j;
(1 ? s1 : s1).array[3] = j;</code></pre>
""",
    }[id]


# Tests the type of file
def test_entity(file):
    return file.kind().check('code file, header file')


def test_global():
    return False


def test_language(language):
    return language == 'C++'


def check(check, file):
    for struct_ref in file.filerefs("Define", "Struct, Union"):
        arr_mems = {}

        for mem_ref in struct_ref.ent().refs("Define, Declare", "Member", True):
            utype = str(mem_ref.ent().freetext("UnderlyingType"))

            if utype and utype.endswith("]") and mem_ref.ent().id() not in arr_mems:
                arr_mems[mem_ref.ent().id()] = mem_ref.ent()

        if not arr_mems:
            continue

        for mem_ent in arr_mems.values():
            ass_refs = mem_ent.refs("Assignby Value")

            for ref in mem_ent.refs("Useby, Setby ~Init"):
                compliant = False

                for ass_ref in ass_refs:
                    if (ass_ref.line() == ref.line()) and (ass_ref.column() == ref.column()):
                        compliant = True
                        break

                if compliant:
                    continue

                lex = ref.file().lexer().lexeme(ref.line(), ref.column())
                prev_lex = lex.previous()

                if prev_lex and ((prev_lex.text() != ".") or prev_lex.previous().text() in "]" or (prev_lex.previous() and prev_lex.previous().ent())):
                    continue

                check.violation(mem_ent, ref.file(), ref.line(), ref.column(), ERR1)