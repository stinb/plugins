# This script is designed to run with Understand - CodeCheck
# Written by Jason Quinn
# 8/6/25


ERR1 = 'Pointer was not declared as pointing to a const-qualified'


# The ID for the check
def ids():
    return ('MISRA23_8.13', 'MISRA12_8.13', 'CPP_DD028')

# The short name of the check
def name(id):
    return {
        'MISRA23_8.13': 'Published Standards/MISRA C 2023/' + """\
8.13 A pointer should point to a const-qualified type whenever possible""",
        'MISRA12_8.13': 'Published Standards/MISRA C 2012/' + """\
8.13 A pointer should point to a const-qualified type whenever possible""",
        'CPP_DD028': 'All Checks/Language Specific/C and C++/Declarations and Definitions/' + """\
A pointer should point to a const-qualified type whenever possible""",
    }[id]




def tags(id):
    return {
        'MISRA23_8.13': [
            'Language: C',
            'Language: C++',
            'Standard: MISRA C 2023',
            'Category: Advisory',
            'Declarations and Definitions',
        ],
        'MISRA12_8.13': [
            'Language: C',
            'Language: C++',
            'Standard: MISRA C 2012',
            'Category: Advisory',
            'Declarations and Definitions',
        ],
        'CPP_DD028': [
            'Language: C',
            'Language: C++',
            'Declarations and Definitions',
        ],
    }.get(id)


# The long description of the check
def detailed_description(id):
    desc = """\
<p><b>Amplification</b></p>
<p>A pointer should point to a const-qualified type unless either:</p>
<ul>
<li>It is used to modify an object, or</li>
<li>It is copied to another pointer that points to a type that is not
const-qualified by means of either:
<ul><li>Assignment, or</li>
<li>Memory move or copying functions.</li></ul>
</li>
</ul>
<p>For the purposes of simplicity, this rule is written in terms of pointers and
the types that they point to. However, it applies equally to arrays and the
types of the elements that they contain. An array should have elements with
const-qualified type unless either:</p
<ul>
<li>Any element of the array is modified, or</li>
<li>It is copied to a pointer that points to a type that is not const-qualified
by the means described above.</li>
</ul>
<p><b>Rationale</b></p>
<p>This rule encourages best practice by ensuring that pointers are not
inadvertently used to modify objects. Conceptually, it is equivalent to
initially declaring:</p>
<ul>
<li>All arrays to have elements with const-qualified type, and</li>
<li>All pointers to point to const-qualified types.</li>
</ul>
<p>and then removing const-qualification only where it is necessary to comply
with the constraints of the language standard</p>
<p><b>Example</b></p>
<p>In the following non-compliant example, p is not used to modify an object but
the type to which it points is not const-qualified.</p>
<pre><code language="C++">uint16_t f ( uint16_t *p )
{
return *p;
}</code></pre>
<p>The code would be compliant if the function were defined with:</p>
<pre><code language="C++">uint16_t g ( const uint16_t *p )</code></pre>
<p>The following example violates a constraint because an attempt is made to use
a const-qualified pointer to modify an object.</p>
<pre><code language="C++">void h ( const uint16_t *p )
{
*p = 0;
}</code></pre>
<p>In the following example, the pointers is const-qualified but the type it
points to is not. Since s is not used to modify an object, this is
non-compliant.</p>
<pre><code language="C++">#include <string.h>
char last_char ( char * const s )
{
return s[ strlen ( s ) - 1u ];
}</code></pre>
<p>The code would be compliant if the function were defined with:</p>
<pre><code language="C++">char last_char ( const char * const s )</code></pre>
<p>In this non-compliant example, none of the elements of the array a are
modified but the element type is not const-qualified.</p>
<pre><code language="C++">uint16_t first ( uint16_t a[ 5 ] )
{
return a[ 0 ];
}</code></pre>
<p>The code would be compliant if the function were defined with:</p>
<pre><code language="C++">uint16_t first ( const uint16_t a[ 5 ] )</code></pre>
"""
    return {
        'MISRA23_8.13': desc,
        'MISRA12_8.13': desc,
        'CPP_DD028': desc,

    }[id]

# Tests the type of file
def test_entity(file):
    return file.kind().check('file')

def test_global():
    return False

def test_language(language):
    return language == 'C++'

def check(check, file):
    refs = file.filerefs('Define', 'Object, Parameter')
    for ref in refs:
        # Skip if not pointer
        if '*' not in str(ref.ent().type()):
            continue
        # Skip if const
        if 'const' in str(ref.ent().type()):
            continue
        # Skip if modified or set
        if ref.ent().ref('Modifyby, Set ~Init'):
            continue
        # Skip if argv from main
        if ref.ent().kindname().lower() == 'parameter' and ref.ent().name() == 'argv' and ref.ent().parent().name() == 'main':
            continue
        check.violation(ref.ent(), file, ref.line(), ref.column(), ERR1)
