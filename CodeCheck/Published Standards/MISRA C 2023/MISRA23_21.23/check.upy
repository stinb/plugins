import re


ERR1 = "All operand arguments to %1 shall have the same standard type"

TGMATH_FUNCS = [
            "atan2",
            "copysign",
            "fdim",
            "fma",
            "fmax",
            "fmin",
            "fmod",
            # "frexp", only first param is operand
            "hypot",
            # "ldexp", only first param is operand
            "nextafter",
            # "nexttoward", should have different types
            "pow",
            "remainder",
            "remquo",
            # "scalbn", only first param is operand
            # "scalbln" only first param is operand
        ]

INT_TYPES = [
    "signed char",
    "unsigned char",
    "char",
    "short",
    "unsigned short",
    "_Bool",
    "bool"
]


# The ID for the check
def ids():
    return ('MISRA23_21.23')


# The short name of the check
def name(id):
    return {
        'MISRA23_21.23': "Published Standards/MISRA C 2023/21.23 All operand \
arguments to any multi-argument type-generic macros declared in <tgmath.h> \
shall have the same standard type"
    }[id]


# The short description of the check
def tags(id):
    return {
        'MISRA23_21.23': [
            'Language: C',
            'Language: C++',
            'Standard: MISRA C 2023',
            'Category: Required',
            'Libraries',
        ],
    }.get(id)


# The long description of the check
def detailed_description(id):
    return {
        'MISRA23_21.23': """
<p><b>Amplification</b></p>
<p>This rule applies to the following multi-argument type-generic macros:</p>
<p>atan2, copysign, fdim, fma, fmax, fmin, fmod, frexp, hypot, ldexp, nextafter, nexttoward, pow, remainder,
remquo, scalbn, scalbln</p>
<p>All operand arguments passed to any of the multi-argument macros defined in &lt;tgmath.h&gt; shall
have the same standard type, after integer promotion has been applied to any integer arguments.</p>
<p>Note: The final parameter to the frexp and remquo macros is for output, and is not considered an
operand.</p>

<p><b>Rationale</b></p>
<p>Ensuring that the types used to determine the corresponding real type for the whole call expression
are consistent makes the relationship between the input values and the result clearer.</p>
<p>On platforms with extended real types, the essentially real floating types may not be able to be strictly
ordered by precision. In this case there is a risk that if two arguments have different types, the
deduced common real type may be an unexpected size or silently lose precision.</p>

<p><b>Example</b></p>
<pre><code language="C++">void f (void) {
    float32_t f1;
    float32_t f2;
    float64_t d1;
    float64_t d2;

    f2 = pow(f1, f2); /* Compliant */
    d2 = pow(d1, d2); /* Compliant */

    f2 = pow(f1, d2); /* Non-compliant - unclear which argument was
    intended to control precision */

    f2 = pow(f1, (float32_t)d2); /* Compliant */
}

void g (void) {
    short s16;
    int i32;
    long l32;

    i32 = pow( s16, i32 ); /* Compliant - both arguments are int after
    integer promotion */

    i32 - pow( i32, l32 ); /* Non-compliant - arguments are not the same
    type after promotion */

    i32 = pow( s16, 10 ); /* Compliant - 10 has literal type int */
    i32 = pow( 10u, 110ul ); /* Non-compliant - literal types unsigned int
    and unsigned long */
}</code></pre>

<p><b>See also</b></p>
<p>Rule 21.11, Rule 21.22</p>
""",
    }[id]


# Tests the type of file
def test_entity(file):
    return file.kind().check('code file, header file')


def test_global():
    return False


def test_language(language):
    return language == 'C++'


def strip_qualifiers(type):
    new_type = re.sub("const", "", type)
    new_type = re.sub("volatile", "", new_type)
    new_type = re.sub("_Atomic", "", new_type)
    new_type = new_type.strip(" ")
    new_type = new_type.strip("()")    

    return new_type


def get_type(literal):
    literal = literal.lower()

    if re.search(r'ull$', literal) or re.search(r'llu$', literal):
        return "unsigned long long"
    elif re.search(r'll$', literal):
        return "long long"
    elif re.search(r'ul$', literal) or re.search(r'lu$', literal):
        return "unsigned long"
    elif re.search(r'l$', literal):
        return "long"
    elif re.search(r'u$', literal):
        return "unsigned int"
    else:
        return "int"
    

def add_param(ent, param_types):
    utype = str(ent.freetext("UnderlyingType"))
    utype = strip_qualifiers(utype)

    if utype in INT_TYPES:
        utype = "int"

    param_types.append(utype)    


def check(check, file):
    for func_ref in file.filerefs("Call", "Function"):
        if func_ref.ent().name() in TGMATH_FUNCS:
            lex = file.lexer().lexeme(func_ref.line(), func_ref.column())

            if lex and (lex.text() != func_ref.ent().name()):
                continue

            on_param = 0
            param_types = []

            # macro call
            if (lex.next().text() == ")") and (lex.next().next().text() == "("):
                lex = lex.next().next()

            while lex:
                if lex.text() in "([":
                    on_param += 1
                elif lex.text() in ")]":
                    on_param -= 1

                    if not on_param:
                        break
                elif (on_param == 1) and lex.token() == "Literal":
                    if str(lex.text()).isdigit():
                        param_types.append("int")
                    else:
                        param_types.append(get_type(lex.text()))

                elif (on_param == 1) and lex.ent() and lex.next().text() not in ["->", "."]:
                    if lex.next().text() in "([":
                        in_lex = lex

                        while in_lex and in_lex.text() not in ")]":
                            in_lex = in_lex.next()

                        if in_lex.next().text() in ["->", "."]:
                            lex = lex.next()
                            continue

                    lex_ent = lex.ent()

                    if lex.previous().text() == ")":
                        prev = lex.previous().previous()
                        
                        if prev and prev.ent() and prev.ent().kind().check("Type"):
                            lex_ent = prev.ent()
                    
                    add_param(lex_ent, param_types)

                # only first two params is operand
                if (len(param_types) == 2) and func_ref.ent().name() in ["remquo"]:
                    break                                                               

                lex = lex.next(True, True)
            
            if (len(param_types) > 1) and (len(set(param_types)) > 1):
                check.violation(func_ref.ent(), file, func_ref.line(), 
                                func_ref.column(), ERR1, func_ref.ent().name())