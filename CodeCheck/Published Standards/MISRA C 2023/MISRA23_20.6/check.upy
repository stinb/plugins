ERR1 = "Preprocessing directive shall not occur within a macro argument"


# The ID for the check
def ids():
    return ('MISRA23_20.6', 'MISRA12_20.6', 'MISRA08_16-0-5', 'MISRA04_19.9', 'CPP_P005')


# The short name of the check
def name(id):
    return {
        'MISRA23_20.6': "Published Standards/MISRA C 2023/20.6 Tokens that look like a preprocessing directive shall not occur within a macro argument",
        'MISRA12_20.6': "Published Standards/MISRA C 2012/20.6 Tokens that look like a preprocessing directive shall not occur within a macro argument",
        'MISRA08_16-0-5': "Published Standards/MISRA-C++ 2008/16-0-5 Arguments to a function-like macro shall not contain tokens that look like preprocessing directives",
        'MISRA04_19.9': "Published Standards/MISRA-C 2004/19.9 Arguments to a function-like macro shall not contain tokens that look like preprocessing directives",
        'CPP_P005': "All Checks/Language Specific/C and C++/Preprocessor/Arguments to a function-like macro shall not contain tokens that look like preprocessing directives"
    }[id]


# The short description of the check
def tags(id):
    return {
        'MISRA23_20.6': [
            'Language: C',
            'Language: C++',
            'Standard: MISRA C 2023',
            'Category: Required',
            'Preprocessor',
        ],
        'MISRA12_20.6': [
            'Language: C',
            'Language: C++',
            'Standard: MISRA C 2012',
            'Category: Required',
            'Preprocessor',
        ],
        'MISRA08_16-0-5': [
            'Language: C',
            'Language: C++',
            'Standard: MISRA C++ 2008',
            'Category: Required',
            'Preprocessor',
        ],
        'MISRA04_19.9': [
            'Language: C',
            'Language: C++',
            'Standard: MISRA  2004',
            'Category: Required',
            'Preprocessor',
        ],
        'CPP_P005': [
            'Language: C',
            'Language: C++',
            'Preprocessor',
        ]
    }.get(id)


# The long description of the check
def detailed_description(id):
    return {
        'MISRA23_20.6': """
<p><b>Rationale</b></p>
<p>An argument containing sequences of tokens that would otherwise act as preprocessing directives
leads to undefined behaviour.</p>

<p><b>Example</b></p>
<pre><code language="C++">#define M( A ) printf ( #A )

#include <stdio.h>

void main ( void )
{
M (
#ifdef SW /* Non-compliant */
"Message 1"
#else /* Non-compliant */
"Message 2"
#endif /* Non-compliant */
);}</code></pre>
<p>The above may print</p>
<pre><code language="C++">#ifdef SW "Message 1" #else "Message 2" #endif</code></pre>
<p>or</p>
<pre><code language="C++">"Message 2"</code></pre>
<p>or exhibit some other behaviour.</p>
""",
        'MISRA12_20.6': """
<p><b>Rationale</b></p>
<p>An argument containing sequences of tokens that would otherwise act as preprocessing directives
leads to undefined behaviour.</p>

<p><b>Example</b></p>
<pre><code language="C++">#define M( A ) printf ( #A )

#include <stdio.h>

void main ( void )
{
M (
#ifdef SW /* Non-compliant */
"Message 1"
#else /* Non-compliant */
"Message 2"
#endif /* Non-compliant */
);}</code></pre>
<p>The above may print</p>
<pre><code language="C++">#ifdef SW "Message 1" #else "Message 2" #endif</code></pre>
<p>or</p>
<pre><code language="C++">"Message 2"</code></pre>
<p>or exhibit some other behaviour.</p>
""",
        'MISRA08_16-0-5': """
<p><b>Rationale</b></p>
<p>An argument containing sequences of tokens that would otherwise act as preprocessing directives
leads to undefined behaviour.</p>

<p><b>Example</b></p>
<pre><code language="C++">#define M( A ) printf ( #A )

#include <stdio.h>

void main ( void )
{
M (
#ifdef SW /* Non-compliant */
"Message 1"
#else /* Non-compliant */
"Message 2"
#endif /* Non-compliant */
);}</code></pre>
<p>The above may print</p>
<pre><code language="C++">#ifdef SW "Message 1" #else "Message 2" #endif</code></pre>
<p>or</p>
<pre><code language="C++">"Message 2"</code></pre>
<p>or exhibit some other behaviour.</p>
""",
        'MISRA04_19.9': """
<p><b>Rationale</b></p>
<p>An argument containing sequences of tokens that would otherwise act as preprocessing directives
leads to undefined behaviour.</p>

<p><b>Example</b></p>
<pre><code language="C++">#define M( A ) printf ( #A )

#include <stdio.h>

void main ( void )
{
M (
#ifdef SW /* Non-compliant */
"Message 1"
#else /* Non-compliant */
"Message 2"
#endif /* Non-compliant */
);}</code></pre>
<p>The above may print</p>
<pre><code language="C++">#ifdef SW "Message 1" #else "Message 2" #endif</code></pre>
<p>or</p>
<pre><code language="C++">"Message 2"</code></pre>
<p>or exhibit some other behaviour.</p>
""",
        'CPP_P005': """
<p><b>Rationale</b></p>
<p>An argument containing sequences of tokens that would otherwise act as preprocessing directives
leads to undefined behaviour.</p>

<p><b>Example</b></p>
<pre><code language="C++">#define M( A ) printf ( #A )

#include <stdio.h>

void main ( void )
{
M (
#ifdef SW /* Non-compliant */
"Message 1"
#else /* Non-compliant */
"Message 2"
#endif /* Non-compliant */
);}</code></pre>
<p>The above may print</p>
<pre><code language="C++">#ifdef SW "Message 1" #else "Message 2" #endif</code></pre>
<p>or</p>
<pre><code language="C++">"Message 2"</code></pre>
<p>or exhibit some other behaviour.</p>
""",
    }[id]


# Tests the type of file
def test_entity(file):
    return file.kind().check('code file, header file')


def test_global():
    return False


def test_language(language):
    return language == 'C++'


def check(check, file):
    lexer = file.lexer(lookup_ents=False)

    for macro_ref in file.filerefs("Use", "Macro Functional"):
        lex = lexer.lexeme(macro_ref.line(), macro_ref.column())
        on_arg = 0

        if lex.next(True, True).text() != "(":
            continue

        while lex:
            if lex.text() == "(":
                on_arg += 1
            elif lex.text() == ")":
                on_arg -= 1

                if not on_arg:
                    break
            elif on_arg > 0 and (lex.text() == "#") and (lex.next().token() == "Preprocessor"):
                check.violation(macro_ref.ent(), file, lex.line_begin(), lex.column_begin(), ERR1)

            lex = lex.next(True, True)