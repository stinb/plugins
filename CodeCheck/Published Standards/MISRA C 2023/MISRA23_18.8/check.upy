# This script is designed to run with Understand - CodeCheck
# Written by Jason Quinn
# 10-13-2025

import re

ERR1 = "Variable-length array found"

# The ID for the check
def ids():
    return ('MISRA23_18.8', 'MISRA12_18.8', 'CPP_DD029')

# The short name of the check
def name(id):
    return {
        'MISRA23_18.8': 'Published Standards/MISRA C 2023/' + """\
18.8 Variable-length arrays shall not be used""",
        'MISRA12_18.8': 'Published Standards/MISRA C 2012/' + """\
18.8 Variable-length arrays shall not be used""",
        'CPP_DD029': """\
All Checks/Language Specific/C and C++/Definitions and Declarations/
Variable-length arrays shall not be used""",
    }[id]




def tags(id):
    return {
        'MISRA23_18.8': [
            'Language: C',
            'Language: C++',
            'Standard: MISRA C 2023',
            'Category: Required',
            'Declarations and Definitions',
        ],
        'MISRA12_18.8': [
            'Language: C',
            'Language: C++',
            'Standard: MISRA C 2012',
            'Category: Required',
            'Declarations and Definitions',
        ],
        'CPP_DD029': [
            'Language: C',
            'Language: C++',
            'Declarations and Definitions',
        ],
    }.get(id)

# The long description of the check
def detailed_description(id):
    desc = """\
<p><b>Rationale</b></p>
<p>Variable-length arrays are specified when the size of an array declared in a
block or a function prototype is not an integer constant expression. They are
typically implemented as a variable size object stored on the stack. Their use
can therefore make it impossible to determine statically the amount of memory
that must be reserved for a stack.</p>
<p>If the size of a variable-length array is negative or zero, the behaviour is
undefined.</p>
<p>If a variable-length array is used in a context in which its type is required
to be compatible with the type of another array, then the size of the array
types shall be identical. Further, all sizes shall evaluate to positive
integers. If these requirements are not met, the behaviour is undefined.</p>
<p>If a variable-length array is used in the operand of a sizeof operator, under
some circumstances it is unspecified whether the array size expression is
evaluated or not.</p>
<p>Each instance of a variable-length array type has its size fixed at the start
of its lifetime. This gives rise to behaviour that might be confusing, for
example:</p>
<pre><code language="C++">void f ( void )
{
uint16_t n = 5;
typedef uint16_t Vector[ n ]; /* An array type with 5 elements */
n = 7;
Vector a1; /* An array type with 5 elements */
uint16_t a2[ n ]; /* An array type with 7 elements */
}</code></pre>
<p><b>Example</b></p>
<p>There is no use of variable-length arrays that is compliant with this rule.
The examples show some of the undefined behaviour that can arise from their use.
</p>
<pre><code language="C++">void f ( int16_t n )
{
uint16_t vla[ n ]; /* Non-compliant - Undefined if n <= 0 */
}
void g ( void )
{
f ( 0 ); /* Undefined */
f ( -1 ); /* Undefined */
f ( 10 ); /* Defined */
}</code></pre>
<p><b>See also</b></p>
<p>Rule 13.6, Rule 18.10</p>
"""
    return {
        'MISRA23_18.8': desc,
        'MISRA12_18.8': desc,
        'CPP_DD029': desc,

    }[id]

def test_entity(file):
    return file.kind().check('code file, header file')

def test_language(language):
    return language == 'C++'


def check(check, file):
    refs = file.filerefs("Define", "Object, Typedef")
    for ref in refs:
        if not '[' in str(ref.ent().type()) or re.search(r'\[\d*\]', str(ref.ent().type())):
            continue

        check.violation(ref.ent(), file, ref.line(), ref.column(), ERR1)


