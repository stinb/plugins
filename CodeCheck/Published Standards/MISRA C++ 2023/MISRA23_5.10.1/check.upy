import re
import unicodedata


ERR1 = "An identifier shall have an appropriate form"
ERR2 = "An identifier shall conform to Normalization Form C"
ERR3 = "An identifier shall not contain a double underscore __"
ERR4 = "An identifier that is not used as a literal suffix shall not start with _"
ERR5 = "A macro identifier shall only be formed using characters in the ranges [A-Z], [0-9] and _"
ERR6 = "An identifier shall not be defined in namespace std, posix, or stdN, where 'N' is any number"
ERR7 = "An identifier shall not be keyword"
ERR8 = "Literal suffix shall start with a single _ and shall not be preceded by a space"
FORBIDDEN_NAMES = {
    "defined", "final", "override", "clock_t", "div_t", "FILE", "fpos_t", "lconv",
    "ldiv_t", "mbstate_t", "ptrdiff_t", "sig_atomic_t", "size_t", "time_t", "tm",
    "va_list", "wctrans_t", "wctype_t", "wint_t"
}


def ids():
    return ('MISRA23_5.10.1')


def name(id):
    return {
        'MISRA23_5.10.1': """Published Standards/MISRA C++ 2023/\
Rule 5.10.1 User-defined identifiers shall have an appropriate form""",
    }[id]


def tags(id):
    return {
        'MISRA23_5.10.1': [
            'Language: C',
            'Language: C++',
            'Standard: MISRA C++ 2023',
            'Category: Required',
            'Identifiers',
        ],
    }.get(id)


def detailed_description(id):
    return {
        'MISRA23_5.10.1': """
<p><b>Amplification</b></p>
<p>When introducing an identifier, it shall be formed according to the following rules:</p>
<p>1. A universal-character-name used at the start of an identifier shall be:</p>
<p>a. In the range [a-z], [A-Z] or _ or</p>
#44 [13].</p>
<p>b. Within the character class XID_Start, as defined by the Unicode standard UAX
<p>2. A universal-character-name within an identifier shall be:</p>
<p>a. One of the characters allowed at the start of an identifier; or</p>
#44 [13].</p>
<p>b. Within the character class XID_Continue, as defined by the Unicode standard UAX
<p>3. All identifiers shall conform to Normalization Form C, as specified in ISO/IEC 10646 [7].</p>
<p>4. An identifier shall not contain a double underscore __.</p>
<p>5. An identifier that is not used as a literal suffix shall not start with _.</p>
<p>6. A user-defined literal suffix shall start with a single _ and shall not be preceded by a space.</p>
<p>A macro identifier shall additionally only be formed using characters in the ranges [A-Z], [0-9] and _.</p>
<p>Other identifiers shall additionally:</p>
<p>1. Not be defined in namespace std, posix, or stdN, where 'N' is any number; and</p>
<p>2. Not appear in the list defined, final, override, clock_t, div_t, FILE, fpos_t, lconv,
ldiv_t, mbstate_t, ptrdiff_t, sig_atomic_t, size_t, time_t, tm, va_list,
wctrans_t, wctype_t or wint_t.</p>
<p>Note: this rule does not apply to template specializations, as they do not introduce new identifiers —
see [temp.expl.spec].</p>

<p><b>Rationale</b></p>
<p>This rule prohibits the introduction of an identifier with a reserved name, and restricts the characters
permitted within identifiers to a subset of those that are currently permitted by the C++ Standard.
This subset is aligned with Unicode recommendations that are expected to be adopted in a future
revision of the C++ Standard.</p>
<p>For macro names, this rule further restricts the set of permitted characters for the following reasons:</p>
<p>1. It enforces commonly accepted coding style;</p>
<p>2. It helps distinguishing macros from other identifiers;</p>
<p>3. It prevents collision with the name of an attribute defined within the C++ Standard or with any
name defined in the C++ Standard Library, preventing undefined behaviour (even when the
corresponding header file is not explicitly included);</p>
<p>4. It prevents collision with keywords or alternative representations, preventing undefined behaviour.</p>
<p>The restrictions always prohibit the use of identifiers that are only prohibited by the C ++ Standard
within certain contexts (and for which no diagnostic is required in some cases). This rule broadens
the context in which these identifiers are not acceptable in order to reduce the risk of confusion.</p>

<p><b>Example</b></p>
<pre><code language="C++">int32_t i﴾ = 2; // Non-compliant - character \\ufd3e (even though
// it may compile)

#define identity(a) a // Non-compliant - shall be in uppercase

void f()
{
    auto _i = 0; // Non-compliant - using a leading _, even at
    // local scope, is prohibited
}

void operator ""_km( long double ); // Compliant - will be called for 1.0_km
void operator ""mil( long double ); // Non-compliant - user-defined literal
// suffixes shall start with _

double operator ""_Bq ( long double ); // Compliant
double operator "" _Bq( long double ); // Non-compliant - _Bq is preceded by a
// space, making it a reserved identifier

namespace std42
{
    inline namespace a
    {
        int i; // Non-compliant - defined within namespace stdN
    }
}

auto final = 42; // Non-compliant

#include <cstdio> // Compliant - even though it introduces FILE

namespace std
{
    template <> struct hash< A > // Rule does not apply
    {
        size_t operator()( const A & x ) const;
    };
}
</code></pre>

<p><b>Developer's Note:</b></p>
<p>1. An identifier that has a character other than a-z, A-Z, 0-9 and _ will be flagged automatically.</p>
<p>2. An identifier that starts with _ will be flagged automatically.</p>
""",
    }[id]


def test_language(language):
    return language == 'C++'


def test_entity(file):
    return file.kind().check("code file, header file")


def test_global():
    return False


def is_invalid_nspace(name):
    return re.search(r"^(std\d*|posix)::", str(name))


def is_valid_macro(name):
    return re.search(r"^[A-Z0-9_]+$", name)


def is_uchar(name):
    return re.search(r"^[A-Za-z0-9_]+$", name)


def is_normalized_nfc(name):
    return name == unicodedata.normalize("NFC", name)


def check_violation(check, ref, err):
    check.violation(ref.ent(), ref.file(), ref.line(), ref.column(), err)


def check(check, file):
    for ref in file.filerefs("Define, Declare"):
        ent_name = str(ref.ent().name())
        ent_name = ent_name.strip("[]") if ref.ent(
        ).kind().check("Lambda") else ent_name

        if (ent_name == "None"
                or (ent_name == "[unnamed]")
                or ref.ent().ref("Specialize", "Template")
                or ref.ent().freetext("DefinedInMacro")
                or (ref.ent().kind().check("Parameter") and (ent_name == "..."))
                or (ref.ent().kind().check("Member") and ent_name.startswith("~"))):
            continue

        if ent_name.startswith('operator""'):
            lex = file.lexer(lookup_ents=False).lexeme(
                ref.line(), ref.column())

            while lex.token() != "Identifier":
                lex = lex.next()

            if (lex.previous().token() == "Whitespace") or not str(lex.text()).startswith("_"):
                check_violation(check, ref, ERR8)
        elif ent_name.startswith('operator'):
            pass
        elif not is_uchar(ent_name):
            check_violation(check, ref, ERR1)
        elif not is_normalized_nfc(ent_name):
            check_violation(check, ref, ERR2)
        elif "__" in ent_name:
            check_violation(check, ref, ERR3)
        elif str(ent_name).startswith("_"):
            check_violation(check, ref, ERR4)
        elif ref.ent().kind().check("Macro") and not is_valid_macro(ent_name):
            check_violation(check, ref, ERR5)
        elif is_invalid_nspace(ref.ent().longname()):
            check_violation(check, ref, ERR6)
        elif ent_name in FORBIDDEN_NAMES:
            check_violation(check, ref, ERR7)
