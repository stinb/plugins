import re


ERR1 = "An explicit type conversion shall not be an expression statement"


def ids():
    return ('MISRA23_9.2.1')


def name(id):
    return {
        'MISRA23_9.2.1': """Published Standards/MISRA C++ 2023/9.2.1 \
An explicit type conversion shall not be an expression statement""",
    }[id]


def tags(id):
    return {
        'MISRA23_9.2.1': [
            'Language: C',
            'Language: C++',
            'Standard: MISRA C++ 2023',
            'Category: Required',
            'Expressions',
        ],
    }.get(id)


def detailed_description(id):
    return {
        'MISRA23_9.2.1': """
<p><b>Amplification</b></p>
<p>This rule only applies to explicit type conversions that use functional notation.</p>

<p><b>Rationale</b></p>
<p>An explicit type conversion that uses functional notation is composed of a type name followed by
parentheses or braces. It creates a temporary object that is discarded at the end of the statement.
This notation can appear to be very similar to the declaration of a variable, except that it does not
contain a variable name.</p>
<p>If the intent was to declare a variable for scope-based resource management (e.g. std::lock_guard),
the destruction side effects which were expected to occur at the end of the containing block will instead
occur immediately (e.g. the lock is prematurely released).</p>

<p><b>Example</b></p>
<p>In the following example, the redundant parentheses surrounding b_mutex violate Rule 6.0.1.</p>
<pre><code language="C++">void f1()
{
    std::unique_lock< std::mutex > a_mutex; // Declaration, rule does not apply
    std::unique_lock< std::mutex > ( b_mutex ); // Declaration, rule does not apply
}

void f2()
{
    std::scoped_lock { a_mutex }; // Non-compliant
    // - locks and unlocks here
    // Unprotected
}

void f3()
{
    std::scoped_lock ( a_mutex, other_mutex ); // Non-compliant
    // - locks and unlocks here
    // Unprotected
}

void f4()
{
    f( std::unique_lock { a_mutex } ); // Compliant - type conversion is
    // not an expression statement
}</code></pre>

<p><b>See also</b></p>
<p>Rule 6.0.1</p>
""",
    }[id]


def test_language(language):
    return language == 'C++'


def test_entity(file):
    return file.kind().check("code file, header file")


def test_global():
    return False


def is_keyword(lex):
    return ((lex.token() == "Keyword" and lex.text() in ["return", "throw"])
            or (lex.token() == "Operator" and lex.text() not in ["::", "}", "{", ";", "<", ">"]))


def check(check, file):
    for call_ref in file.filerefs("Call ~Inactive ~Implicit, Cast Use", "Explicit Member Function, Type"):
        print(f"call {call_ref}")
        lex = file.lexer().lexeme(call_ref.line(), 0)

        if is_keyword(lex.previous(True, True)) or lex.previous(True, True).text() in "(":
            continue

        on_func = False
        skip = False

        if lex.token() in ["Indent", "Whitespace"]:
            lex = lex.next(True, True)

        statement = ""

        while lex and lex.line_begin() == call_ref.line():
            if on_func and lex.text() == ",":
                pass
            elif ((not on_func
                    and lex.token() not in ["Operator", "Punctuation"]
                    and lex.text() not in call_ref.ent().longname())
                    or is_keyword(lex)):
                skip = True
                break
            elif lex.ent() and lex.ent().id() == call_ref.ent().id():
                on_func = True

            statement += lex.text()

            lex = lex.next(True, True)

        if skip:
            continue

        if re.search(rf"\(?(std::)?(.*::)?{call_ref.ent().name()}(<.*>)?\)?[\({{].+[\)\}}];", statement):
            check.violation(call_ref.ent(), file,
                            call_ref.line(), call_ref.column(), ERR1)
