# This script is designed to run with Understand - CodeCheck
# Rewritten by Robby Bennett
# 2025-01-07


import math
import re

from understand import Ent


ERR1 = 'VOCF too high (%1)'

REF_KINDS = 'define, ada declare body, vhdl declare'
ENT_KINDS = '''\
    ada entry, ada function, ada procedure, ada protected, ada task,
    c function,
    csharp method,
    fortran block data, fortran function, fortran interface, fortran program, fortran subroutine,
    java method,
    jovial subroutine,
    pascal compunit, pascal function, pascal procedure,
    vhdl procedure, vhdl function, vhdl process, vhdl architecture,
    web function, web method'''


def ids():
    return ('HIS_11', 'AC_HIS_11')


def name(id):
    return {
        'HIS_11': '''Published Standards/Hersteller Initiative Software (HIS) Metrics/11. Language scope (VOCF)''',
        'AC_HIS_11': '''All Checks/Language scope (VOCF)''',
    }[id]


def tags(id):
    return {
        'HIS_11': [
            'Language: Ada',
            'Language: C',
            'Language: C++',
            'Language: C#',
            'Language: Fortran',
            'Language: Java',
            'Language: Jovial',
            'Language: Delphi/Pascal',
            'Language: VHDL',
            'Language: Web',
            'Standard: Hersteller Initiative Software (HIS) Metrics',
            'Metrics',
        ],
        'AC_HIS_11': [
            'Language: Ada',
            'Language: C',
            'Language: C++',
            'Language: C#',
            'Language: Fortran',
            'Language: Java',
            'Language: Jovial',
            'Language: Delphi/Pascal',
            'Language: VHDL',
            'Language: Web',
            'Metrics',
        ],
    }.get(id)


def detailed_description(id):
    return '''\
<p><b>Title</b></p>

<p>Language scope (VOCF)</p>

<p><b>Description</b></p>

<p>The language scope is an indicator of the cost of maintaining/changing functions.

<p>VOCF = (N1 + N2) / (nl + n2),</p>

<p>where</p>

<p>nl = Number of different operators</p>

<p>N1 = Sum of all Operators</p>

<p>n2 = Number of different  Operands</p>

<p>N2 = Sum of all Operands</p>

<p>Higher value = similar or duplicated code portions; Calls in/out of sub-functions
need to be considered</p>

<p>Acceptable Range &lt;= 4</p>

<p><b>Developer's Notes</b></p>

<p>This check cannot pick up PHP/Javascript functions that are embedded in an html file. They must be placed in a separate .php or .js file.</p>
'''


def test_entity(file):
    return True


def test_global():
    return False


def test_language(language):
    return language in ('Ada', 'C++', 'C#', 'Fortran', 'Java', 'Jovial', 'Pascal', 'VHDL', 'Web')


def define_options(check):
    check.options().integer('maxVOCF', 'Maximum VOCF level', 4)
    check.options().checkbox('ignoreInactive', 'Ignore Inactive Code', True)


def check(check, file):
    max_vocf = check.options().lookup('maxVOCF')
    ignore_inactive = check.options().lookup('ignoreInactive')

    for ref in file.filerefs(REF_KINDS, ENT_KINDS):
        ent = ref.ent()

        vocf = get_vocf(ent, ignore_inactive)
        if not math.isnan(vocf) and vocf > max_vocf:
            check.violation(ent, file, ref.line(), ref.column(), ERR1, vocf)


def get_vocf(func: Ent, ignore_inactive: bool) -> float:
    refs = func.refs('definein', '' , True)
    if not refs:
        refs = func.refs('declarein', '', True)
        if not refs:
            return float('nan')
    start_ref = refs[0]

    refs = func.refs('end', '', True)
    if not refs:
        return float('nan')
    end_ref = refs[0]

    lexer = start_ref.file().lexer(False)

    N1 = 0
    N2 = 0

    n1_set: set[str] = set()
    n2_set: set[str] = set()

    for lex in lexer.lexemes(start_ref.line(), end_ref.line()):
        if ignore_inactive and lex.inactive():
            continue

        token, text = lex.token(), lex.text()
        if token in ('Keyword', 'Punctuation', 'Operator'):
            if not re.search(r'[)}\]]', text):
                n1_set.add(text)
                N1 += 1
        elif token in ('Identifier', 'Literal', 'String'):
            n2_set.add(text)
            N2 += 1

    n1 = len(n1_set)
    n2 = len(n2_set)
    if n1 + n2 > 0:
        return round((N1 + N2) / (n1 + n2), 2)
    return 0.0
