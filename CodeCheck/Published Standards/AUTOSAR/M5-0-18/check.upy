import re


ERR1 = 'Relational operator %1 shall only be used between pointers that refer to the same object'
STDLIB_FUNCS = ["strchr", "strrchr", "strstr", "memchr"]


def ids():
    return ('M5-0-18', 'CPP_P043', 'MISRA12_18.3', 'MISRA08_5-0-18', 'MISRA04_17.3', 'MISRA23_18.3')


def name(id):
    return {
        'M5-0-18': 'Published Standards/AUTOSAR/>, >=, <, <= shall not be applied to objects of pointer type, except where they point to the same array',
        'CPP_P043': 'All Checks/Language Specific/C and C++/Pointers/>, >=, <, <= shall not be applied to objects of pointer type, except where they point to the same array',
        'MISRA12_18.3': 'Published Standards/MISRA C 2012/18.3 The relational operators >, >=, < and <= shall not be applied to objects of pointer type except where they point into the same object',
        'MISRA08_5-0-18': 'Published Standards/MISRA-C++ 2008/5-0-18 >, >=, <, <= shall not be applied to objects of pointer type, except where they point to the same array',
        'MISRA04_17.3': 'Published Standards/MISRA-C 2004/17.3 >, >=, <, <= shall not be applied to objects of pointer type, except where they point to the same array',
        'MISRA23_18.3': 'Published Standards/MISRA C 2023/18.3 The relational operators >, >=, < and <= shall not be applied to objects of pointer type except where they point into the same object',
    }[id]


def tags(id):
    return {
        'MISRA08_5-0-18': [
            'Language: C',
            'Language: C++',
            'Standard: MISRA C++ 2008',
            'Category: Required',
            'Pointers',
        ],
        'MISRA12_18.3': [
            'Language: C',
            'Standard: MISRA C 2012',
            'Category: Required',
            'Pointers',
        ],
        'MISRA04_17.3': [
            'Language: C',
            'Standard: MISRA C 2004',
            'Category: Required',
            'Pointers',
        ],
        'M5-0-18': [
            'Language: C',
            'Language: C++',
            'Standard: AUTOSAR',
            'Category: Required',
            'Automation: Automated',
            'Pointers',
        ],
        'CPP_P043': [
            'Language: C',
            'Language: C++',
            'Pointers',
        ],
        'MISRA23_18.3': [
            'Language: C',
            'Standard: MISRA C 2023',
            'Category: Required',
            'Pointers',
        ],
    }.get(id)


def detailed_description():
    return """\
<p><b>Rationale</b></p>
<p>Attempting to make comparisons between pointers will produce undefined
behaviour if the two pointers do not point to the same object.</p>
<p>Note: it is permissible to address the next element beyond the end of an
array, but accessing this element is not allowed.</p>
<p><b>Example</b></p>
<pre><code language="C++">void f1 ( )
{
    int32_t a1[ 10 ];
    int32_t a2[ 10 ];
    int32_t * p1 = a1;
    if ( p1 &lt; a1 ) // Compliant
    {
    }
    if ( p1 &lt; a2 ) // Non-compliant
    {
    }
}
</code></pre>
"""


def test_entity(file):
    return file.kind().check('code file, header file')


def test_language(language):
    return language == 'C++'


def get_obj(lex):
    while lex and lex.token() not in ["Whitespace", "Indent", "Newline"]:
        if lex.ent() and lex.previous().text() not in ["->", "."]:
            return lex.ent()
        
        lex = lex.previous()


def get_left_op(lex):
    parent_obj = None

    while lex and (lex.text() != "=" ) and lex.token() not in ["Literal", "Whitespace", "Indent", "Newline"]:
        if (lex.token() == "Identifier") and lex.ent():
            if not lex.ent().kind().check("Object, Parameter"):
                return None, None
            
            utype = str(lex.ent().freetext("UnderlyingType"))

            if lex.ent().kind().check("Member") and lex.previous().text() in [".", "->"] and lex.ref() and lex.ref().kind().check("Addr"):
                parent_obj = get_obj(lex.previous())
            elif not (re.search(r"(\*$|\[.*\]$)", utype) or (lex.previous(True, True).text() == "&")):
                return None, None
                        
            return lex.ent(), parent_obj

        lex = lex.previous()

    return None, None


def get_right_op(lex):
    right_ent = None
    parent_obj = None

    # compared to sizeof
    if lex.token() == "Keyword":
        return None, lex, None

    while lex and lex.text() not in [";", ","] and lex.token() not in ["Literal", "Whitespace", "Indent", "Newline"]:
        if (lex.token() == "Identifier") and lex.ent() and lex.next().text() not in ["->", "."]:
            if not lex.ent().kind().check("Object, Parameter"):
                return None, lex, None
            
            utype = str(lex.ent().freetext("UnderlyingType"))

            if lex.ent().kind().check("Member") and lex.previous().text() in [".", "->"] and lex.ref() and lex.ref().kind().check("Addr"):
                parent_obj = get_obj(lex.previous())
            elif not (re.search(r"(\*$|\[.*\]$)", utype) or (lex.previous(True, True).text() == "&")):
                return None, lex, None
            
            return lex.ent(), lex, parent_obj        
        
        lex = lex.next()
    
    return right_ent, lex, None


def get_ptrs(ent):
    ptr_ids = [ent.id()]

    for ptr_ref in ent.refs("Assign Ptr"):
        if ptr_ref.ent().kind().check("Function") and ptr_ref.ent().name() in STDLIB_FUNCS:
            lex = ptr_ref.file().lexer().lexeme(ptr_ref.line(), ptr_ref.column())
            on_param = 0

            while lex:
                if lex.text() == "(":
                    on_param += 1
                elif lex.text() == ")":
                    on_param -= 1
                elif (on_param == 1) and lex.ent():
                    ptr_ids.append(lex.ent().id())

                lex = lex.next(True, True)
        elif ptr_ref.ent().kind().check("Object, Parameter"):
            ptr_ids.append(ptr_ref.ent().id())

    for set_ref in ent.refs("Setby"):
        lex = set_ref.file().lexer().lexeme(set_ref.line(), set_ref.column())

        if lex and (lex.next(True, True).text() != "="):
            continue
            
        lex = lex.next(True, True)
        on_bracket = 0

        while lex and (lex.text() != ";"):
            if lex.text() in "[{(":
                on_bracket += 1
            elif lex.text() in "]})":
                on_bracket -= 1
            elif not on_bracket and lex.ent():
                ptr_ids.append(lex.ent().id())
            elif not on_bracket and (lex.text() == ","):
                break

            lex = lex.next(True, True)

    return ptr_ids


def check(check, file):
    lexer = file.lexer(True, 8, False, False)
    lex = lexer.first()

    while lex:
        if (lex.token() == "Operator") and lex.text() in ["<", "<=", ">=", ">"]:
            op = lex
            left_ent, l_parent = get_left_op(lex.previous(True, True))

            if not left_ent:
                lex = lex.next(True, True)
                continue

            right_ent, lex, r_parent = get_right_op(lex.next(True, True))

            if not right_ent:
                continue


            if l_parent and r_parent:
                if l_parent.id() == r_parent.id():
                    continue

                check.violation(None, file, op.line_begin(), op.column_begin(), ERR1, op.text())
                continue
            
            left_ptrs = get_ptrs(left_ent)
            right_ptrs = get_ptrs(right_ent)                      

            if not set(left_ptrs) & set(right_ptrs):
                check.violation(None, file, op.line_begin(), op.column_begin(), ERR1, op.text())

        lex = lex.next(True, True)