# This script is designed to run with Understand - CodeCheck
# Written by Jordan Colbeth
# 10-12-2021
# Fix 12-31-2025: Loop handling in switch case analysis

import re

OPT1 = "Case/Default clauses with return"
OPT1RETURN = "Return allowed"
OPT1NORETURN = "Return not allowed"

ERR1 = 'Unconditional throw or break statement does not terminate non-empty switch-clause'

# The ID for the check
def ids():
    return ('M6-4-5', 'CPP_C033', 'MISRA04_15.2', 'MISRA08_6-4-5', 'MISRA12_16.3', 'MISRA23_16.3')

# The short name of the check
def name(id):
    return {
        'M6-4-5': 'Published Standards/AUTOSAR/An unconditional throw or break statement shall terminate every non-empty switch-clause',
        'CPP_C033': 'All Checks/Language Specific/C and C++/Control Flow/An unconditional throw or break statement shall terminate every non-empty switch-clause',
        'MISRA04_15.2': 'Published Standards/MISRA-C 2004/15.2 An unconditional break statement shall terminate every non-empty switch clause',
        'MISRA08_6-4-5': 'Published Standards/MISRA-C++ 2008/6-4-5 An unconditional throw or break statement shall terminate every non-empty switch-clause',
        'MISRA12_16.3': 'Published Standards/MISRA C 2012/16.3 An unconditional break statement shall terminate every switch-clause',
        'MISRA23_16.3': 'Published Standards/MISRA C 2023/16.3 An unconditional break statement shall terminate every switch-clause',
    }[id]


def tags(id):
    return {
        'MISRA08_6-4-5': [
            'Language: C',
            'Language: C++',
            'Standard: MISRA C++ 2008',
            'Category: Required',
            'Control Flow',
        ],
        'MISRA12_16.3': [
            'Language: C',
            'Standard: MISRA C 2012',
            'Category: Required',
            'Control Flow',
        ],
        'MISRA04_15.2': [
            'Language: C',
            'Standard: MISRA C 2004',
            'Category: Required',
            'Control Flow',
        ],
        'M6-4-5': [
            'Language: C',
            'Language: C++',
            'Standard: AUTOSAR',
            'Category: Required',
            'Automation: Automated',
            'Control Flow',
        ],
        'CPP_C033': [
            'Language: C',
            'Language: C++',
            'Control Flow',
        ],
        'MISRA23_16.3': [
            'Language: C',
            'Standard: MISRA C 2023',
            'Category: Required',
            'Control Flow',
        ],
    }.get(id)

# The short description of the check
def description():
    return '( Required ) An unconditional throw or break statement shall terminate every non-empty switch-clause.'




# The long description of the check
def detailed_description(id):
    return {
        'M6-4-5' : """\
<p><b>Developer's Notes</b></p>
This check is reliant upon Understand's Control Flow graph. If errors exist in the project analysis, the Control Flow graph
may not render correctly. If this is the case, then this check may throw false positives. This check will not detect code
that exists after a break, throw or return statement as it is normally unreachable. Unreachable code is detected by another check.
</p>

<p>
<p><b>Rationale</b></p>
If a developer fails to add a <i>break</i> statement to the end of a <i>switch-clause</i>, then control flow falls
into any following <i>switch-clause</i>. Whilst this is sometimes intentional, it is often an error.
</p>

<p>
To ensure that such errors can be detected, the last statement in every <i>switch-clause</i> shall be a
<i>break</i> statement, or if the <i>switch-clause</i> is a compound statement, then the last statement in the
compound statement shall be a break statement.
</p>

<p>
A special case exists if the <i>switch-clause</i> is empty, as this allows groups of clauses requiring
identical statements to be created.
</p>

<br>
<p><b>Example</b></p><pre><code language="C++">  switch ( x )
  {
    case 0:
      break; // Compliant
    case 1:  // Compliant - empty drop through
    case 2:  // allows a group
      break; // Compliant
    case 3:
      throw; // Compliant
    case 4:
      a = b;
             // Non-compliant - non empty drop through
    default:
      ;      // Non-compliant - default must also have "break"
  }
</code></pre>""",
        'CPP_C033': """\
<p><b>Developer's Notes</b></p>
This check is reliant upon Understand's Control Flow graph. If errors exist in the project analysis, the Control Flow graph
may not render correctly. If this is the case, then this check may throw false positives. This check will not detect code
that exists after a break, throw or return statement as it is normally unreachable. Unreachable code is detected by another check.
</p>

<p>
<p><b>Rationale</b></p>
If a developer fails to add a <i>break</i> statement to the end of a <i>switch-clause</i>, then control flow falls
into any following <i>switch-clause</i>. Whilst this is sometimes intentional, it is often an error.
</p>

<p>
To ensure that such errors can be detected, the last statement in every <i>switch-clause</i> shall be a
<i>break</i> statement, or if the <i>switch-clause</i> is a compound statement, then the last statement in the
compound statement shall be a break statement.
</p>

<p>
A special case exists if the <i>switch-clause</i> is empty, as this allows groups of clauses requiring
identical statements to be created.
</p>

<br>
<p><b>Example</b></p>
<pre><code language="C++">  switch ( x )
  {
    case 0:
      break; // Compliant
    case 1:  // Compliant - empty drop through
    case 2:  // allows a group
      break; // Compliant
    case 3:
      throw; // Compliant
    case 4:
      a = b;
             // Non-compliant - non empty drop through
    default:
      ;      // Non-compliant - default must also have "break"
  }
</code></pre>""",
    'MISRA04_15.2' : """\
<p><b>Developer's Notes</b></p>
This check is reliant upon Understand's Control Flow graph. If errors exist in the project analysis, the Control Flow graph
may not render correctly. If this is the case, then this check may throw false positives. This check will not detect code
that exists after a break, throw or return statement as it is normally unreachable. Unreachable code is detected by another check.
</p>

<p><b>Rationale</b></p>
The last statement in every switch clause shall be a <i>break</i> statement, or if the <i>switch</i> clause
is a compound statement, then the last statement in the compound statement shall be a <i>break</i>
statement.</p>
<br>
<p><b>Example</b></p><pre><code language="C++">  switch ( x )
  {
    case 0:
      break; // Compliant
    case 1:  // Compliant - empty drop through
    case 2:  // allows a group
      break; // Compliant
    case 3:
      a = b;
             // Non-compliant - non empty drop through
    default:
      ;      // Non-compliant - default must also have "break"
  }
</code></pre>""",
    'MISRA08_6-4-5' : """\
<p><b>Developer's Notes</b></p>
This check is reliant upon Understand's Control Flow graph. If errors exist in the project analysis, the Control Flow graph
may not render correctly. If this is the case, then this check may throw false positives. This check will not detect code
that exists after a break, throw or return statement as it is normally unreachable. Unreachable code is detected by another check.
</p>

<p>
<p><b>Rationale</b></p>
If a developer fails to add a <i>break</i> statement to the end of a <i>switch-clause</i>, then control flow falls
into any following <i>switch-clause</i>. Whilst this is sometimes intentional, it is often an error.
</p>

<p>
To ensure that such errors can be detected, the last statement in every <i>switch-clause</i> shall be a
<i>break</i> statement, or if the <i>switch-clause</i> is a compound statement, then the last statement in the
compound statement shall be a break statement.
</p>

<p>
A special case exists if the <i>switch-clause</i> is empty, as this allows groups of clauses requiring
identical statements to be created.
</p>

<br>
<p><b>Example</b></p><pre><code language="C++">  switch ( x )
  {
    case 0:
      break; // Compliant
    case 1:  // Compliant - empty drop through
    case 2:  // allows a group
      break; // Compliant
    case 3:
      throw; // Compliant
    case 4:
      a = b;
             // Non-compliant - non empty drop through
    default:
      ;      // Non-compliant - default must also have "break"
  }
</code></pre>""",
    'MISRA12_16.3' : """\
<p><b>Developer's Notes</b></p>
This check is reliant upon Understand's Control Flow graph. If errors exist in the project analysis, the Control Flow graph
may not render correctly. If this is the case, then this check may throw false positives. This check will not detect code
that exists after a break, throw or return statement as it is normally unreachable. Unreachable code is detected by another check.
</p>

<p>
<p><b>Rationale</b></p>
If a developer fails to end a <i>switch-clause</i> with a <i>break</i> statement, then control flow "falls" into the
following <i>switch-clause</i> or, if there is no such clause, off the end and into the statement following
the <i>switch</i> statement. Whilst falling into a following <i>switch-clause</i> is sometimes intentional, it is often
an error. An unterminated <i>switch-clause</i> occurring at the end of a <i>switch</i> statement may fall into any
<i>switch-clauses</i> which are added later.
</p>

<p>
To ensure that such errors can be detected, the last statement in every <i>switch-clause</i> shall be a
<i>break</i> statement, or if the <i>switch-clause</i> is a compound statement, then the last statement in the
compound statement shall be a break statement.
</p>

<p>
Note: a <i>switch-clause</i> is defined as containing at least one statement. Two consecutive labels, <i>case</i> or
<i>default</i>, do not have any intervening statement and are therefore permitted by this rule.
</p>

<br>
<p><b>Example</b></p><pre><code language="C++">switch ( x )
{
  case 0:
    break; /* Compliant - unconditional break */
  case 1: /* Compliant - empty fall through allows a group */
  case 2:
    break; /* Compliant */
  case 4:
    a = b; /* Non-compliant - break omitted */
  case 5:
    if ( a == b )
    {
      ++a;
      break; /* Non-compliant - conditional break */
    }
  default:
    ; /* Non-compliant - default must also have a break */
}
</code></pre>""",
    'MISRA23_16.3' : """\
<p><b>Developer's Notes</b></p>
This check is reliant upon Understand's Control Flow graph. If errors exist in the project analysis, the Control Flow graph
may not render correctly. If this is the case, then this check may throw false positives. This check will not detect code
that exists after a break, throw or return statement as it is normally unreachable. Unreachable code is detected by another check.
</p>

<p>
<p><b>Rationale</b></p>
If a developer fails to end a <i>switch-clause</i> with a <i>break</i> statement, then control flow "falls" into the
following <i>switch-clause</i> or, if there is no such clause, off the end and into the statement following
the <i>switch</i> statement. Whilst falling into a following <i>switch-clause</i> is sometimes intentional, it is often
an error. An unterminated <i>switch-clause</i> occurring at the end of a <i>switch</i> statement may fall into any
<i>switch-clauses</i> which are added later.
</p>

<p>
To ensure that such errors can be detected, the last statement in every <i>switch-clause</i> shall be a
<i>break</i> statement, or if the <i>switch-clause</i> is a compound statement, then the last statement in the
compound statement shall be a break statement.
</p>

<p>
Note: a <i>switch-clause</i> is defined as containing at least one statement. Two consecutive labels, <i>case</i> or
<i>default</i>, do not have any intervening statement and are therefore permitted by this rule.
</p>

<br>
<p><b>Example</b></p><pre><code language="C++">switch ( x )
{
  case 0:
    break; /* Compliant - unconditional break */
  case 1: /* Compliant - empty fall through allows a group */
  case 2:
    break; /* Compliant */
  case 4:
    a = b; /* Non-compliant - break omitted */
  case 5:
    if ( a == b )
    {
      ++a;
      break; /* Non-compliant - conditional break */
    }
  default:
    ; /* Non-compliant - default must also have a break */
}
</code></pre>""",
    }[id]

def test_entity(file):
    return file.kind().check('code file, header file')

def test_language(language):
    return language == 'C++'

# Define configurable options for the check
def define_options(check):
    check.option().choice('returnAllowed',OPT1,[OPT1RETURN,OPT1NORETURN],OPT1NORETURN);


# This is the actual test being performed on the user's code
def check(check, file):
    lexer = None

    funcRefs = file.filerefs("Define", "Function")
    if not funcRefs:
        return

    # Loop through all functions
    for funcRef in funcRefs:
        func = funcRef.ent()
        # Spin up control flow graph
        if not func.control_flow_graph():
            continue
        cfg = func.control_flow_graph()

        start = cfg.start()
        end = start.end_node()
        nodes = cfg.nodes()

        # Test all nodes for switch cases and switch default statements
        for node in nodes:
            kind = node.kind()
            if (kind == "switch-case" or kind == "switch-default"):
                for child in node.children():
                    line = node.line_begin()
                    column = node.column_begin()
                    visited = {}
                    # Add path_stack to track current path for loop detection
                    path_stack = set()
                    # Run the testing function on this switch node
                    ok, line, column = testCase(check, funcRef, file, line, column, node, child, visited, lexer, False, path_stack)
                    if not ok:
                        check.violation(funcRef.ent(), file, int(line or 0), int(column or 0), ERR1)



# This function walks the switch case statements to ensure they end in a break or throw command
# Added path_stack parameter to track nodes in current traversal path
def testCase(check, funcRef, file, line, column, node, child, visited, lexer, passive, path_stack):
    parent = node
    node = child
    kind = node.kind()
    canReturn = (check.option().lookup("returnAllowed") == OPT1RETURN)

    if kind == "break":
        return True, line, column
    if kind == "passive":
        passive = True
        if not lexer:
            if not file.lexer():
                return True, line, column
            lexer = file.lexer()
        lexeme = None
        if node.line_begin() and node.column_begin():
            lexeme = lexer.lexeme(node.line_begin(), node.column_begin())
        if lexeme and lexeme.text().lower() == 'throw':
            return True, line, column


    if (canReturn == True and kind == "return"):
        return True, line, column

    if (kind in ("switch-case", "switch-default", "end-switch")):
        if passive:
            return False, line, column
            passive = False
        if kind != 'end-switch':
            line = node.line_begin()
            column = node.column_begin()

    # Tracking distinguishes between:
    # 1. Nodes already visited in ANY path (visited dict) - prevents infinite loops
    # 2. Nodes in the CURRENT path (path_stack set) - detects loop back-edges
    # If we encounter a node that's in our current path, it's a back-edge (loop),
    # which should NOT be considered a valid termination path
    if node in path_stack:
        # This is a back-edge (loop) - not a valid exit path
        return False, line, column
    
    if node in visited:
        # Already explored this node from another path
        # Return the cached result
        return visited[node]
    
    # Add current node to path_stack before exploring child nodes
    path_stack.add(node)

    children = node.children()
    found_valid_termination = False
    
    if children:
        for child in children:
            # Pass path_stack through recursive calls
            ok, line, column = testCase(check, funcRef, file, line, column, node, child, visited, lexer, passive, path_stack)
            if ok:
                found_valid_termination = True
                # Don't break early - continue checking all paths (ensures we detect when ALL paths don't terminate)
    
    # Remove current node from path_stack after exploring
    path_stack.remove(node)
    
    # Cache the result for this node
    visited[node] = (found_valid_termination, line, column)
    
    return found_valid_termination, line, column

