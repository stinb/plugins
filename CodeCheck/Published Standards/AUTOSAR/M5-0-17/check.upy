import re


ERR1 = 'Subtraction shall only be between pointers that refer to the same array'
ERR2 = 'Comparison shall only be between pointers that refer to the same array'


STDLIB_FUNCS = ["strchr", "strrchr", "strstr", "memchr"]


# The ID for the check
def ids():
    return ('M5-0-17', 'MISRA08_5-0-17', 'CPP_P041', 'MISRA12_18.2', 'ARR36-C', 'MISRA23_8.7.2', 'MISRA23_18.2')


# The short name of the check
def name(id):
    return {
        'M5-0-17': 'Published Standards/AUTOSAR/Subtraction between pointers shall only be applied to pointers that address elements of the same array',
        'MISRA08_5-0-17': 'Published Standards/MISRA-C++ 2008/5-0-17 Subtraction between pointers shall only be applied to pointers that address elements of the same array',
        'CPP_P041': 'All Checks/Language Specific/C and C++/Pointers/Subtraction between pointers shall only be applied to pointers that address elements of the same array',
        'MISRA12_18.2': 'Published Standards/MISRA C 2012/18.2 Subtraction between pointers shall only be applied to pointers that address elements of the same array',
        'ARR36-C': 'Published Standards/SEI Cert Standards/C/Do not subtract or compare two pointers that do not refer to the same array',
        'MISRA23_8.7.2': 'Published Standards/MISRA C++ 2023/8.7.2 Subtraction between pointers shall only be applied to pointers that address elements of the same array',
        'MISRA23_18.2': 'Published Standards/MISRA C 2023/18.2 Subtraction between pointers shall only be applied to pointers that address elements of the same array',
    }[id]


def tags(id):
    return {
        'MISRA08_5-0-17': [
            'Language: C',
            'Language: C++',
            'Standard: MISRA C++ 2008',
            'Category: Required',
            'Pointers',
        ],
        'MISRA12_18.2': [
            'Language: C',
            'Standard: MISRA C 2012',
            'Category: Required',
            'Pointers',
        ],
        'M5-0-17': [
            'Language: C',
            'Language: C++',
            'Standard: AUTOSAR',
            'Category: Required',
            'Automation: Automated',
            'Pointers',
        ],
        'ARR36-C': [
            'Language: C',
            'Standard: SEI CERT C',
            'Severity: 50',
            'Likelihood: Probable',
            'Remediation Cost: Medium',
            'Priority: P8',
            'Level: L2',
            'Pointers',
        ],
        'CPP_P041': [
            'Language: C',
            'Language: C++',
            'Pointers',
        ],
        'MISRA23_8.7.2': [
            'Language: C',
            'Language: C++',
            'Standard: MISRA C++ 2023',
            'Category: Required',
            'Pointers',
        ],
        'MISRA23_18.2': [
            'Language: C',
            'Standard: MISRA C 2023',
            'Category: Required',
            'Pointers',
        ],
    }.get(id)


# The long description of the check
def detailed_description(id):
    return {
        'M5-0-17': '''
<p><b>Rationale</b></p>

<p>This rule applies to expressions of the form:</p>

<pre><code language="C++">    pointer_expression_1 - pointer_expression_2</code></pre>

<p>where <code>pointer_expression_1</code> and <code>pointer_expression_2</code> are pointers to array elements. It is <i>undefined behaviour</i> if <code>pointer_expression_1</code> and <code>pointer_expression_2</code> do not point to elements of the same array or the element one beyond the end of that array.</p>

<p><b>Example</b></p>

<pre><code language="C++">void f1 ( )
{
    int32_t a1[ 10 ];
    int32_t a2[ 10 ];

    int32_t * p1 = &a1 [ 1 ];
    int32_t * p2 = &a2 [ 10 ];
    int32_t * p3 = &a1 [ 2 ];
    int32_t diff;

    diff = p1 - a1; // Compliant
    diff = p2 - a2; // Compliant
    diff = p1 - p2; // Non-compliant
    diff = p2 - p1; // Non-compliant
    diff = p3 - p1; // Compliant
}
</code></pre>
''',
        'MISRA08_5-0-17': '''
<p><b>Rationale</b></p>

<p>This rule applies to expressions of the form:</p>

<pre><code language="C++">    pointer_expression_1 - pointer_expression_2</code></pre>

<p>where <code>pointer_expression_1</code> and <code>pointer_expression_2</code> are pointers to array elements. It is <i>undefined behaviour</i> if <code>pointer_expression_1</code> and <code>pointer_expression_2</code> do not point to elements of the same array or the element one beyond the end of that array.</p>

<p><b>Example</b></p>

<pre><code language="C++">void f1 ( )
{
    int32_t a1[ 10 ];
    int32_t a2[ 10 ];

    int32_t * p1 = &a1 [ 1 ];
    int32_t * p2 = &a2 [ 10 ];
    int32_t * p3 = &a1 [ 2 ];
    int32_t diff;

    diff = p1 - a1; // Compliant
    diff = p2 - a2; // Compliant
    diff = p1 - p2; // Non-compliant
    diff = p2 - p1; // Non-compliant
    diff = p3 - p1; // Compliant
}
</code></pre>
''',
        'CPP_P041': '''
<p><b>Rationale</b></p>

<p>This rule applies to expressions of the form:</p>

<pre><code language="C++">    pointer_expression_1 - pointer_expression_2</code></pre>

<p>where <code>pointer_expression_1</code> and <code>pointer_expression_2</code> are pointers to array elements. It is <i>undefined behaviour</i> if <code>pointer_expression_1</code> and <code>pointer_expression_2</code> do not point to elements of the same array or the element one beyond the end of that array.</p>

<p><b>Example</b></p>

<pre><code language="C++">void f1 ( )
{
    int32_t a1[ 10 ];
    int32_t a2[ 10 ];

    int32_t * p1 = &a1 [ 1 ];
    int32_t * p2 = &a2 [ 10 ];
    int32_t * p3 = &a1 [ 2 ];
    int32_t diff;

    diff = p1 - a1; // Compliant
    diff = p2 - a2; // Compliant
    diff = p1 - p2; // Non-compliant
    diff = p2 - p1; // Non-compliant
    diff = p3 - p1; // Compliant
}
</code></pre>
''',
        'MISRA12_18.2': '''
<p><b>Rationale</b></p>

<p>This rule applies to expressions of the form:</p>

<pre><code language="C++">pointer_expression_1 - pointer_expression_2</code></pre>

<p>It is undefined behaviour if <code>pointer_expression_1</code> and <code>pointer_expression_2</code> do not point to elements of the same array or the element one beyond the end of that array.</p>

<p><b>Example</b></p>

<pre><code language="C++">#include &lt;stddef.h&gt;
void f1 ( int32_t *ptr )
{
  int32_t a1[ 10 ];
  int32_t a2[ 10 ];
  int32_t *p1 = &a1[ 1 ];
  int32_t *p2 = &a2[ 10 ];
  ptrdiff_t diff;
  diff = p1 - a1;          /* Compliant */
  diff = p2 - a2;          /* Compliant */
  diff = p1 - p2;          /* Non-compliant */
  diff = ptr - p1;         /* Non-compliant */
}
</code></pre>

<p><b>See also</b></p>

<p>Dir 4.1, Rule 18.4</p>
''',
        'ARR36-C': '''
<p>Do not subtract or compare two pointers that do not refer to the same array</p>
<p>For the full standard: <i>https://wiki.sei.cmu.edu/confluence/display/c/ARR36-C.+Do+not+subtract+or+compare+two+pointers+that+do+not+refer+to+the+same+array</i></p>
<p><b>Exceptions</b></p>
<p><i>ARR36-C-EX1: Comparing two pointers to distinct members of the same struct object is allowed. Pointers to structure members declared later in the structure compare greater-than pointers to members declared earlier in the structure.</i></p>
<p><b>Noncompliant Code Example</b></p>
<pre><code language="C++"># include &lt;stddef.h&gt;

enum { SIZE = 32 };

void func(void) {
  int nums[SIZE];
  int end;
  int *next_num_ptr = nums;
  size_t free_elements;

  /* Increment next_num_ptr as array fills */

  free_elements = &end - next_num_ptr;
}
</code></pre>
''',
        'MISRA23_8.7.2': '''
<p><b>Amplification</b></p>

<p>This rule applies to expressions of the form:</p>
<pre><code language="C++">    pointer_expression_1 - pointer_expression_2</code></pre>
<p>Note: a pointer to an object that is not an array is treated as if it were a pointer to the first element of
an array with a single element.</p>

<p><b>Rationale</b></p>

<p>Undefined behaviour occurs if pointer_expression_1 and pointer_expression_2 do not point
to elements of the same array or the element one beyond the end of that array.</p>

<p><b>Example</b></p>
<pre><code language="C++">void f1( int32_t * ptr )
{
 int32_t a1[ 10 ];
 int32_t a2[ 10 ];
 int32_t * p1 = &a1[ 1 ];
 int32_t * p2 = &a2[ 10 ];
 ptrdiff_t diff1 = p1 - a1; // Compliant
 ptrdiff_t diff2 = p2 - a2; // Compliant
 ptrdiff_t diff3 = p1 - p2; // Non-compliant
 ptrdiff_t diff4 = ptr - p1; // Non-compliant
}
</code></pre>

<p><b>See also</b></p>
<p>Rule 4.1.3</p>
''',
        'MISRA23_18.2': '''
<p><b>Rationale</b></p>

<p>This rule applies to expressions of the form:</p>

<pre><code language="C++">pointer_expression_1 - pointer_expression_2</code></pre>

<p>It is undefined behaviour if <code>pointer_expression_1</code> and <code>pointer_expression_2</code> do not point to elements of the same array or the element one beyond the end of that array.</p>

<p><b>Example</b></p>

<pre><code language="C++">#include &lt;stddef.h&gt;
void f1 ( int32_t *ptr )
{
  int32_t a1[ 10 ];
  int32_t a2[ 10 ];
  int32_t *p1 = &a1[ 1 ];
  int32_t *p2 = &a2[ 10 ];
  ptrdiff_t diff;
  diff = p1 - a1;          /* Compliant */
  diff = p2 - a2;          /* Compliant */
  diff = p1 - p2;          /* Non-compliant */
  diff = ptr - p1;         /* Non-compliant */
}
</code></pre>

<p><b>See also</b></p>
<p>Dir 4.1, Rule 18.4</p>
''',
    }[id]


# Tests the type of file
def test_entity(file):
    return file.kind().check('header file,code file')


# Optional - Return True if this check should be run on the entire project
# regardless of what files are selected. Should only be used for
# project-level checks
def test_global():
    return False


def test_language(language):
    return language == 'C++'


def define_options(check):
    compare = (check.id() == 'ARR36-C')
    check.option().checkbox('compare', 'Check pointer comparisons using the relational operators <, <=, >=, and >', compare)


def get_left_op(lex):
    on_bracket = 0

    while lex and (lex.text() != "=" ) and lex.token() not in ["Literal"]:
        if lex.text() in "]})":
            on_bracket += 1
        elif lex.text() in "[{(":
            on_bracket -= 1
        elif not on_bracket and (lex.token() == "Identifier") and lex.ent():
            if not lex.ent().kind().check("Object, Parameter"):
                return None
            
            utype = str(lex.ent().freetext("UnderlyingType"))

            if not (re.search(r"(\*$|\[.*\]$)", utype) or (lex.previous(True, True).text() == "&")):
                return None
            
            return lex.ent()

        lex = lex.previous(True, True)

    return None


def get_right_op(lex):
    right_ent = None
    on_bracket = 0

    while lex and lex.text() not in [";", ","] and lex.token() not in ["Literal"]:
        if lex.text() in "[{(":
            on_bracket += 1
        elif lex.text() in "]})":
            on_bracket -= 1
        elif not on_bracket and (lex.token() == "Identifier") and lex.ent() and lex.next().text() not in ["->", "."]:
            if not lex.ent().kind().check("Object, Parameter"):
                return None, lex
            
            utype = str(lex.ent().freetext("UnderlyingType"))

            if not (re.search(r"(\*$|\[.*\]$)", utype) or (lex.previous(True, True).text() == "&")):
                return None, lex

            return lex.ent(), lex        
            break
        
        lex = lex.next(True, True)
    
    return right_ent, lex


def get_ptrs(ent):
    ptr_ids = [ent.id()]
    has_array = False

    for ptr_ref in ent.refs("Assign Ptr"):
        utype = str(ptr_ref.ent().freetext("UnderlyingType"))

        if re.search(r"\[.*\]$", utype):
            has_array = True
            
        if ptr_ref.ent().kind().check("Function") and ptr_ref.ent().name() in STDLIB_FUNCS:
            lex = ptr_ref.file().lexer().lexeme(ptr_ref.line(), ptr_ref.column())
            on_param = 0

            while lex:
                if lex.text() == "(":
                    on_param += 1
                elif lex.text() == ")":
                    on_param -= 1
                elif (on_param == 1) and lex.ent():
                    ptr_ids.append(lex.ent().id())

                lex = lex.next(True, True)
        elif ptr_ref.ent().kind().check("Object, Parameter"):
            ptr_ids.append(ptr_ref.ent().id())

    for set_ref in ent.refs("Setby"):
        lex = set_ref.file().lexer().lexeme(set_ref.line(), set_ref.column())

        if lex and (lex.next(True, True).text() != "="):
            continue
            
        lex = lex.next(True, True)
        on_bracket = 0

        while lex and (lex.text() != ";"):
            if lex.text() in "[{(":
                on_bracket += 1
            elif lex.text() in "]})":
                on_bracket -= 1
            elif not on_bracket and lex.ent():
                utype = str(lex.ent().freetext("UnderlyingType"))

                if re.search(r"\[.*\]$", utype):
                    has_array = True

                ptr_ids.append(lex.ent().id())
            elif not on_bracket and (lex.text() == ","):
                break

            lex = lex.next(True, True)

    return ptr_ids, has_array


def check(check, file):
    OPERATORS = ["-", "<", "<=", ">=", ">"] if check.option().lookup('compare') else ["-"]
    lexer = file.lexer(True, 8, False, False)
    lex = lexer.first()

    while lex:
        if (lex.token() == "Operator") and (lex.text() in OPERATORS):
            op = lex.text()
            left_ent = get_left_op(lex)

            if not left_ent:
                lex = lex.next(True, True)
                continue

            right_ent, lex = get_right_op(lex)

            if not right_ent:
                continue
            
            left_ptrs, l_has_array = get_ptrs(left_ent)
            right_ptrs, r_has_array = get_ptrs(right_ent)

            if not (l_has_array or r_has_array):
                continue

            if not set(left_ptrs) & set(right_ptrs):
                error = ERR1 if (op == "-") else ERR2
                check.violation(None, file, lex.line_begin(), lex.column_begin(), error)

        lex = lex.next(True, True)