import re


ERR1 = 'A switch statement shall be a well-formed switch statement'


# The ID for the check
def ids():
    return ('M6-4-3', 'MISRA12_16.1', 'MISRA23_16.1', 'CPP_C046')


# The short name of the check
def name(id):
    return {
        'M6-4-3': 'Published Standards/AUTOSAR/A switch statement shall be a well-formed switch statement',
        'MISRA12_16.1': 'Published Standards/MISRA C 2012/16.1 All switch statements shall be well-formed',
        'MISRA23_16.1': 'Published Standards/MISRA C 2023/16.1 All switch statements shall be well-formed',
        'CPP_C046': 'All Checks/Language Specific/C and C++/Control Flow/All switch statements shall be well-formed',
    }[id]


def tags(id):
    return {
        'M6-4-3': [
            'Language: C',
            'Language: C++',
            'Standard: AUTOSAR',
            'Category: Required',
            'Automation: Automated',
            'Control Flow',
        ],
        'MISRA12_16.1': [
            'Language: C',
            'Standard: MISRA C 2012',
            'Category: Required',
            'Control Flow',
            ],
        'MISRA23_16.1': [
            'Language: C',
            'Standard: MISRA C 2023',
            'Category: Required',
            'Control Flow',
            ],
        'CPP_C046': [
            'Language: C',
            'Language: C++',
            'Control Flow',
        ],
    }.get(id)


# The short description of the check
def description():
    return 'A switch statement shall be a well-formed switch statement.'


# The long description of the check
def detailed_description():
    return """
<p><b>Rule</b></p>
<p>A switch statement shall be a well-formed switch statement.</p>
<p>A well-formed switch statement conforms to the following syntax rules, which are additional
to the C++ standard syntax rules. All syntax rules not defined below are as defined in
ISO/IEC 14882:2003 [1].</p>
<pre><code language="C++">switch-statement:
switch ( condition ) { case-label-clause-list default-label-clauseopt }
case-label-clause-list:
case-label case-clauseopt
case-label-clause-list case-label case-clauseopt
case-label:
case constant-expression :
case-clause:
case-block-seqopt break ;
case-block-seqopt throw assignment-expressionopt ;
{ statement-seqopt break ; }
{ statement-seqopt throw assignment-expressionopt ; }
default-label-clause:
default-label default-clause
default-label:
default :
default-clause:
case-clause
case-block:
expression_statement
compound_statement
selection_statement
iteration_statement
try_block
case-block-seq:
case-block
case-block-seq case-block
</code></pre>
<p>The following statements, which are permitted by C++, are explicitly not included within the
MISRA C++ switch syntax rules. Note, however, that they are permitted within the compound
statements forming the body of a switch-clause.</p>
<pre><code language="C++">labelled_statement
jump_statement
declaration_statement
</code></pre>
<p>The following terms are also used within the text of the rules:</p>
<pre><code language="C++">switch-label Either a case-label or default-label.
case-clause The code between any two switch-labels.
default-clause The code between the default-label and the end of the switch statement.
switch-clause Either a case-clause or a default-clause.
</code></pre>
<p><b>Rationale</b></p>
<p>The syntax for the switch statement in C++ is weak, allowing complex, unstructured behaviour.
The previous text describes the syntax for switch statements as defined by MISRA C++. This, and
the associated rules, imposes a simple and consistent structure on to the switch statement.</p>
<p><b>Note</b></p>
<p>In this checking, a switch is well-formed when the following cases are satisfied:</p>
<p>1. Default and non-empty clauses should have a break or return statement.</p>
<p>2. A clause before the default statement should have a break or return statement.</p>
<p><b>Example</b></p>
<pre><code language="C++">switch ( x )
{
case 0:
 ...
 break; // break is required here
case 1: // empty clause, break not required
case 2:
 break; // break is required here
default: // default clause is required
 break; // break is required here, in case a future
 // modification turns this into a case clause
}
</code></pre>
"""


# Tests the type of file
def test_entity(file):
    return file.kind().check('code file, header file')


def test_global():
    return False


def test_language(language):
    return language == 'C++'


def check(check, file):
    lexer = file.lexer(lookup_ents=False)

    for func_ref in file.filerefs("Define", "Function"):
        func_cfg = func_ref.ent().control_flow_graph()

        for node in func_cfg.nodes():
            if node.kind() != "switch":
                continue

            end_switch = node.end_node()
            has_default = False
            ill_formed = False

            for node_child in node.children():
                if not str(node_child.kind()).startswith("switch-"):
                    continue

                lex = lexer.lexeme(node_child.line_begin(), node_child.column_begin())
                has_exit = False

                while lex and (lex.line_begin() <= node_child.line_end()):
                    if (lex.text() == "default") and (lex.token() == "Keyword"):
                        has_default = True

                    lex = lex.next(True, True)

                while lex and lex.text() not in ["case", "default"] and (lex.line_begin() <= end_switch.line_end()):
                    if lex.text() in ["return", "break", "throw", "goto", "exit", "abort"] and (lex.token() in ["Keyword", "Identifier"]):
                        has_exit = True
                        break

                    lex = lex.next(True, True)

                if not has_exit:
                    ill_formed = True
                    break
                    
            if ill_formed or not has_default:
                check.violation(None, file, node.line_begin(), node.column_begin(), ERR1)