import re

ERR1 = "Pseudorandom numbers shall not be generated using the %1 function."

# The ID for the check
def ids():
    return ('A26-5-1', 'MISRA23_21.24')

# The short name of the check
def name(id):
    return {
        'A26-5-1': 'Published Standards/AUTOSAR/\
Pseudorandom numbers shall not be generated using std::rand()',
        'MISRA23_21.24': 'Published Standards/MISRA C 2023/21.24 The random number generator functions of <stdlib.h> shall not be used',
    }[id]



def tags(id):
    return {
        'A26-5-1': [
            'Language: C',
            'Language: C++',
            'Standard: AUTOSAR',
            'Category: Required',
            'Automation: Automated',
        ],
        'MISRA23_21.24': [
            'Language: C',
            'Language: C++',
            'Standard: MISRA C 2023',
            'Category: Required',
            'Automation: Automated',
        ],
    }.get(id)

# The long description of the check
def detailed_description(id):
    if id == 'MISRA23_21.24':
        return '''
<p><b>Amplification</b></p>
<p>The functions rand and srand shall not be used and no macro with one of these names shall be
expanded.</p>

<p><b>Rationale</b></p>
<p>The C Standard Library function rand() makes no guarantees as to the quality of the random
sequence produced.</p>
<p>The C Standard warns that the numbers generated by some implementations of the rand()
function have a short cycle and the results can be predictable. Applications with particular
requirements should use a generator that is known to be sufficient for their needs.</p>
<p>The srand() function is also included within this rule, as without any associated use of the rand()
function, its use is superfluous.</p>

<p><b>Example</b></p>
<pre><code language="C++">#include &lt;stdlib.h&gt;
int r = rand(); /* Non-compliant */</code></pre>
        '''

    return """\
<p><b>Rationale</b></p>
<p>Using a pseudo-random sequence of numbers requires that it is generated with good statistical properties. Some implementations of std::rand() function have a comparatively short cycle, as a result the numbers can be predictable. Using functionalities from &lt;random&gt; is recommended instead of using std::rand().</p>
<p>Note: std::random_shuffle should not be used, as it is deprecated since C++14 (see A1-1-1) and one of the available overloads is often implemented in terms of std::rand.</p>
<p><b>Example</b></p>
<pre><code language="C++">// $Id: A26-5-1.cpp 311495 2018-03-13 13:02:54Z michal.szczepankiewicz $

#include &lt;cstdlib&gt;
#include &lt;cstdint&gt;
#include &lt;ctime&gt;
#include &lt;iostream&gt;
#include &lt;random&gt;

int main()
{
std::srand(std::time(nullptr));
int r1 = std::rand() % 100; //non-compliant
std::cout &lt;&lt; "Random value using std::rand(): " &lt;&lt; r1 &lt;&lt; std::endl;

std::random_device rd;
std::default_random_engine eng{rd()};
std::uniform_int_distribution&lt;int&gt; ud{0, 100};
int r2 = ud(eng); //compliant
std::cout &lt;&lt; "Random value using std::random_device: " &lt;&lt; r2 &lt;&lt; std::endl;

return 0;
}
</code></pre>
<p><b>See also</b></p>
<p>SEI CERT C++ Coding Standard [10]: MSC50-CPP: Do not use std::rand() for generating pseudorandom numbers.
</p>"""

# Tests the type of file
def test_entity(file):
    return file.kind().check('header file,code file')

def define_options(check):
    if check.id() == 'MISRA23_21.24':
        check.option().choice('standard', 'This check differs slightly depending on which standard is selected here:', ['MISRA23_21.24', 'Other'], 'MISRA23_21.24')

    else:
        check.option().choice('standard', 'This check differs slightly depending on which standard is selected here:', ['MISRA23_21.24', 'Other'], 'Other')

# Optional - Return True if this check should be run on the entire project
# regardless of what files are selected. Should only be used for
# project-level checks
def test_global():
    return False

def test_language(language):
    return language == 'C++'

def check(check, file):
    not_allowed = ["rand","srand"] if (check.option().lookup("standard") == 'MISRA23_21.24') else ["rand","random_shuffle"]
    flagged = []

    for ref in file.filerefs("Call","Function"):
        if ref.ent().name() in not_allowed:
            check.violation(ref.ent(), file, ref.line(), ref.column(), ERR1, ref.ent().name())
