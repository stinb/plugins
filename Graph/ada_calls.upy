import understand


def name():
    """
    Required, the name of the graph.
    """
    return "Ada Calls and Calledby"


def style():
    """
    Optional, the name as it appears in the graph variants drop down.

    This defaults to "Custom"
    """
    return ""


def description():
    """
    Optional, the description to display in the plugin manager.
    """
    return '''A calls graph for Ada files, packages and functions.'''


def tags():
    """
    Optional, the tags to display in the plugin manager
    """
    return [
        'Target: Files',
        'Target: Packages',
        'Target: Functions',
        'Language: Ada',
    ]


def test_global(db):
    """
    Optional, return True if this graph is a project level graph

    If True, this graph will appear in the top level Graph Menu.
    """
    return False


def test_entity(ent):
    """
    Optional, return True if the graph exists for the given entity

    If True, this graph will appear in the Graphical Views menu for the
    entity.
    """
    return ent.kind().check("Ada File, Ada Package, Ada Procedure, Ada Function")


def test_architecture(arch):
    """
    Optional, return True if the graph exists for the given architecture

    If True, this graph will appear in the Graphical Views menu for the
    architecture.
    """
    return False


def init(graph, target):
    """
    Initialize the graph

    This function is called once on graph creation. Use it to define the
    available graph options and/or a legend.
    """
    # Use isinstance on the target to see if it's an entity, architecture, or
    # project level graph (if your plugin supports multiple). You can use the
    # target to customize available options.
    if isinstance(target, understand.Ent):
        graph.options().define("Depth", ["1", "2", "3", "4", "5"], "3")

    # Defining a legend is optional. You can add multiple entries to the legend.
    graph.legend().define("func", "circle", "Function", "#86E6F7")
    graph.legend().define("pack", "rectangle", "Package", "#2A74DB")
    graph.legend().define("file", "rectangle", "File", "#444444")


def get_package_cluster(graph, clusters, package):
    if not package:
        return graph
    elif package not in clusters:
        clusters[package] = graph.cluster(package.name())
        clusters[package].set("penwidth", "2")
        clusters[package].set("pencolor", "#2A74DB")

    return clusters[package]


def get_file_cluster(graph, clusters, file, package):
    if not file:
        return graph
    elif file not in clusters:
        parcluster = get_package_cluster(graph, clusters, package)
        clusters[file] = parcluster.cluster(file.name())
        clusters[file].set("penwidth", "2")
        clusters[file].set("pencolor", "#444444")

    return clusters[file]


def grabNode(graph, nodes, ent, clusters):
    """
    This is a custom function for this script to get a graphviz node
    """
    if ent in nodes:
        node = nodes[ent]
    else:
        dec_ref = ent.ref("Declarein Spec", "Package") or ent.ref("Declarein Stub", "Package") or ent.ref(
            "Declarein", "Package") or ent.ref("Declarein") or ent.ref("Definein")
        file_cluster = get_file_cluster(
            graph, clusters, dec_ref.file(), dec_ref.ent())
        node = file_cluster.node(ent.name(), ent)

        if ent.kind().check("Procedure, Function"):
            node.set("shape", "ellipse")
            node.set("color", "#86E6F7")
            node.set("penwidth", "2")

        nodes[ent] = node

    return node


def draw(graph, target):
    """
    Draw the graph

    The second argument can be a database, architecture, or an entity depending
    which test functions return True.
    """
    # Use set to change graph, node, and edge attributes
    graph.set("rankdir", "LR")

    # store the ent->graphviz node so that each entity node appears only
    # once no matter how many calls to it there are.
    nodes = dict()
    clusters = dict()

    # avoid visiting any node more than once
    visited = set()

    # If the graph can be more than one type, use isinstance to determine the type
    depth = 1
    curLevel = []

    if target.kind().check("Procedure, Function"):
        curLevel.append(target)
    else:
        kind_str = "Declare Spec" if str(
            target.name()).endswith(".ads") else "Declare"

        for pack_ref in target.refs(kind_str, "Package", True):
            for func_ref in pack_ref.ent().refs(kind_str, "Procedure, Function", True):
                curLevel.append(func_ref.ent())

        for func_ref in target.refs(kind_str, "Procedure, Function", True):
            curLevel.append(func_ref.ent())

    depth = int(graph.options().lookup("Depth"))

    # Loop over the levels of the tree
    while depth > 0:
        depth -= 1
        nextLevel = []
        for ent in curLevel:
            # avoid visiting nodes multiple times
            if ent in visited:
                continue
            visited.add(ent)

            # Get a graphviz node for the entity
            tail = grabNode(graph, nodes, ent, clusters)

            # Add edges for each call
            for ref in ent.refs("call, rename, override, "
                                "callby, renameby, overriddenby", unique=True):
                if ref.ent() in visited:
                    continue

                headEnt = ref.ent()
                head = grabNode(graph, nodes, headEnt, clusters)

                # create an edge
                if ref.kind().check("call, rename, overriddenby"):
                    nextLevel.append(headEnt)
                    edge = graph.edge(tail, head)
                else:
                    edge = graph.edge(head, tail)

                # Use sync so that clicking on the edge will visit the reference
                edge.sync(ref)

        curLevel = nextLevel
