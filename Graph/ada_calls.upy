import understand


def name():
    """
    Required, the name of the graph.
    """
    return "Ada Calls"


def style():
    """
    Optional, the name as it appears in the graph variants drop down.

    This defaults to "Custom"
    """
    return ""


def description():
    """
    Optional, the description to display in the plugin manager.
    """
    return '''A calls graph for Ada files, packages and functions.'''


def tags():
    """
    Optional, the tags to display in the plugin manager
    """
    return [
        'Target: Ada Files',
        'Target: Ada Packages',
        'Target: Ada Functions',
        'Language: Ada',
    ]


def test_global(db):
    """
    Optional, return True if this graph is a project level graph

    If True, this graph will appear in the top level Graph Menu.
    """
    return False


def test_entity(ent):
    """
    Optional, return True if the graph exists for the given entity

    If True, this graph will appear in the Graphical Views menu for the
    entity.
    """
    return ent.kind().check("Ada File, Ada Package, Ada Procedure")


def test_architecture(arch):
    """
    Optional, return True if the graph exists for the given architecture

    If True, this graph will appear in the Graphical Views menu for the
    architecture.
    """
    return False


def init(graph, target):
    """
    Initialize the graph

    This function is called once on graph creation. Use it to define the
    available graph options and/or a legend.
    """
    # Define options through the options object
    graph.options().define("Fill", ["On", "Off"], "Off")

    # Use isinstance on the target to see if it's an entity, architecture, or
    # project level graph (if your plugin supports multiple). You can use the
    # target to customize available options.
    if isinstance(target, understand.Ent):
        graph.options().define("Depth", ["1", "2", "3", "4", "5"], "3")

    # Defining a legend is optional. You can add multiple entries to the legend.
    graph.legend().define("func", "roundedrect", "Function", "blue", "#FFFFFF")


def grabNode(graph, nodes, ent):
    """
    This is a custom function for this script to get a graphviz node
    """
    if ent in nodes:
        node = nodes[ent]
    else:
        # passing an ent to the node object will automatically sync the entity.
        node = graph.node(ent.name(), ent)

        if ent.kind().check("unresolved"):
            # Set graph, node, and edge attributes with the set function.
            # See Graphviz documentation for available attributes.
            node.set("shape", "octagon")
            node.set("color", "gray")
            node.set("fillcolor", "white")
        nodes[ent] = node

    return node


def draw(graph, target):
    """
    Draw the graph

    The second argument can be a database, architecture, or an entity depending
    which test functions return True.
    """
    fore = "blue"
    back = "#FFFFFF"

    # Use options to lookup the current values
    if graph.options().lookup("Fill") == "On":
        fore = "#000000"
        back = "blue"

    # Use set to update the legend outside of init
    graph.legend().set("func", "fore", fore)
    graph.legend().set("func", "back", back)

    # Use set to change graph, node, and edge attributes
    graph.set("rankdir", "LR")

    # Use default to set the default attributes for graphs, nodes, and edges
    graph.default("color", fore, "node")
    graph.default("fillcolor", back, "node")
    graph.default("style", "filled,rounded", "node")
    graph.default("shape", "box", "node")

    # store the ent->graphviz node so that each entity node appears only
    # once no matter how many calls to it there are.
    nodes = dict()

    # avoid visiting any node more than once
    visited = set()

    # If the graph can be more than one type, use isinstance to determine the type
    depth = 1
    curLevel = []

    if target.kind().check("Procedure"):
        curLevel.append(target)
    else:
        for pack_ref in target.refs("Define, Declare", "Package", True):
            for func_ref in pack_ref.ent().refs("Define, Declare", "Procedure", True):
                curLevel.append(func_ref.ent())

        for func_ref in target.refs("Define, Declare", "Procedure", True):
            curLevel.append(func_ref.ent())

    depth = int(graph.options().lookup("Depth"))

    # Loop over the levels of the tree
    while depth > 0:
        depth -= 1
        nextLevel = []
        for ent in curLevel:

            # avoid visiting nodes multiple times
            if ent in visited:
                continue
            visited.add(ent)

            # Get a graphviz node for the entity
            tail = grabNode(graph, nodes, ent)

            # Add edges for each call
            for ref in ent.refs("call", unique=True):
                headEnt = ref.ent()
                nextLevel.append(headEnt)
                head = grabNode(graph, nodes, headEnt)

                # create an edge
                edge = graph.edge(tail, head)
                # Use sync so that clicking on the edge will visit the reference
                edge.sync(ref)
        curLevel = nextLevel
