#
#          Copyright (c) 2024, Scientific Toolworks, Inc.
#
# This file contains proprietary information of Scientific Toolworks, Inc.
# and is protected by federal copyright law. It may not be copied or
# distributed in any form or medium without prior written authorization
# from Scientific Toolworks, Inc.
#
# Author: Jason Haslam
#

import understand
import itertools
from qt import QtConcurrency

ERR = "Potential data race on variable `{}`"

def id():
  return "STI_DATA_RACE"

def name():
  return "SciTools/Data Race"

def tags():
  return [ "Severity: 0" ]

def description():
  return "Find variables with potential data races"

def test_entity(file):
  return file.kind().check("c file")

def test_global(file):
  return False

def define_options(check):
  pass

def check(check, file):
  db = check.db()
  cache = check.cache()

  main_entry_points = lookup_main_entry_points(db, cache)
  thread_entry_points = lookup_thread_entry_points(db, cache)
  if not main_entry_points or not thread_entry_points:
    return

  # Build a set of all shared variables.
  shared_vars = set()

  # Compare main entry points with all other threads separately. This is the
  # Cartesian product of main entry points with thread entry points. Compare
  # all other thread entry points with each other. This is all two element
  # subsequences of the thread entry points.
  for args in itertools.product(main_entry_points, thread_entry_points):
    shared_vars |= find_shared_variables(cache, *args)

  for args in itertools.combinations(thread_entry_points, r=2):
    shared_vars |= find_shared_variables(cache, *args)

  if not shared_vars:
    return

  # Emit violations for shared variables referenced in this file.
  for ref in file.filerefs("use,modify,set ~init", "object ~local"):
    var = ref.ent()
    if var in shared_vars:
      err = ERR.format(var.name())
      check.violation(var, file, ref.line(), ref.column(), err)

def find_shared_variables(cache, lhs_entry_point, rhs_entry_point):
  lhs_calls = lookup_calls(cache, lhs_entry_point)
  lhs_reads = set(lookup_reads(cache, lhs_entry_point, lhs_calls))
  lhs_writes = set(lookup_writes(cache, lhs_entry_point, lhs_calls))
  lhs_reads_writes = lhs_reads | lhs_writes

  rhs_calls = lookup_calls(cache, rhs_entry_point)
  rhs_reads = set(lookup_reads(cache, rhs_entry_point, rhs_calls))
  rhs_writes = set(lookup_writes(cache, rhs_entry_point, rhs_calls))
  rhs_reads_writes = rhs_reads | rhs_writes

  # Shared variables are the the ones that are written on the LHS thread and
  # read or written on the RHS thread, *or* the ones that are written on the
  # RHS thread and read or written on the LHS thread. That is, the union
  # of the intersections of writes from one thread with the union of the
  # reads and writes from the other thread.
  return ((lhs_writes & rhs_reads_writes) | (rhs_writes & lhs_reads_writes))

def lookup_main_entry_points(db, cache):
  result = cache.value("main_entry_points")
  if result is None:
    result = []
    if arch := db.lookup_arch("Main Entry Points"):
      result = arch.ents()
    cache.insert(result, "main_entry_points")
  return result

def lookup_thread_entry_points(db, cache):
  result = cache.value("thread_entry_points")
  if result is None:
    result = QtConcurrency(db).thread_entry_points()
    cache.insert(result, "thread_entry_points")
  return result

def lookup_calls(cache, entry_point):
  result = cache.value("calls", entry_point)
  if result is None:
    calls = set()
    visit_call_tree(calls, entry_point)
    result = list(calls)
    cache.insert(result, "calls", entry_point)
  return result

def visit_call_tree(result, root):
  if root not in result:
    result.add(root)
    for callee in root.ents("call", "function"):
      visit_call_tree(result, callee)

def lookup_reads(cache, entry_point, calls):
  result = cache.value("reads", entry_point)
  if result is None:
    reads = set()
    for call in calls:
      reads |= set(call.ents("use,modify", "object ~local"))
    result = list(reads)
    cache.insert(result, "reads", entry_point)
  return result

def lookup_writes(cache, entry_point, calls):
  result = cache.value("writes", entry_point)
  if result is None:
    writes = set()
    for call in calls:
      writes |= set(call.ents("modify,set ~init", "object ~local"))
    result = list(writes)
    cache.insert(result, "writes", entry_point)
  return result
