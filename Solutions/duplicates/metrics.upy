import und_lib.duplicates as duplicates
import understand

FILE_KINDSTR = "file ~unknown ~unresolved ~unparsed"

def ids():
  return ["DuplicateLinesOfCode", "DuplicateLinesOfCodePercent"]

def name(id):
  if id == "DuplicateLinesOfCodePercent":
    return "Duplicated Lines of Code Percentage"
  return "Duplicated Lines of Code"

def description(id):
  return """<p>The {} of unique lines that are duplicated.</p>
  <p>This metric plugin searches the entire project for duplicate lines. The
  number minimum number of lines to match and options to ignore whitespace and
  comments can be edited per project through the Project Configuration dialog
  metrics page.</p>

  <p>See also the interactive report
  <a href="und://plugin/ireport/Duplicate%20Lines%20of%20Code">Duplicate Lines of
  Code</a> and the check "Duplicate Lines of Code". There is also a
  <a href="https://blog.scitools.com/duplicate-lines-of-code/">blog
  article &#8599;</a> describing how duplicate lines are calculated. Duplicate lines
  of code are part of the Project Quality
  <a href="und://plugins/Solutions/.doc/manager_project_quality.md?filter=Solution%3A%22Project%20Quality%22">
  solution</a>.</p>
  """.format("number" if id == "DuplicateLinesOfCode" else "percent")

def tags(id):
  return [
    'Solution: Project Quality',
    'Target: Files',
    'Target: Architectures',
    'Target: Project',
    'Language: Any',
    'Duplicate Code'
  ]

def define_options(metric):
  duplicates.defineOptions(metric)

def is_integer(id):
   return id == "DuplicateLinesOfCode"

def test_entity(metric, ent):
  return hasattr(metric, "cache") and ent.kind().check(FILE_KINDSTR)

def test_architecture(metric, arch):
  return hasattr(metric, "cache")

def test_global(metric, db):
  return hasattr(metric, "cache")

def test_available(metric,entkindstr):
  # Kind check if requested
  if entkindstr:
    my_kinds = set(understand.Kind.list_entity(FILE_KINDSTR))
    test_kinds = set(understand.Kind.list_entity(entkindstr))
    return len(my_kinds.intersection(test_kinds)) > 0

  return True

def value(metric, target):
  ignores = duplicates.ignoresOption(metric)
  lines = duplicates.lineOption(metric)

  cachename = "Duplicates_{}_{}".format(lines, ",".join(ignores))

  cache = metric.cache(cachename)
  if cache.is_empty():
    # Find matches
    matches = duplicates.Matches(lines)

    for file in metric.db().ents(FILE_KINDSTR):
      matches.processFile(file, duplicates.fileLines(file,ignores)[0])

    # store
    cache.clear()
    total = 0
    duplLines = matches.duplicateLines()
    for file, lineset in duplLines.items():
      cache.insert(len(lineset), ent=file)
      total += len(lineset)
    cache.insert(total)

  # Return count from cache
  dupls = 0
  loc = 0
  if isinstance(target, understand.Db):
    dupls = cache.value(value=0)
    loc = target.metric("CountLineCode")
  elif isinstance(target, understand.Arch):
    for ent in target.ents(True):
      if ent.kind().check(FILE_KINDSTR):
        dupls += cache.value(ent=ent,value=0)
        loc += ent.metric("CountLineCode")
  else:
    dupls = cache.value(ent=target, value=0)
    loc = target.metric("CountLineCode")

  if metric.id() == "DuplicateLinesOfCodePercent":
    return dupls / loc if loc else 0
  return dupls

